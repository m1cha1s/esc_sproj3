/*
 * Copyright (c) 2024 Raspberry Pi Ltd. SPDX-License-Identifier: BSD-3-Clause
 *
 * @file     RP2040.h
 * @brief    CMSIS HeaderFile
 * @version  0.1
 * @date     Mon Sep 30 13:07:50 2024
 * @note     Generated by SVDConv V3.3.47+p96-g4288cb50
 *           from File '/Users/m1cha1s/Developer/esc_sproj3/RP2040.svd',
 *           last modified on Mon Sep 30 12:57:08 2024
 */


/** @addtogroup Raspberry Pi
  * @{
  */


/** @addtogroup RP2040
  * @{
  */


#ifndef RP2040_H
#define RP2040_H

#include "base/types.h"
#define uint32_t u32

#ifdef __cplusplus
extern "C" {
#endif


/** @addtogroup Configuration_of_CMSIS
  * @{
  */



/* =========================================================================================================================== */
/* ================                                Interrupt Number Definition                                ================ */
/* =========================================================================================================================== */

typedef enum {
/* =======================================  ARM Cortex-M0+ Specific Interrupt Numbers  ======================================= */
  Reset_IRQn                = -15,              /*!< -15  Reset Vector, invoked on Power up and warm reset                     */
  NonMaskableInt_IRQn       = -14,              /*!< -14  Non maskable Interrupt, cannot be stopped or preempted               */
  HardFault_IRQn            = -13,              /*!< -13  Hard Fault, all classes of Fault                                     */
  SVCall_IRQn               =  -5,              /*!< -5 System Service Call via SVC instruction                                */
  PendSV_IRQn               =  -2,              /*!< -2 Pendable request for system service                                    */
  SysTick_IRQn              =  -1,              /*!< -1 System Tick Timer                                                      */
/* ===========================================  RP2040 Specific Interrupt Numbers  =========================================== */
  TIMER_IRQ_0_IRQn          =   0,              /*!< 0  TIMER_IRQ_0                                                            */
  TIMER_IRQ_1_IRQn          =   1,              /*!< 1  TIMER_IRQ_1                                                            */
  TIMER_IRQ_2_IRQn          =   2,              /*!< 2  TIMER_IRQ_2                                                            */
  TIMER_IRQ_3_IRQn          =   3,              /*!< 3  TIMER_IRQ_3                                                            */
  PWM_IRQ_WRAP_IRQn         =   4,              /*!< 4  PWM_IRQ_WRAP                                                           */
  USBCTRL_IRQ_IRQn          =   5,              /*!< 5  USBCTRL_IRQ                                                            */
  XIP_IRQ_IRQn              =   6,              /*!< 6  XIP_IRQ                                                                */
  PIO0_IRQ_0_IRQn           =   7,              /*!< 7  PIO0_IRQ_0                                                             */
  PIO0_IRQ_1_IRQn           =   8,              /*!< 8  PIO0_IRQ_1                                                             */
  PIO1_IRQ_0_IRQn           =   9,              /*!< 9  PIO1_IRQ_0                                                             */
  PIO1_IRQ_1_IRQn           =  10,              /*!< 10 PIO1_IRQ_1                                                             */
  DMA_IRQ_0_IRQn            =  11,              /*!< 11 DMA_IRQ_0                                                              */
  DMA_IRQ_1_IRQn            =  12,              /*!< 12 DMA_IRQ_1                                                              */
  IO_IRQ_BANK0_IRQn         =  13,              /*!< 13 IO_IRQ_BANK0                                                           */
  IO_IRQ_QSPI_IRQn          =  14,              /*!< 14 IO_IRQ_QSPI                                                            */
  SIO_IRQ_PROC0_IRQn        =  15,              /*!< 15 SIO_IRQ_PROC0                                                          */
  SIO_IRQ_PROC1_IRQn        =  16,              /*!< 16 SIO_IRQ_PROC1                                                          */
  CLOCKS_IRQ_IRQn           =  17,              /*!< 17 CLOCKS_IRQ                                                             */
  SPI0_IRQ_IRQn             =  18,              /*!< 18 SPI0_IRQ                                                               */
  SPI1_IRQ_IRQn             =  19,              /*!< 19 SPI1_IRQ                                                               */
  UART0_IRQ_IRQn            =  20,              /*!< 20 UART0_IRQ                                                              */
  UART1_IRQ_IRQn            =  21,              /*!< 21 UART1_IRQ                                                              */
  ADC_IRQ_FIFO_IRQn         =  22,              /*!< 22 ADC_IRQ_FIFO                                                           */
  I2C0_IRQ_IRQn             =  23,              /*!< 23 I2C0_IRQ                                                               */
  I2C1_IRQ_IRQn             =  24,              /*!< 24 I2C1_IRQ                                                               */
  RTC_IRQ_IRQn              =  25               /*!< 25 RTC_IRQ                                                                */
} IRQn_Type;



/* =========================================================================================================================== */
/* ================                           Processor and Core Peripheral Section                           ================ */
/* =========================================================================================================================== */

/* ==========================  Configuration of the ARM Cortex-M0+ Processor and Core Peripherals  =========================== */
#define __CM0PLUS_REV                 0x0001U   /*!< CM0PLUS Core Revision                                                     */
#define __NVIC_PRIO_BITS               2        /*!< Number of Bits used for Priority Levels                                   */
#define __Vendor_SysTickConfig         0        /*!< Set to 1 if different SysTick Config is used                              */
#define __VTOR_PRESENT                 1        /*!< Set to 1 if CPU supports Vector Table Offset Register                     */
#define __MPU_PRESENT                  1        /*!< MPU present                                                               */
#define __FPU_PRESENT                  0        /*!< FPU present                                                               */


/** @} */ /* End of group Configuration_of_CMSIS */

#define __IM
#define __OM
#define __IOM


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                          RESETS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief RESETS (RESETS)
  */

typedef struct {                                /*!< RESETS Structure                                                          */
  
  union {
    __IOM uint32_t reg;                         /*!< Reset control. If a bit is set it means the peripheral is in
                                                     reset. 0 means the peripheral's reset is deasserted.                      */
    
    struct {
      __IOM uint32_t ADC        : 1;            /*!< ADC                                                                       */
      __IOM uint32_t BUSCTRL    : 1;            /*!< BUSCTRL                                                                   */
      __IOM uint32_t DMA        : 1;            /*!< DMA                                                                       */
      __IOM uint32_t I2C0       : 1;            /*!< I2C0                                                                      */
      __IOM uint32_t I2C1       : 1;            /*!< I2C1                                                                      */
      __IOM uint32_t IO_BANK0   : 1;            /*!< IO_BANK0                                                                  */
      __IOM uint32_t IO_QSPI    : 1;            /*!< IO_QSPI                                                                   */
      __IOM uint32_t JTAG       : 1;            /*!< JTAG                                                                      */
      __IOM uint32_t PADS_BANK0 : 1;            /*!< PADS_BANK0                                                                */
      __IOM uint32_t PADS_QSPI  : 1;            /*!< PADS_QSPI                                                                 */
      __IOM uint32_t PIO0       : 1;            /*!< PIO0                                                                      */
      __IOM uint32_t PIO1       : 1;            /*!< PIO1                                                                      */
      __IOM uint32_t PLL_SYS    : 1;            /*!< PLL_SYS                                                                   */
      __IOM uint32_t PLL_USB    : 1;            /*!< PLL_USB                                                                   */
      __IOM uint32_t PWM        : 1;            /*!< PWM                                                                       */
      __IOM uint32_t RTC        : 1;            /*!< RTC                                                                       */
      __IOM uint32_t SPI0       : 1;            /*!< SPI0                                                                      */
      __IOM uint32_t SPI1       : 1;            /*!< SPI1                                                                      */
      __IOM uint32_t SYSCFG     : 1;            /*!< SYSCFG                                                                    */
      __IOM uint32_t SYSINFO    : 1;            /*!< SYSINFO                                                                   */
      __IOM uint32_t TBMAN      : 1;            /*!< TBMAN                                                                     */
      __IOM uint32_t TIMER      : 1;            /*!< TIMER                                                                     */
      __IOM uint32_t UART0      : 1;            /*!< UART0                                                                     */
      __IOM uint32_t UART1      : 1;            /*!< UART1                                                                     */
      __IOM uint32_t USBCTRL    : 1;            /*!< USBCTRL                                                                   */
            uint32_t            : 7;
    } bit;
  } RESET;
  
  union {
    __IOM uint32_t reg;                         /*!< Watchdog select. If a bit is set then the watchdog will reset
                                                     this peripheral when the watchdog fires.                                  */
    
    struct {
      __IOM uint32_t ADC        : 1;            /*!< ADC                                                                       */
      __IOM uint32_t BUSCTRL    : 1;            /*!< BUSCTRL                                                                   */
      __IOM uint32_t DMA        : 1;            /*!< DMA                                                                       */
      __IOM uint32_t I2C0       : 1;            /*!< I2C0                                                                      */
      __IOM uint32_t I2C1       : 1;            /*!< I2C1                                                                      */
      __IOM uint32_t IO_BANK0   : 1;            /*!< IO_BANK0                                                                  */
      __IOM uint32_t IO_QSPI    : 1;            /*!< IO_QSPI                                                                   */
      __IOM uint32_t JTAG       : 1;            /*!< JTAG                                                                      */
      __IOM uint32_t PADS_BANK0 : 1;            /*!< PADS_BANK0                                                                */
      __IOM uint32_t PADS_QSPI  : 1;            /*!< PADS_QSPI                                                                 */
      __IOM uint32_t PIO0       : 1;            /*!< PIO0                                                                      */
      __IOM uint32_t PIO1       : 1;            /*!< PIO1                                                                      */
      __IOM uint32_t PLL_SYS    : 1;            /*!< PLL_SYS                                                                   */
      __IOM uint32_t PLL_USB    : 1;            /*!< PLL_USB                                                                   */
      __IOM uint32_t PWM        : 1;            /*!< PWM                                                                       */
      __IOM uint32_t RTC        : 1;            /*!< RTC                                                                       */
      __IOM uint32_t SPI0       : 1;            /*!< SPI0                                                                      */
      __IOM uint32_t SPI1       : 1;            /*!< SPI1                                                                      */
      __IOM uint32_t SYSCFG     : 1;            /*!< SYSCFG                                                                    */
      __IOM uint32_t SYSINFO    : 1;            /*!< SYSINFO                                                                   */
      __IOM uint32_t TBMAN      : 1;            /*!< TBMAN                                                                     */
      __IOM uint32_t TIMER      : 1;            /*!< TIMER                                                                     */
      __IOM uint32_t UART0      : 1;            /*!< UART0                                                                     */
      __IOM uint32_t UART1      : 1;            /*!< UART1                                                                     */
      __IOM uint32_t USBCTRL    : 1;            /*!< USBCTRL                                                                   */
            uint32_t            : 7;
    } bit;
  } WDSEL;
  
  union {
    __IOM uint32_t reg;                         /*!< Reset done. If a bit is set then a reset done signal has been
                                                     returned by the peripheral. This indicates that the peripheral's
                                                     registers are ready to be accessed.                                       */
    
    struct {
      __IM  uint32_t ADC        : 1;            /*!< ADC                                                                       */
      __IM  uint32_t BUSCTRL    : 1;            /*!< BUSCTRL                                                                   */
      __IM  uint32_t DMA        : 1;            /*!< DMA                                                                       */
      __IM  uint32_t I2C0       : 1;            /*!< I2C0                                                                      */
      __IM  uint32_t I2C1       : 1;            /*!< I2C1                                                                      */
      __IM  uint32_t IO_BANK0   : 1;            /*!< IO_BANK0                                                                  */
      __IM  uint32_t IO_QSPI    : 1;            /*!< IO_QSPI                                                                   */
      __IM  uint32_t JTAG       : 1;            /*!< JTAG                                                                      */
      __IM  uint32_t PADS_BANK0 : 1;            /*!< PADS_BANK0                                                                */
      __IM  uint32_t PADS_QSPI  : 1;            /*!< PADS_QSPI                                                                 */
      __IM  uint32_t PIO0       : 1;            /*!< PIO0                                                                      */
      __IM  uint32_t PIO1       : 1;            /*!< PIO1                                                                      */
      __IM  uint32_t PLL_SYS    : 1;            /*!< PLL_SYS                                                                   */
      __IM  uint32_t PLL_USB    : 1;            /*!< PLL_USB                                                                   */
      __IM  uint32_t PWM        : 1;            /*!< PWM                                                                       */
      __IM  uint32_t RTC        : 1;            /*!< RTC                                                                       */
      __IM  uint32_t SPI0       : 1;            /*!< SPI0                                                                      */
      __IM  uint32_t SPI1       : 1;            /*!< SPI1                                                                      */
      __IM  uint32_t SYSCFG     : 1;            /*!< SYSCFG                                                                    */
      __IM  uint32_t SYSINFO    : 1;            /*!< SYSINFO                                                                   */
      __IM  uint32_t TBMAN      : 1;            /*!< TBMAN                                                                     */
      __IM  uint32_t TIMER      : 1;            /*!< TIMER                                                                     */
      __IM  uint32_t UART0      : 1;            /*!< UART0                                                                     */
      __IM  uint32_t UART1      : 1;            /*!< UART1                                                                     */
      __IM  uint32_t USBCTRL    : 1;            /*!< USBCTRL                                                                   */
            uint32_t            : 7;
    } bit;
  } RESET_DONE;
} RESETS_Type;                                  /*!< Size = 12 (0xc)                                                           */



/* =========================================================================================================================== */
/* ================                                            PSM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief PSM (PSM)
  */

typedef struct {                                /*!< PSM Structure                                                             */
  
  union {
    __IOM uint32_t reg;                         /*!< Force block out of reset (i.e. power it on)                               */
    
    struct {
      __IOM uint32_t ROSC       : 1;            /*!< ROSC                                                                      */
      __IOM uint32_t XOSC       : 1;            /*!< XOSC                                                                      */
      __IOM uint32_t CLOCKS     : 1;            /*!< CLOCKS                                                                    */
      __IOM uint32_t RESETS     : 1;            /*!< RESETS                                                                    */
      __IOM uint32_t BUSFABRIC  : 1;            /*!< BUSFABRIC                                                                 */
      __IOM uint32_t ROM        : 1;            /*!< ROM                                                                       */
      __IOM uint32_t SRAM0      : 1;            /*!< SRAM0                                                                     */
      __IOM uint32_t SRAM1      : 1;            /*!< SRAM1                                                                     */
      __IOM uint32_t SRAM2      : 1;            /*!< SRAM2                                                                     */
      __IOM uint32_t SRAM3      : 1;            /*!< SRAM3                                                                     */
      __IOM uint32_t SRAM4      : 1;            /*!< SRAM4                                                                     */
      __IOM uint32_t SRAM5      : 1;            /*!< SRAM5                                                                     */
      __IOM uint32_t XIP        : 1;            /*!< XIP                                                                       */
      __IOM uint32_t VREG_AND_CHIP_RESET : 1;   /*!< VREG_AND_CHIP_RESET                                                       */
      __IOM uint32_t SIO        : 1;            /*!< SIO                                                                       */
      __IOM uint32_t PROC0      : 1;            /*!< PROC0                                                                     */
      __IOM uint32_t PROC1      : 1;            /*!< PROC1                                                                     */
            uint32_t            : 15;
    } bit;
  } FRCE_ON;
  
  union {
    __IOM uint32_t reg;                         /*!< Force into reset (i.e. power it off)                                      */
    
    struct {
      __IOM uint32_t ROSC       : 1;            /*!< ROSC                                                                      */
      __IOM uint32_t XOSC       : 1;            /*!< XOSC                                                                      */
      __IOM uint32_t CLOCKS     : 1;            /*!< CLOCKS                                                                    */
      __IOM uint32_t RESETS     : 1;            /*!< RESETS                                                                    */
      __IOM uint32_t BUSFABRIC  : 1;            /*!< BUSFABRIC                                                                 */
      __IOM uint32_t ROM        : 1;            /*!< ROM                                                                       */
      __IOM uint32_t SRAM0      : 1;            /*!< SRAM0                                                                     */
      __IOM uint32_t SRAM1      : 1;            /*!< SRAM1                                                                     */
      __IOM uint32_t SRAM2      : 1;            /*!< SRAM2                                                                     */
      __IOM uint32_t SRAM3      : 1;            /*!< SRAM3                                                                     */
      __IOM uint32_t SRAM4      : 1;            /*!< SRAM4                                                                     */
      __IOM uint32_t SRAM5      : 1;            /*!< SRAM5                                                                     */
      __IOM uint32_t XIP        : 1;            /*!< XIP                                                                       */
      __IOM uint32_t VREG_AND_CHIP_RESET : 1;   /*!< VREG_AND_CHIP_RESET                                                       */
      __IOM uint32_t SIO        : 1;            /*!< SIO                                                                       */
      __IOM uint32_t PROC0      : 1;            /*!< PROC0                                                                     */
      __IOM uint32_t PROC1      : 1;            /*!< PROC1                                                                     */
            uint32_t            : 15;
    } bit;
  } FRCE_OFF;
  
  union {
    __IOM uint32_t reg;                         /*!< Set to 1 if this peripheral should be reset when the watchdog
                                                     fires.                                                                    */
    
    struct {
      __IOM uint32_t ROSC       : 1;            /*!< ROSC                                                                      */
      __IOM uint32_t XOSC       : 1;            /*!< XOSC                                                                      */
      __IOM uint32_t CLOCKS     : 1;            /*!< CLOCKS                                                                    */
      __IOM uint32_t RESETS     : 1;            /*!< RESETS                                                                    */
      __IOM uint32_t BUSFABRIC  : 1;            /*!< BUSFABRIC                                                                 */
      __IOM uint32_t ROM        : 1;            /*!< ROM                                                                       */
      __IOM uint32_t SRAM0      : 1;            /*!< SRAM0                                                                     */
      __IOM uint32_t SRAM1      : 1;            /*!< SRAM1                                                                     */
      __IOM uint32_t SRAM2      : 1;            /*!< SRAM2                                                                     */
      __IOM uint32_t SRAM3      : 1;            /*!< SRAM3                                                                     */
      __IOM uint32_t SRAM4      : 1;            /*!< SRAM4                                                                     */
      __IOM uint32_t SRAM5      : 1;            /*!< SRAM5                                                                     */
      __IOM uint32_t XIP        : 1;            /*!< XIP                                                                       */
      __IOM uint32_t VREG_AND_CHIP_RESET : 1;   /*!< VREG_AND_CHIP_RESET                                                       */
      __IOM uint32_t SIO        : 1;            /*!< SIO                                                                       */
      __IOM uint32_t PROC0      : 1;            /*!< PROC0                                                                     */
      __IOM uint32_t PROC1      : 1;            /*!< PROC1                                                                     */
            uint32_t            : 15;
    } bit;
  } WDSEL;
  
  union {
    __IOM uint32_t reg;                         /*!< Indicates the peripheral's registers are ready to access.                 */
    
    struct {
      __IM  uint32_t ROSC       : 1;            /*!< ROSC                                                                      */
      __IM  uint32_t XOSC       : 1;            /*!< XOSC                                                                      */
      __IM  uint32_t CLOCKS     : 1;            /*!< CLOCKS                                                                    */
      __IM  uint32_t RESETS     : 1;            /*!< RESETS                                                                    */
      __IM  uint32_t BUSFABRIC  : 1;            /*!< BUSFABRIC                                                                 */
      __IM  uint32_t ROM        : 1;            /*!< ROM                                                                       */
      __IM  uint32_t SRAM0      : 1;            /*!< SRAM0                                                                     */
      __IM  uint32_t SRAM1      : 1;            /*!< SRAM1                                                                     */
      __IM  uint32_t SRAM2      : 1;            /*!< SRAM2                                                                     */
      __IM  uint32_t SRAM3      : 1;            /*!< SRAM3                                                                     */
      __IM  uint32_t SRAM4      : 1;            /*!< SRAM4                                                                     */
      __IM  uint32_t SRAM5      : 1;            /*!< SRAM5                                                                     */
      __IM  uint32_t XIP        : 1;            /*!< XIP                                                                       */
      __IM  uint32_t VREG_AND_CHIP_RESET : 1;   /*!< VREG_AND_CHIP_RESET                                                       */
      __IM  uint32_t SIO        : 1;            /*!< SIO                                                                       */
      __IM  uint32_t PROC0      : 1;            /*!< PROC0                                                                     */
      __IM  uint32_t PROC1      : 1;            /*!< PROC1                                                                     */
            uint32_t            : 15;
    } bit;
  } DONE;
} PSM_Type;                                     /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                          CLOCKS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief CLOCKS (CLOCKS)
  */

typedef struct {                                /*!< CLOCKS Structure                                                          */
  
  union {
    __IOM uint32_t reg;                         /*!< Clock control, can be changed on-the-fly (except for auxsrc)              */
    
    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 4;            /*!< Selects the auxiliary clock source, will glitch when switching            */
            uint32_t            : 1;
      __IOM uint32_t KILL       : 1;            /*!< Asynchronously kills the clock generator                                  */
      __IOM uint32_t ENABLE     : 1;            /*!< Starts and stops the clock generator cleanly                              */
      __IOM uint32_t DC50       : 1;            /*!< Enables duty cycle correction for odd divisors                            */
            uint32_t            : 3;
      __IOM uint32_t PHASE      : 2;            /*!< This delays the enable signal by up to 3 cycles of the input
                                                     clock This must be set before the clock is enabled to have
                                                     any effect                                                                */
            uint32_t            : 2;
      __IOM uint32_t NUDGE      : 1;            /*!< An edge on this signal shifts the phase of the output by 1 cycle
                                                     of the input clock This can be done at any time                           */
            uint32_t            : 11;
    } bit;
  } CLK_GPOUT0_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock divisor, can be changed on-the-fly                                  */
    
    struct {
      __IOM uint32_t FRAC       : 8;            /*!< Fractional component of the divisor                                       */
      __IOM uint32_t INT        : 24;           /*!< Integer component of the divisor, 0 -> divide by 2^16                     */
    } bit;
  } CLK_GPOUT0_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Indicates which SRC is currently selected by the glitchless
                                                     mux (one-hot).                                                            */
    
    struct {
      __IM  uint32_t CLK_GPOUT0_SELECTED : 32;  /*!< This slice does not have a glitchless mux (only the AUX_SRC
                                                     field is present, not SRC) so this register is hardwired
                                                     to 0x1.                                                                   */
    } bit;
  } CLK_GPOUT0_SELECTED;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock control, can be changed on-the-fly (except for auxsrc)              */
    
    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 4;            /*!< Selects the auxiliary clock source, will glitch when switching            */
            uint32_t            : 1;
      __IOM uint32_t KILL       : 1;            /*!< Asynchronously kills the clock generator                                  */
      __IOM uint32_t ENABLE     : 1;            /*!< Starts and stops the clock generator cleanly                              */
      __IOM uint32_t DC50       : 1;            /*!< Enables duty cycle correction for odd divisors                            */
            uint32_t            : 3;
      __IOM uint32_t PHASE      : 2;            /*!< This delays the enable signal by up to 3 cycles of the input
                                                     clock This must be set before the clock is enabled to have
                                                     any effect                                                                */
            uint32_t            : 2;
      __IOM uint32_t NUDGE      : 1;            /*!< An edge on this signal shifts the phase of the output by 1 cycle
                                                     of the input clock This can be done at any time                           */
            uint32_t            : 11;
    } bit;
  } CLK_GPOUT1_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock divisor, can be changed on-the-fly                                  */
    
    struct {
      __IOM uint32_t FRAC       : 8;            /*!< Fractional component of the divisor                                       */
      __IOM uint32_t INT        : 24;           /*!< Integer component of the divisor, 0 -> divide by 2^16                     */
    } bit;
  } CLK_GPOUT1_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Indicates which SRC is currently selected by the glitchless
                                                     mux (one-hot).                                                            */
    
    struct {
      __IM  uint32_t CLK_GPOUT1_SELECTED : 32;  /*!< This slice does not have a glitchless mux (only the AUX_SRC
                                                     field is present, not SRC) so this register is hardwired
                                                     to 0x1.                                                                   */
    } bit;
  } CLK_GPOUT1_SELECTED;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock control, can be changed on-the-fly (except for auxsrc)              */
    
    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 4;            /*!< Selects the auxiliary clock source, will glitch when switching            */
            uint32_t            : 1;
      __IOM uint32_t KILL       : 1;            /*!< Asynchronously kills the clock generator                                  */
      __IOM uint32_t ENABLE     : 1;            /*!< Starts and stops the clock generator cleanly                              */
      __IOM uint32_t DC50       : 1;            /*!< Enables duty cycle correction for odd divisors                            */
            uint32_t            : 3;
      __IOM uint32_t PHASE      : 2;            /*!< This delays the enable signal by up to 3 cycles of the input
                                                     clock This must be set before the clock is enabled to have
                                                     any effect                                                                */
            uint32_t            : 2;
      __IOM uint32_t NUDGE      : 1;            /*!< An edge on this signal shifts the phase of the output by 1 cycle
                                                     of the input clock This can be done at any time                           */
            uint32_t            : 11;
    } bit;
  } CLK_GPOUT2_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock divisor, can be changed on-the-fly                                  */
    
    struct {
      __IOM uint32_t FRAC       : 8;            /*!< Fractional component of the divisor                                       */
      __IOM uint32_t INT        : 24;           /*!< Integer component of the divisor, 0 -> divide by 2^16                     */
    } bit;
  } CLK_GPOUT2_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Indicates which SRC is currently selected by the glitchless
                                                     mux (one-hot).                                                            */
    
    struct {
      __IM  uint32_t CLK_GPOUT2_SELECTED : 32;  /*!< This slice does not have a glitchless mux (only the AUX_SRC
                                                     field is present, not SRC) so this register is hardwired
                                                     to 0x1.                                                                   */
    } bit;
  } CLK_GPOUT2_SELECTED;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock control, can be changed on-the-fly (except for auxsrc)              */
    
    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 4;            /*!< Selects the auxiliary clock source, will glitch when switching            */
            uint32_t            : 1;
      __IOM uint32_t KILL       : 1;            /*!< Asynchronously kills the clock generator                                  */
      __IOM uint32_t ENABLE     : 1;            /*!< Starts and stops the clock generator cleanly                              */
      __IOM uint32_t DC50       : 1;            /*!< Enables duty cycle correction for odd divisors                            */
            uint32_t            : 3;
      __IOM uint32_t PHASE      : 2;            /*!< This delays the enable signal by up to 3 cycles of the input
                                                     clock This must be set before the clock is enabled to have
                                                     any effect                                                                */
            uint32_t            : 2;
      __IOM uint32_t NUDGE      : 1;            /*!< An edge on this signal shifts the phase of the output by 1 cycle
                                                     of the input clock This can be done at any time                           */
            uint32_t            : 11;
    } bit;
  } CLK_GPOUT3_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock divisor, can be changed on-the-fly                                  */
    
    struct {
      __IOM uint32_t FRAC       : 8;            /*!< Fractional component of the divisor                                       */
      __IOM uint32_t INT        : 24;           /*!< Integer component of the divisor, 0 -> divide by 2^16                     */
    } bit;
  } CLK_GPOUT3_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Indicates which SRC is currently selected by the glitchless
                                                     mux (one-hot).                                                            */
    
    struct {
      __IM  uint32_t CLK_GPOUT3_SELECTED : 32;  /*!< This slice does not have a glitchless mux (only the AUX_SRC
                                                     field is present, not SRC) so this register is hardwired
                                                     to 0x1.                                                                   */
    } bit;
  } CLK_GPOUT3_SELECTED;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock control, can be changed on-the-fly (except for auxsrc)              */
    
    struct {
      __IOM uint32_t SRC        : 2;            /*!< Selects the clock source glitchlessly, can be changed on-the-fly          */
            uint32_t            : 3;
      __IOM uint32_t AUXSRC     : 2;            /*!< Selects the auxiliary clock source, will glitch when switching            */
            uint32_t            : 25;
    } bit;
  } CLK_REF_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock divisor, can be changed on-the-fly                                  */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t INT        : 2;            /*!< Integer component of the divisor, 0 -> divide by 2^16                     */
            uint32_t            : 22;
    } bit;
  } CLK_REF_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Indicates which SRC is currently selected by the glitchless
                                                     mux (one-hot).                                                            */
    
    struct {
      __IM  uint32_t CLK_REF_SELECTED : 32;     /*!< The glitchless multiplexer does not switch instantaneously (to
                                                     avoid glitches), so software should poll this register
                                                     to wait for the switch to complete. This register contains
                                                     one decoded bit for each of the clock sources enumerated
                                                     in the CTRL SRC field. At most one of these bits will be
                                                     set at any time, indicating that clock is currently present
                                                     at the output of the glitchless mux. Whilst switching is
                                                     in progress, this register may briefly show all-0s.                       */
    } bit;
  } CLK_REF_SELECTED;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock control, can be changed on-the-fly (except for auxsrc)              */
    
    struct {
      __IOM uint32_t SRC        : 1;            /*!< Selects the clock source glitchlessly, can be changed on-the-fly          */
            uint32_t            : 4;
      __IOM uint32_t AUXSRC     : 3;            /*!< Selects the auxiliary clock source, will glitch when switching            */
            uint32_t            : 24;
    } bit;
  } CLK_SYS_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock divisor, can be changed on-the-fly                                  */
    
    struct {
      __IOM uint32_t FRAC       : 8;            /*!< Fractional component of the divisor                                       */
      __IOM uint32_t INT        : 24;           /*!< Integer component of the divisor, 0 -> divide by 2^16                     */
    } bit;
  } CLK_SYS_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Indicates which SRC is currently selected by the glitchless
                                                     mux (one-hot).                                                            */
    
    struct {
      __IM  uint32_t CLK_SYS_SELECTED : 32;     /*!< The glitchless multiplexer does not switch instantaneously (to
                                                     avoid glitches), so software should poll this register
                                                     to wait for the switch to complete. This register contains
                                                     one decoded bit for each of the clock sources enumerated
                                                     in the CTRL SRC field. At most one of these bits will be
                                                     set at any time, indicating that clock is currently present
                                                     at the output of the glitchless mux. Whilst switching is
                                                     in progress, this register may briefly show all-0s.                       */
    } bit;
  } CLK_SYS_SELECTED;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock control, can be changed on-the-fly (except for auxsrc)              */
    
    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 3;            /*!< Selects the auxiliary clock source, will glitch when switching            */
            uint32_t            : 2;
      __IOM uint32_t KILL       : 1;            /*!< Asynchronously kills the clock generator                                  */
      __IOM uint32_t ENABLE     : 1;            /*!< Starts and stops the clock generator cleanly                              */
            uint32_t            : 20;
    } bit;
  } CLK_PERI_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock divisor, can be changed on-the-fly                                  */
    
    struct {
      __IOM uint32_t FRAC       : 8;            /*!< Fractional component of the divisor                                       */
      __IOM uint32_t INT        : 24;           /*!< Integer component of the divisor, 0 -> divide by 2^16                     */
    } bit;
  } CLK_PERI_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Indicates which SRC is currently selected by the glitchless
                                                     mux (one-hot).                                                            */
    
    struct {
      __IM  uint32_t CLK_PERI_SELECTED : 32;    /*!< This slice does not have a glitchless mux (only the AUX_SRC
                                                     field is present, not SRC) so this register is hardwired
                                                     to 0x1.                                                                   */
    } bit;
  } CLK_PERI_SELECTED;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock control, can be changed on-the-fly (except for auxsrc)              */
    
    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 3;            /*!< Selects the auxiliary clock source, will glitch when switching            */
            uint32_t            : 2;
      __IOM uint32_t KILL       : 1;            /*!< Asynchronously kills the clock generator                                  */
      __IOM uint32_t ENABLE     : 1;            /*!< Starts and stops the clock generator cleanly                              */
            uint32_t            : 4;
      __IOM uint32_t PHASE      : 2;            /*!< This delays the enable signal by up to 3 cycles of the input
                                                     clock This must be set before the clock is enabled to have
                                                     any effect                                                                */
            uint32_t            : 2;
      __IOM uint32_t NUDGE      : 1;            /*!< An edge on this signal shifts the phase of the output by 1 cycle
                                                     of the input clock This can be done at any time                           */
            uint32_t            : 11;
    } bit;
  } CLK_USB_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock divisor, can be changed on-the-fly                                  */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t INT        : 2;            /*!< Integer component of the divisor, 0 -> divide by 2^16                     */
            uint32_t            : 22;
    } bit;
  } CLK_USB_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Indicates which SRC is currently selected by the glitchless
                                                     mux (one-hot).                                                            */
    
    struct {
      __IM  uint32_t CLK_USB_SELECTED : 32;     /*!< This slice does not have a glitchless mux (only the AUX_SRC
                                                     field is present, not SRC) so this register is hardwired
                                                     to 0x1.                                                                   */
    } bit;
  } CLK_USB_SELECTED;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock control, can be changed on-the-fly (except for auxsrc)              */
    
    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 3;            /*!< Selects the auxiliary clock source, will glitch when switching            */
            uint32_t            : 2;
      __IOM uint32_t KILL       : 1;            /*!< Asynchronously kills the clock generator                                  */
      __IOM uint32_t ENABLE     : 1;            /*!< Starts and stops the clock generator cleanly                              */
            uint32_t            : 4;
      __IOM uint32_t PHASE      : 2;            /*!< This delays the enable signal by up to 3 cycles of the input
                                                     clock This must be set before the clock is enabled to have
                                                     any effect                                                                */
            uint32_t            : 2;
      __IOM uint32_t NUDGE      : 1;            /*!< An edge on this signal shifts the phase of the output by 1 cycle
                                                     of the input clock This can be done at any time                           */
            uint32_t            : 11;
    } bit;
  } CLK_ADC_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock divisor, can be changed on-the-fly                                  */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t INT        : 2;            /*!< Integer component of the divisor, 0 -> divide by 2^16                     */
            uint32_t            : 22;
    } bit;
  } CLK_ADC_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Indicates which SRC is currently selected by the glitchless
                                                     mux (one-hot).                                                            */
    
    struct {
      __IM  uint32_t CLK_ADC_SELECTED : 32;     /*!< This slice does not have a glitchless mux (only the AUX_SRC
                                                     field is present, not SRC) so this register is hardwired
                                                     to 0x1.                                                                   */
    } bit;
  } CLK_ADC_SELECTED;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock control, can be changed on-the-fly (except for auxsrc)              */
    
    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 3;            /*!< Selects the auxiliary clock source, will glitch when switching            */
            uint32_t            : 2;
      __IOM uint32_t KILL       : 1;            /*!< Asynchronously kills the clock generator                                  */
      __IOM uint32_t ENABLE     : 1;            /*!< Starts and stops the clock generator cleanly                              */
            uint32_t            : 4;
      __IOM uint32_t PHASE      : 2;            /*!< This delays the enable signal by up to 3 cycles of the input
                                                     clock This must be set before the clock is enabled to have
                                                     any effect                                                                */
            uint32_t            : 2;
      __IOM uint32_t NUDGE      : 1;            /*!< An edge on this signal shifts the phase of the output by 1 cycle
                                                     of the input clock This can be done at any time                           */
            uint32_t            : 11;
    } bit;
  } CLK_RTC_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock divisor, can be changed on-the-fly                                  */
    
    struct {
      __IOM uint32_t FRAC       : 8;            /*!< Fractional component of the divisor                                       */
      __IOM uint32_t INT        : 24;           /*!< Integer component of the divisor, 0 -> divide by 2^16                     */
    } bit;
  } CLK_RTC_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Indicates which SRC is currently selected by the glitchless
                                                     mux (one-hot).                                                            */
    
    struct {
      __IM  uint32_t CLK_RTC_SELECTED : 32;     /*!< This slice does not have a glitchless mux (only the AUX_SRC
                                                     field is present, not SRC) so this register is hardwired
                                                     to 0x1.                                                                   */
    } bit;
  } CLK_RTC_SELECTED;
  
  union {
    __IOM uint32_t reg;                         /*!< CLK_SYS_RESUS_CTRL                                                        */
    
    struct {
      __IOM uint32_t TIMEOUT    : 8;            /*!< This is expressed as a number of clk_ref cycles and must be
                                                     >= 2x clk_ref_freq/min_clk_tst_freq                                       */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable resus                                                              */
            uint32_t            : 3;
      __IOM uint32_t FRCE       : 1;            /*!< Force a resus, for test purposes only                                     */
            uint32_t            : 3;
      __IOM uint32_t CLEAR      : 1;            /*!< For clearing the resus after the fault that triggered it has
                                                     been corrected                                                            */
            uint32_t            : 15;
    } bit;
  } CLK_SYS_RESUS_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< CLK_SYS_RESUS_STATUS                                                      */
    
    struct {
      __IM  uint32_t RESUSSED   : 1;            /*!< Clock has been resuscitated, correct the error then send ctrl_clear=1     */
            uint32_t            : 31;
    } bit;
  } CLK_SYS_RESUS_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< Reference clock frequency in kHz                                          */
    
    struct {
      __IOM uint32_t FC0_REF_KHZ : 20;          /*!< FC0_REF_KHZ                                                               */
            uint32_t            : 12;
    } bit;
  } FC0_REF_KHZ;
  
  union {
    __IOM uint32_t reg;                         /*!< Minimum pass frequency in kHz. This is optional. Set to 0 if
                                                     you are not using the pass/fail flags                                     */
    
    struct {
      __IOM uint32_t FC0_MIN_KHZ : 25;          /*!< FC0_MIN_KHZ                                                               */
            uint32_t            : 7;
    } bit;
  } FC0_MIN_KHZ;
  
  union {
    __IOM uint32_t reg;                         /*!< Maximum pass frequency in kHz. This is optional. Set to 0x1ffffff
                                                     if you are not using the pass/fail flags                                  */
    
    struct {
      __IOM uint32_t FC0_MAX_KHZ : 25;          /*!< FC0_MAX_KHZ                                                               */
            uint32_t            : 7;
    } bit;
  } FC0_MAX_KHZ;
  
  union {
    __IOM uint32_t reg;                         /*!< Delays the start of frequency counting to allow the mux to settle
                                                     Delay is measured in multiples of the reference clock period              */
    
    struct {
      __IOM uint32_t FC0_DELAY  : 3;            /*!< FC0_DELAY                                                                 */
            uint32_t            : 29;
    } bit;
  } FC0_DELAY;
  
  union {
    __IOM uint32_t reg;                         /*!< The test interval is 0.98us * 2**interval, but let's call it
                                                     1us * 2**interval The default gives a test interval of
                                                     250us                                                                     */
    
    struct {
      __IOM uint32_t FC0_INTERVAL : 4;          /*!< FC0_INTERVAL                                                              */
            uint32_t            : 28;
    } bit;
  } FC0_INTERVAL;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock sent to frequency counter, set to 0 when not required
                                                     Writing to this register initiates the frequency count                    */
    
    struct {
      __IOM uint32_t FC0_SRC    : 8;            /*!< FC0_SRC                                                                   */
            uint32_t            : 24;
    } bit;
  } FC0_SRC;
  
  union {
    __IOM uint32_t reg;                         /*!< Frequency counter status                                                  */
    
    struct {
      __IM  uint32_t PASS       : 1;            /*!< Test passed                                                               */
            uint32_t            : 3;
      __IM  uint32_t DONE       : 1;            /*!< Test complete                                                             */
            uint32_t            : 3;
      __IM  uint32_t RUNNING    : 1;            /*!< Test running                                                              */
            uint32_t            : 3;
      __IM  uint32_t WAITING    : 1;            /*!< Waiting for test clock to start                                           */
            uint32_t            : 3;
      __IM  uint32_t FAIL       : 1;            /*!< Test failed                                                               */
            uint32_t            : 3;
      __IM  uint32_t SLOW       : 1;            /*!< Test clock slower than expected, only valid when status_done=1            */
            uint32_t            : 3;
      __IM  uint32_t FAST       : 1;            /*!< Test clock faster than expected, only valid when status_done=1            */
            uint32_t            : 3;
      __IM  uint32_t DIED       : 1;            /*!< Test clock stopped during test                                            */
            uint32_t            : 3;
    } bit;
  } FC0_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< Result of frequency measurement, only valid when status_done=1            */
    
    struct {
      __IM  uint32_t FRAC       : 5;            /*!< FRAC                                                                      */
      __IM  uint32_t KHZ        : 25;           /*!< KHZ                                                                       */
            uint32_t            : 2;
    } bit;
  } FC0_RESULT;
  
  union {
    __IOM uint32_t reg;                         /*!< enable clock in wake mode                                                 */
    
    struct {
      __IOM uint32_t CLK_SYS_CLOCKS : 1;        /*!< CLK_SYS_CLOCKS                                                            */
      __IOM uint32_t CLK_ADC_ADC : 1;           /*!< CLK_ADC_ADC                                                               */
      __IOM uint32_t CLK_SYS_ADC : 1;           /*!< CLK_SYS_ADC                                                               */
      __IOM uint32_t CLK_SYS_BUSCTRL : 1;       /*!< CLK_SYS_BUSCTRL                                                           */
      __IOM uint32_t CLK_SYS_BUSFABRIC : 1;     /*!< CLK_SYS_BUSFABRIC                                                         */
      __IOM uint32_t CLK_SYS_DMA : 1;           /*!< CLK_SYS_DMA                                                               */
      __IOM uint32_t CLK_SYS_I2C0 : 1;          /*!< CLK_SYS_I2C0                                                              */
      __IOM uint32_t CLK_SYS_I2C1 : 1;          /*!< CLK_SYS_I2C1                                                              */
      __IOM uint32_t CLK_SYS_IO : 1;            /*!< CLK_SYS_IO                                                                */
      __IOM uint32_t CLK_SYS_JTAG : 1;          /*!< CLK_SYS_JTAG                                                              */
      __IOM uint32_t CLK_SYS_VREG_AND_CHIP_RESET : 1;/*!< CLK_SYS_VREG_AND_CHIP_RESET                                          */
      __IOM uint32_t CLK_SYS_PADS : 1;          /*!< CLK_SYS_PADS                                                              */
      __IOM uint32_t CLK_SYS_PIO0 : 1;          /*!< CLK_SYS_PIO0                                                              */
      __IOM uint32_t CLK_SYS_PIO1 : 1;          /*!< CLK_SYS_PIO1                                                              */
      __IOM uint32_t CLK_SYS_PLL_SYS : 1;       /*!< CLK_SYS_PLL_SYS                                                           */
      __IOM uint32_t CLK_SYS_PLL_USB : 1;       /*!< CLK_SYS_PLL_USB                                                           */
      __IOM uint32_t CLK_SYS_PSM : 1;           /*!< CLK_SYS_PSM                                                               */
      __IOM uint32_t CLK_SYS_PWM : 1;           /*!< CLK_SYS_PWM                                                               */
      __IOM uint32_t CLK_SYS_RESETS : 1;        /*!< CLK_SYS_RESETS                                                            */
      __IOM uint32_t CLK_SYS_ROM : 1;           /*!< CLK_SYS_ROM                                                               */
      __IOM uint32_t CLK_SYS_ROSC : 1;          /*!< CLK_SYS_ROSC                                                              */
      __IOM uint32_t CLK_RTC_RTC : 1;           /*!< CLK_RTC_RTC                                                               */
      __IOM uint32_t CLK_SYS_RTC : 1;           /*!< CLK_SYS_RTC                                                               */
      __IOM uint32_t CLK_SYS_SIO : 1;           /*!< CLK_SYS_SIO                                                               */
      __IOM uint32_t CLK_PERI_SPI0 : 1;         /*!< CLK_PERI_SPI0                                                             */
      __IOM uint32_t CLK_SYS_SPI0 : 1;          /*!< CLK_SYS_SPI0                                                              */
      __IOM uint32_t CLK_PERI_SPI1 : 1;         /*!< CLK_PERI_SPI1                                                             */
      __IOM uint32_t CLK_SYS_SPI1 : 1;          /*!< CLK_SYS_SPI1                                                              */
      __IOM uint32_t CLK_SYS_SRAM0 : 1;         /*!< CLK_SYS_SRAM0                                                             */
      __IOM uint32_t CLK_SYS_SRAM1 : 1;         /*!< CLK_SYS_SRAM1                                                             */
      __IOM uint32_t CLK_SYS_SRAM2 : 1;         /*!< CLK_SYS_SRAM2                                                             */
      __IOM uint32_t CLK_SYS_SRAM3 : 1;         /*!< CLK_SYS_SRAM3                                                             */
    } bit;
  } WAKE_EN0;
  
  union {
    __IOM uint32_t reg;                         /*!< enable clock in wake mode                                                 */
    
    struct {
      __IOM uint32_t CLK_SYS_SRAM4 : 1;         /*!< CLK_SYS_SRAM4                                                             */
      __IOM uint32_t CLK_SYS_SRAM5 : 1;         /*!< CLK_SYS_SRAM5                                                             */
      __IOM uint32_t CLK_SYS_SYSCFG : 1;        /*!< CLK_SYS_SYSCFG                                                            */
      __IOM uint32_t CLK_SYS_SYSINFO : 1;       /*!< CLK_SYS_SYSINFO                                                           */
      __IOM uint32_t CLK_SYS_TBMAN : 1;         /*!< CLK_SYS_TBMAN                                                             */
      __IOM uint32_t CLK_SYS_TIMER : 1;         /*!< CLK_SYS_TIMER                                                             */
      __IOM uint32_t CLK_PERI_UART0 : 1;        /*!< CLK_PERI_UART0                                                            */
      __IOM uint32_t CLK_SYS_UART0 : 1;         /*!< CLK_SYS_UART0                                                             */
      __IOM uint32_t CLK_PERI_UART1 : 1;        /*!< CLK_PERI_UART1                                                            */
      __IOM uint32_t CLK_SYS_UART1 : 1;         /*!< CLK_SYS_UART1                                                             */
      __IOM uint32_t CLK_SYS_USBCTRL : 1;       /*!< CLK_SYS_USBCTRL                                                           */
      __IOM uint32_t CLK_USB_USBCTRL : 1;       /*!< CLK_USB_USBCTRL                                                           */
      __IOM uint32_t CLK_SYS_WATCHDOG : 1;      /*!< CLK_SYS_WATCHDOG                                                          */
      __IOM uint32_t CLK_SYS_XIP : 1;           /*!< CLK_SYS_XIP                                                               */
      __IOM uint32_t CLK_SYS_XOSC : 1;          /*!< CLK_SYS_XOSC                                                              */
            uint32_t            : 17;
    } bit;
  } WAKE_EN1;
  
  union {
    __IOM uint32_t reg;                         /*!< enable clock in sleep mode                                                */
    
    struct {
      __IOM uint32_t CLK_SYS_CLOCKS : 1;        /*!< CLK_SYS_CLOCKS                                                            */
      __IOM uint32_t CLK_ADC_ADC : 1;           /*!< CLK_ADC_ADC                                                               */
      __IOM uint32_t CLK_SYS_ADC : 1;           /*!< CLK_SYS_ADC                                                               */
      __IOM uint32_t CLK_SYS_BUSCTRL : 1;       /*!< CLK_SYS_BUSCTRL                                                           */
      __IOM uint32_t CLK_SYS_BUSFABRIC : 1;     /*!< CLK_SYS_BUSFABRIC                                                         */
      __IOM uint32_t CLK_SYS_DMA : 1;           /*!< CLK_SYS_DMA                                                               */
      __IOM uint32_t CLK_SYS_I2C0 : 1;          /*!< CLK_SYS_I2C0                                                              */
      __IOM uint32_t CLK_SYS_I2C1 : 1;          /*!< CLK_SYS_I2C1                                                              */
      __IOM uint32_t CLK_SYS_IO : 1;            /*!< CLK_SYS_IO                                                                */
      __IOM uint32_t CLK_SYS_JTAG : 1;          /*!< CLK_SYS_JTAG                                                              */
      __IOM uint32_t CLK_SYS_VREG_AND_CHIP_RESET : 1;/*!< CLK_SYS_VREG_AND_CHIP_RESET                                          */
      __IOM uint32_t CLK_SYS_PADS : 1;          /*!< CLK_SYS_PADS                                                              */
      __IOM uint32_t CLK_SYS_PIO0 : 1;          /*!< CLK_SYS_PIO0                                                              */
      __IOM uint32_t CLK_SYS_PIO1 : 1;          /*!< CLK_SYS_PIO1                                                              */
      __IOM uint32_t CLK_SYS_PLL_SYS : 1;       /*!< CLK_SYS_PLL_SYS                                                           */
      __IOM uint32_t CLK_SYS_PLL_USB : 1;       /*!< CLK_SYS_PLL_USB                                                           */
      __IOM uint32_t CLK_SYS_PSM : 1;           /*!< CLK_SYS_PSM                                                               */
      __IOM uint32_t CLK_SYS_PWM : 1;           /*!< CLK_SYS_PWM                                                               */
      __IOM uint32_t CLK_SYS_RESETS : 1;        /*!< CLK_SYS_RESETS                                                            */
      __IOM uint32_t CLK_SYS_ROM : 1;           /*!< CLK_SYS_ROM                                                               */
      __IOM uint32_t CLK_SYS_ROSC : 1;          /*!< CLK_SYS_ROSC                                                              */
      __IOM uint32_t CLK_RTC_RTC : 1;           /*!< CLK_RTC_RTC                                                               */
      __IOM uint32_t CLK_SYS_RTC : 1;           /*!< CLK_SYS_RTC                                                               */
      __IOM uint32_t CLK_SYS_SIO : 1;           /*!< CLK_SYS_SIO                                                               */
      __IOM uint32_t CLK_PERI_SPI0 : 1;         /*!< CLK_PERI_SPI0                                                             */
      __IOM uint32_t CLK_SYS_SPI0 : 1;          /*!< CLK_SYS_SPI0                                                              */
      __IOM uint32_t CLK_PERI_SPI1 : 1;         /*!< CLK_PERI_SPI1                                                             */
      __IOM uint32_t CLK_SYS_SPI1 : 1;          /*!< CLK_SYS_SPI1                                                              */
      __IOM uint32_t CLK_SYS_SRAM0 : 1;         /*!< CLK_SYS_SRAM0                                                             */
      __IOM uint32_t CLK_SYS_SRAM1 : 1;         /*!< CLK_SYS_SRAM1                                                             */
      __IOM uint32_t CLK_SYS_SRAM2 : 1;         /*!< CLK_SYS_SRAM2                                                             */
      __IOM uint32_t CLK_SYS_SRAM3 : 1;         /*!< CLK_SYS_SRAM3                                                             */
    } bit;
  } SLEEP_EN0;
  
  union {
    __IOM uint32_t reg;                         /*!< enable clock in sleep mode                                                */
    
    struct {
      __IOM uint32_t CLK_SYS_SRAM4 : 1;         /*!< CLK_SYS_SRAM4                                                             */
      __IOM uint32_t CLK_SYS_SRAM5 : 1;         /*!< CLK_SYS_SRAM5                                                             */
      __IOM uint32_t CLK_SYS_SYSCFG : 1;        /*!< CLK_SYS_SYSCFG                                                            */
      __IOM uint32_t CLK_SYS_SYSINFO : 1;       /*!< CLK_SYS_SYSINFO                                                           */
      __IOM uint32_t CLK_SYS_TBMAN : 1;         /*!< CLK_SYS_TBMAN                                                             */
      __IOM uint32_t CLK_SYS_TIMER : 1;         /*!< CLK_SYS_TIMER                                                             */
      __IOM uint32_t CLK_PERI_UART0 : 1;        /*!< CLK_PERI_UART0                                                            */
      __IOM uint32_t CLK_SYS_UART0 : 1;         /*!< CLK_SYS_UART0                                                             */
      __IOM uint32_t CLK_PERI_UART1 : 1;        /*!< CLK_PERI_UART1                                                            */
      __IOM uint32_t CLK_SYS_UART1 : 1;         /*!< CLK_SYS_UART1                                                             */
      __IOM uint32_t CLK_SYS_USBCTRL : 1;       /*!< CLK_SYS_USBCTRL                                                           */
      __IOM uint32_t CLK_USB_USBCTRL : 1;       /*!< CLK_USB_USBCTRL                                                           */
      __IOM uint32_t CLK_SYS_WATCHDOG : 1;      /*!< CLK_SYS_WATCHDOG                                                          */
      __IOM uint32_t CLK_SYS_XIP : 1;           /*!< CLK_SYS_XIP                                                               */
      __IOM uint32_t CLK_SYS_XOSC : 1;          /*!< CLK_SYS_XOSC                                                              */
            uint32_t            : 17;
    } bit;
  } SLEEP_EN1;
  
  union {
    __IOM uint32_t reg;                         /*!< indicates the state of the clock enable                                   */
    
    struct {
      __IM  uint32_t CLK_SYS_CLOCKS : 1;        /*!< CLK_SYS_CLOCKS                                                            */
      __IM  uint32_t CLK_ADC_ADC : 1;           /*!< CLK_ADC_ADC                                                               */
      __IM  uint32_t CLK_SYS_ADC : 1;           /*!< CLK_SYS_ADC                                                               */
      __IM  uint32_t CLK_SYS_BUSCTRL : 1;       /*!< CLK_SYS_BUSCTRL                                                           */
      __IM  uint32_t CLK_SYS_BUSFABRIC : 1;     /*!< CLK_SYS_BUSFABRIC                                                         */
      __IM  uint32_t CLK_SYS_DMA : 1;           /*!< CLK_SYS_DMA                                                               */
      __IM  uint32_t CLK_SYS_I2C0 : 1;          /*!< CLK_SYS_I2C0                                                              */
      __IM  uint32_t CLK_SYS_I2C1 : 1;          /*!< CLK_SYS_I2C1                                                              */
      __IM  uint32_t CLK_SYS_IO : 1;            /*!< CLK_SYS_IO                                                                */
      __IM  uint32_t CLK_SYS_JTAG : 1;          /*!< CLK_SYS_JTAG                                                              */
      __IM  uint32_t CLK_SYS_VREG_AND_CHIP_RESET : 1;/*!< CLK_SYS_VREG_AND_CHIP_RESET                                          */
      __IM  uint32_t CLK_SYS_PADS : 1;          /*!< CLK_SYS_PADS                                                              */
      __IM  uint32_t CLK_SYS_PIO0 : 1;          /*!< CLK_SYS_PIO0                                                              */
      __IM  uint32_t CLK_SYS_PIO1 : 1;          /*!< CLK_SYS_PIO1                                                              */
      __IM  uint32_t CLK_SYS_PLL_SYS : 1;       /*!< CLK_SYS_PLL_SYS                                                           */
      __IM  uint32_t CLK_SYS_PLL_USB : 1;       /*!< CLK_SYS_PLL_USB                                                           */
      __IM  uint32_t CLK_SYS_PSM : 1;           /*!< CLK_SYS_PSM                                                               */
      __IM  uint32_t CLK_SYS_PWM : 1;           /*!< CLK_SYS_PWM                                                               */
      __IM  uint32_t CLK_SYS_RESETS : 1;        /*!< CLK_SYS_RESETS                                                            */
      __IM  uint32_t CLK_SYS_ROM : 1;           /*!< CLK_SYS_ROM                                                               */
      __IM  uint32_t CLK_SYS_ROSC : 1;          /*!< CLK_SYS_ROSC                                                              */
      __IM  uint32_t CLK_RTC_RTC : 1;           /*!< CLK_RTC_RTC                                                               */
      __IM  uint32_t CLK_SYS_RTC : 1;           /*!< CLK_SYS_RTC                                                               */
      __IM  uint32_t CLK_SYS_SIO : 1;           /*!< CLK_SYS_SIO                                                               */
      __IM  uint32_t CLK_PERI_SPI0 : 1;         /*!< CLK_PERI_SPI0                                                             */
      __IM  uint32_t CLK_SYS_SPI0 : 1;          /*!< CLK_SYS_SPI0                                                              */
      __IM  uint32_t CLK_PERI_SPI1 : 1;         /*!< CLK_PERI_SPI1                                                             */
      __IM  uint32_t CLK_SYS_SPI1 : 1;          /*!< CLK_SYS_SPI1                                                              */
      __IM  uint32_t CLK_SYS_SRAM0 : 1;         /*!< CLK_SYS_SRAM0                                                             */
      __IM  uint32_t CLK_SYS_SRAM1 : 1;         /*!< CLK_SYS_SRAM1                                                             */
      __IM  uint32_t CLK_SYS_SRAM2 : 1;         /*!< CLK_SYS_SRAM2                                                             */
      __IM  uint32_t CLK_SYS_SRAM3 : 1;         /*!< CLK_SYS_SRAM3                                                             */
    } bit;
  } ENABLED0;
  
  union {
    __IOM uint32_t reg;                         /*!< indicates the state of the clock enable                                   */
    
    struct {
      __IM  uint32_t CLK_SYS_SRAM4 : 1;         /*!< CLK_SYS_SRAM4                                                             */
      __IM  uint32_t CLK_SYS_SRAM5 : 1;         /*!< CLK_SYS_SRAM5                                                             */
      __IM  uint32_t CLK_SYS_SYSCFG : 1;        /*!< CLK_SYS_SYSCFG                                                            */
      __IM  uint32_t CLK_SYS_SYSINFO : 1;       /*!< CLK_SYS_SYSINFO                                                           */
      __IM  uint32_t CLK_SYS_TBMAN : 1;         /*!< CLK_SYS_TBMAN                                                             */
      __IM  uint32_t CLK_SYS_TIMER : 1;         /*!< CLK_SYS_TIMER                                                             */
      __IM  uint32_t CLK_PERI_UART0 : 1;        /*!< CLK_PERI_UART0                                                            */
      __IM  uint32_t CLK_SYS_UART0 : 1;         /*!< CLK_SYS_UART0                                                             */
      __IM  uint32_t CLK_PERI_UART1 : 1;        /*!< CLK_PERI_UART1                                                            */
      __IM  uint32_t CLK_SYS_UART1 : 1;         /*!< CLK_SYS_UART1                                                             */
      __IM  uint32_t CLK_SYS_USBCTRL : 1;       /*!< CLK_SYS_USBCTRL                                                           */
      __IM  uint32_t CLK_USB_USBCTRL : 1;       /*!< CLK_USB_USBCTRL                                                           */
      __IM  uint32_t CLK_SYS_WATCHDOG : 1;      /*!< CLK_SYS_WATCHDOG                                                          */
      __IM  uint32_t CLK_SYS_XIP : 1;           /*!< CLK_SYS_XIP                                                               */
      __IM  uint32_t CLK_SYS_XOSC : 1;          /*!< CLK_SYS_XOSC                                                              */
            uint32_t            : 17;
    } bit;
  } ENABLED1;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw Interrupts                                                            */
    
    struct {
      __IM  uint32_t CLK_SYS_RESUS : 1;         /*!< CLK_SYS_RESUS                                                             */
            uint32_t            : 31;
    } bit;
  } INTR;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable                                                          */
    
    struct {
      __IOM uint32_t CLK_SYS_RESUS : 1;         /*!< CLK_SYS_RESUS                                                             */
            uint32_t            : 31;
    } bit;
  } INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force                                                           */
    
    struct {
      __IOM uint32_t CLK_SYS_RESUS : 1;         /*!< CLK_SYS_RESUS                                                             */
            uint32_t            : 31;
    } bit;
  } INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing                                  */
    
    struct {
      __IM  uint32_t CLK_SYS_RESUS : 1;         /*!< CLK_SYS_RESUS                                                             */
            uint32_t            : 31;
    } bit;
  } INTS;
} CLOCKS_Type;                                  /*!< Size = 200 (0xc8)                                                         */



/* =========================================================================================================================== */
/* ================                                        PADS_BANK0                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief PADS_BANK0 (PADS_BANK0)
  */

typedef struct {                                /*!< PADS_BANK0 Structure                                                      */
  
  union {
    __IOM uint32_t reg;                         /*!< Voltage select. Per bank control                                          */
    
    struct {
      __IOM uint32_t VOLTAGE_SELECT : 1;        /*!< VOLTAGE_SELECT                                                            */
            uint32_t            : 31;
    } bit;
  } VOLTAGE_SELECT;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO0;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO1;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO2;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO3;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO4;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO5;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO6;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO7;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO8;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO9;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO10;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO11;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO12;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO13;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO14;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO15;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO16;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO17;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO18;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO19;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO20;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO21;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO22;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO23;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO24;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO25;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO26;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO27;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO28;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO29;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } SWCLK;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } SWD;
} PADS_BANK0_Type;                              /*!< Size = 132 (0x84)                                                         */



/* =========================================================================================================================== */
/* ================                                         PADS_QSPI                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief PADS_QSPI (PADS_QSPI)
  */

typedef struct {                                /*!< PADS_QSPI Structure                                                       */
  
  union {
    __IOM uint32_t reg;                         /*!< Voltage select. Per bank control                                          */
    
    struct {
      __IOM uint32_t VOLTAGE_SELECT : 1;        /*!< VOLTAGE_SELECT                                                            */
            uint32_t            : 31;
    } bit;
  } VOLTAGE_SELECT;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO_QSPI_SCLK;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO_QSPI_SD0;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO_QSPI_SD1;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO_QSPI_SD2;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO_QSPI_SD3;
  
  union {
    __IOM uint32_t reg;                         /*!< Pad control register                                                      */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< Slew rate control. 1 = Fast, 0 = Slow                                     */
      __IOM uint32_t SCHMITT    : 1;            /*!< Enable schmitt trigger                                                    */
      __IOM uint32_t PDE        : 1;            /*!< Pull down enable                                                          */
      __IOM uint32_t PUE        : 1;            /*!< Pull up enable                                                            */
      __IOM uint32_t DRIVE      : 2;            /*!< Drive strength.                                                           */
      __IOM uint32_t IE         : 1;            /*!< Input enable                                                              */
      __IOM uint32_t OD         : 1;            /*!< Output disable. Has priority over output enable from peripherals          */
            uint32_t            : 24;
    } bit;
  } GPIO_QSPI_SS;
} PADS_QSPI_Type;                               /*!< Size = 28 (0x1c)                                                          */



/* =========================================================================================================================== */
/* ================                                          IO_QSPI                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief IO_QSPI (IO_QSPI)
  */

typedef struct {                                /*!< IO_QSPI Structure                                                         */
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO_QSPI_SCLK_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO_QSPI_SCLK_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO_QSPI_SS_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO_QSPI_SS_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO_QSPI_SD0_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO_QSPI_SD0_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO_QSPI_SD1_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO_QSPI_SD1_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO_QSPI_SD2_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO_QSPI_SD2_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO_QSPI_SD3_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO_QSPI_SD3_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw Interrupts                                                            */
    
    struct {
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< GPIO_QSPI_SCLK_LEVEL_LOW                                                */
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SCLK_LEVEL_HIGH                                              */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< GPIO_QSPI_SCLK_EDGE_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< GPIO_QSPI_SCLK_EDGE_HIGH                                                */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< GPIO_QSPI_SS_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SS_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< GPIO_QSPI_SS_EDGE_LOW                                                     */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< GPIO_QSPI_SS_EDGE_HIGH                                                    */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD0_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD0_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< GPIO_QSPI_SD0_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD0_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD1_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD1_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< GPIO_QSPI_SD1_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD1_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD2_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD2_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< GPIO_QSPI_SD2_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD2_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD3_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD3_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< GPIO_QSPI_SD3_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD3_EDGE_HIGH                                                  */
            uint32_t            : 8;
    } bit;
  } INTR;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable for proc0                                                */
    
    struct {
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< GPIO_QSPI_SCLK_LEVEL_LOW                                                */
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SCLK_LEVEL_HIGH                                              */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< GPIO_QSPI_SCLK_EDGE_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< GPIO_QSPI_SCLK_EDGE_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< GPIO_QSPI_SS_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SS_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< GPIO_QSPI_SS_EDGE_LOW                                                     */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< GPIO_QSPI_SS_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD0_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD0_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< GPIO_QSPI_SD0_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD0_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD1_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD1_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< GPIO_QSPI_SD1_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD1_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD2_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD2_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< GPIO_QSPI_SD2_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD2_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD3_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD3_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< GPIO_QSPI_SD3_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD3_EDGE_HIGH                                                  */
            uint32_t            : 8;
    } bit;
  } PROC0_INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force for proc0                                                 */
    
    struct {
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< GPIO_QSPI_SCLK_LEVEL_LOW                                                */
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SCLK_LEVEL_HIGH                                              */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< GPIO_QSPI_SCLK_EDGE_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< GPIO_QSPI_SCLK_EDGE_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< GPIO_QSPI_SS_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SS_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< GPIO_QSPI_SS_EDGE_LOW                                                     */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< GPIO_QSPI_SS_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD0_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD0_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< GPIO_QSPI_SD0_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD0_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD1_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD1_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< GPIO_QSPI_SD1_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD1_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD2_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD2_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< GPIO_QSPI_SD2_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD2_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD3_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD3_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< GPIO_QSPI_SD3_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD3_EDGE_HIGH                                                  */
            uint32_t            : 8;
    } bit;
  } PROC0_INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing for proc0                        */
    
    struct {
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< GPIO_QSPI_SCLK_LEVEL_LOW                                                */
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SCLK_LEVEL_HIGH                                              */
      __IM  uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< GPIO_QSPI_SCLK_EDGE_LOW                                                  */
      __IM  uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< GPIO_QSPI_SCLK_EDGE_HIGH                                                */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< GPIO_QSPI_SS_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SS_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< GPIO_QSPI_SS_EDGE_LOW                                                     */
      __IM  uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< GPIO_QSPI_SS_EDGE_HIGH                                                    */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD0_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD0_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< GPIO_QSPI_SD0_EDGE_LOW                                                    */
      __IM  uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD0_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD1_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD1_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< GPIO_QSPI_SD1_EDGE_LOW                                                    */
      __IM  uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD1_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD2_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD2_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< GPIO_QSPI_SD2_EDGE_LOW                                                    */
      __IM  uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD2_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD3_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD3_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< GPIO_QSPI_SD3_EDGE_LOW                                                    */
      __IM  uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD3_EDGE_HIGH                                                  */
            uint32_t            : 8;
    } bit;
  } PROC0_INTS;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable for proc1                                                */
    
    struct {
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< GPIO_QSPI_SCLK_LEVEL_LOW                                                */
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SCLK_LEVEL_HIGH                                              */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< GPIO_QSPI_SCLK_EDGE_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< GPIO_QSPI_SCLK_EDGE_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< GPIO_QSPI_SS_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SS_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< GPIO_QSPI_SS_EDGE_LOW                                                     */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< GPIO_QSPI_SS_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD0_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD0_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< GPIO_QSPI_SD0_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD0_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD1_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD1_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< GPIO_QSPI_SD1_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD1_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD2_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD2_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< GPIO_QSPI_SD2_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD2_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD3_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD3_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< GPIO_QSPI_SD3_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD3_EDGE_HIGH                                                  */
            uint32_t            : 8;
    } bit;
  } PROC1_INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force for proc1                                                 */
    
    struct {
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< GPIO_QSPI_SCLK_LEVEL_LOW                                                */
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SCLK_LEVEL_HIGH                                              */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< GPIO_QSPI_SCLK_EDGE_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< GPIO_QSPI_SCLK_EDGE_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< GPIO_QSPI_SS_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SS_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< GPIO_QSPI_SS_EDGE_LOW                                                     */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< GPIO_QSPI_SS_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD0_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD0_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< GPIO_QSPI_SD0_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD0_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD1_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD1_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< GPIO_QSPI_SD1_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD1_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD2_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD2_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< GPIO_QSPI_SD2_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD2_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD3_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD3_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< GPIO_QSPI_SD3_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD3_EDGE_HIGH                                                  */
            uint32_t            : 8;
    } bit;
  } PROC1_INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing for proc1                        */
    
    struct {
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< GPIO_QSPI_SCLK_LEVEL_LOW                                                */
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SCLK_LEVEL_HIGH                                              */
      __IM  uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< GPIO_QSPI_SCLK_EDGE_LOW                                                  */
      __IM  uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< GPIO_QSPI_SCLK_EDGE_HIGH                                                */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< GPIO_QSPI_SS_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SS_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< GPIO_QSPI_SS_EDGE_LOW                                                     */
      __IM  uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< GPIO_QSPI_SS_EDGE_HIGH                                                    */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD0_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD0_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< GPIO_QSPI_SD0_EDGE_LOW                                                    */
      __IM  uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD0_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD1_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD1_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< GPIO_QSPI_SD1_EDGE_LOW                                                    */
      __IM  uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD1_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD2_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD2_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< GPIO_QSPI_SD2_EDGE_LOW                                                    */
      __IM  uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD2_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD3_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD3_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< GPIO_QSPI_SD3_EDGE_LOW                                                    */
      __IM  uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD3_EDGE_HIGH                                                  */
            uint32_t            : 8;
    } bit;
  } PROC1_INTS;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable for dormant_wake                                         */
    
    struct {
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< GPIO_QSPI_SCLK_LEVEL_LOW                                                */
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SCLK_LEVEL_HIGH                                              */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< GPIO_QSPI_SCLK_EDGE_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< GPIO_QSPI_SCLK_EDGE_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< GPIO_QSPI_SS_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SS_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< GPIO_QSPI_SS_EDGE_LOW                                                     */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< GPIO_QSPI_SS_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD0_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD0_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< GPIO_QSPI_SD0_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD0_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD1_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD1_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< GPIO_QSPI_SD1_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD1_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD2_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD2_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< GPIO_QSPI_SD2_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD2_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD3_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD3_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< GPIO_QSPI_SD3_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD3_EDGE_HIGH                                                  */
            uint32_t            : 8;
    } bit;
  } DORMANT_WAKE_INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force for dormant_wake                                          */
    
    struct {
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< GPIO_QSPI_SCLK_LEVEL_LOW                                                */
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SCLK_LEVEL_HIGH                                              */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< GPIO_QSPI_SCLK_EDGE_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< GPIO_QSPI_SCLK_EDGE_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< GPIO_QSPI_SS_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SS_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< GPIO_QSPI_SS_EDGE_LOW                                                     */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< GPIO_QSPI_SS_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD0_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD0_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< GPIO_QSPI_SD0_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD0_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD1_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD1_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< GPIO_QSPI_SD1_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD1_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD2_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD2_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< GPIO_QSPI_SD2_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD2_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD3_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD3_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< GPIO_QSPI_SD3_EDGE_LOW                                                    */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD3_EDGE_HIGH                                                  */
            uint32_t            : 8;
    } bit;
  } DORMANT_WAKE_INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing for dormant_wake                 */
    
    struct {
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< GPIO_QSPI_SCLK_LEVEL_LOW                                                */
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SCLK_LEVEL_HIGH                                              */
      __IM  uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< GPIO_QSPI_SCLK_EDGE_LOW                                                  */
      __IM  uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< GPIO_QSPI_SCLK_EDGE_HIGH                                                */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< GPIO_QSPI_SS_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SS_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< GPIO_QSPI_SS_EDGE_LOW                                                     */
      __IM  uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< GPIO_QSPI_SS_EDGE_HIGH                                                    */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD0_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD0_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< GPIO_QSPI_SD0_EDGE_LOW                                                    */
      __IM  uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD0_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD1_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD1_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< GPIO_QSPI_SD1_EDGE_LOW                                                    */
      __IM  uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD1_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD2_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD2_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< GPIO_QSPI_SD2_EDGE_LOW                                                    */
      __IM  uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD2_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< GPIO_QSPI_SD3_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< GPIO_QSPI_SD3_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< GPIO_QSPI_SD3_EDGE_LOW                                                    */
      __IM  uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< GPIO_QSPI_SD3_EDGE_HIGH                                                  */
            uint32_t            : 8;
    } bit;
  } DORMANT_WAKE_INTS;
} IO_QSPI_Type;                                 /*!< Size = 88 (0x58)                                                          */



/* =========================================================================================================================== */
/* ================                                         IO_BANK0                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief IO_BANK0 (IO_BANK0)
  */

typedef struct {                                /*!< IO_BANK0 Structure                                                        */
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO0_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO0_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO1_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO1_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO2_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO2_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO3_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO3_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO4_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO4_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO5_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO5_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO6_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO6_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO7_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO7_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO8_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO8_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO9_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO9_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO10_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO10_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO11_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO11_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO12_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO12_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO13_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO13_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO14_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO14_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO15_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO15_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO16_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO16_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO17_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO17_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO18_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO18_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO19_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO19_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO20_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO20_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO21_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO21_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO22_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO22_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO23_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO23_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO24_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO24_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO25_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO25_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO26_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO26_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO27_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO27_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO28_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO28_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO status                                                               */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< output signal from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< output signal to pad after register override is applied                   */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< output enable from selected peripheral, before register override
                                                     is applied                                                                */
      __IM  uint32_t OETOPAD    : 1;            /*!< output enable to pad after register override is applied                   */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< input signal from pad, before override is applied                         */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< input signal to peripheral, after override is applied                     */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< interrupt from pad before override is applied                             */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< interrupt to processors, after override is applied                        */
            uint32_t            : 5;
    } bit;
  } GPIO29_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO control including function select and overrides.                     */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< 0-31 -> selects pin function according to the gpio table 31
                                                     == NULL                                                                   */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< OUTOVER                                                                   */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< OEOVER                                                                    */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< INOVER                                                                    */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< IRQOVER                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO29_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw Interrupts                                                            */
    
    struct {
      __IM  uint32_t GPIO0_LEVEL_LOW : 1;       /*!< GPIO0_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< GPIO0_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO0_EDGE_LOW : 1;        /*!< GPIO0_EDGE_LOW                                                            */
      __IOM uint32_t GPIO0_EDGE_HIGH : 1;       /*!< GPIO0_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO1_LEVEL_LOW : 1;       /*!< GPIO1_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< GPIO1_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO1_EDGE_LOW : 1;        /*!< GPIO1_EDGE_LOW                                                            */
      __IOM uint32_t GPIO1_EDGE_HIGH : 1;       /*!< GPIO1_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO2_LEVEL_LOW : 1;       /*!< GPIO2_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< GPIO2_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO2_EDGE_LOW : 1;        /*!< GPIO2_EDGE_LOW                                                            */
      __IOM uint32_t GPIO2_EDGE_HIGH : 1;       /*!< GPIO2_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO3_LEVEL_LOW : 1;       /*!< GPIO3_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< GPIO3_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO3_EDGE_LOW : 1;        /*!< GPIO3_EDGE_LOW                                                            */
      __IOM uint32_t GPIO3_EDGE_HIGH : 1;       /*!< GPIO3_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO4_LEVEL_LOW : 1;       /*!< GPIO4_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< GPIO4_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO4_EDGE_LOW : 1;        /*!< GPIO4_EDGE_LOW                                                            */
      __IOM uint32_t GPIO4_EDGE_HIGH : 1;       /*!< GPIO4_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO5_LEVEL_LOW : 1;       /*!< GPIO5_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< GPIO5_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO5_EDGE_LOW : 1;        /*!< GPIO5_EDGE_LOW                                                            */
      __IOM uint32_t GPIO5_EDGE_HIGH : 1;       /*!< GPIO5_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO6_LEVEL_LOW : 1;       /*!< GPIO6_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< GPIO6_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO6_EDGE_LOW : 1;        /*!< GPIO6_EDGE_LOW                                                            */
      __IOM uint32_t GPIO6_EDGE_HIGH : 1;       /*!< GPIO6_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO7_LEVEL_LOW : 1;       /*!< GPIO7_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< GPIO7_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO7_EDGE_LOW : 1;        /*!< GPIO7_EDGE_LOW                                                            */
      __IOM uint32_t GPIO7_EDGE_HIGH : 1;       /*!< GPIO7_EDGE_HIGH                                                           */
    } bit;
  } INTR0;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw Interrupts                                                            */
    
    struct {
      __IM  uint32_t GPIO8_LEVEL_LOW : 1;       /*!< GPIO8_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< GPIO8_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO8_EDGE_LOW : 1;        /*!< GPIO8_EDGE_LOW                                                            */
      __IOM uint32_t GPIO8_EDGE_HIGH : 1;       /*!< GPIO8_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO9_LEVEL_LOW : 1;       /*!< GPIO9_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< GPIO9_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO9_EDGE_LOW : 1;        /*!< GPIO9_EDGE_LOW                                                            */
      __IOM uint32_t GPIO9_EDGE_HIGH : 1;       /*!< GPIO9_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO10_LEVEL_LOW : 1;      /*!< GPIO10_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< GPIO10_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO10_EDGE_LOW : 1;       /*!< GPIO10_EDGE_LOW                                                           */
      __IOM uint32_t GPIO10_EDGE_HIGH : 1;      /*!< GPIO10_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO11_LEVEL_LOW : 1;      /*!< GPIO11_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< GPIO11_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO11_EDGE_LOW : 1;       /*!< GPIO11_EDGE_LOW                                                           */
      __IOM uint32_t GPIO11_EDGE_HIGH : 1;      /*!< GPIO11_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO12_LEVEL_LOW : 1;      /*!< GPIO12_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< GPIO12_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO12_EDGE_LOW : 1;       /*!< GPIO12_EDGE_LOW                                                           */
      __IOM uint32_t GPIO12_EDGE_HIGH : 1;      /*!< GPIO12_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO13_LEVEL_LOW : 1;      /*!< GPIO13_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< GPIO13_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO13_EDGE_LOW : 1;       /*!< GPIO13_EDGE_LOW                                                           */
      __IOM uint32_t GPIO13_EDGE_HIGH : 1;      /*!< GPIO13_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO14_LEVEL_LOW : 1;      /*!< GPIO14_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< GPIO14_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO14_EDGE_LOW : 1;       /*!< GPIO14_EDGE_LOW                                                           */
      __IOM uint32_t GPIO14_EDGE_HIGH : 1;      /*!< GPIO14_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO15_LEVEL_LOW : 1;      /*!< GPIO15_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< GPIO15_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO15_EDGE_LOW : 1;       /*!< GPIO15_EDGE_LOW                                                           */
      __IOM uint32_t GPIO15_EDGE_HIGH : 1;      /*!< GPIO15_EDGE_HIGH                                                          */
    } bit;
  } INTR1;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw Interrupts                                                            */
    
    struct {
      __IM  uint32_t GPIO16_LEVEL_LOW : 1;      /*!< GPIO16_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< GPIO16_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO16_EDGE_LOW : 1;       /*!< GPIO16_EDGE_LOW                                                           */
      __IOM uint32_t GPIO16_EDGE_HIGH : 1;      /*!< GPIO16_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO17_LEVEL_LOW : 1;      /*!< GPIO17_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< GPIO17_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO17_EDGE_LOW : 1;       /*!< GPIO17_EDGE_LOW                                                           */
      __IOM uint32_t GPIO17_EDGE_HIGH : 1;      /*!< GPIO17_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO18_LEVEL_LOW : 1;      /*!< GPIO18_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< GPIO18_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO18_EDGE_LOW : 1;       /*!< GPIO18_EDGE_LOW                                                           */
      __IOM uint32_t GPIO18_EDGE_HIGH : 1;      /*!< GPIO18_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO19_LEVEL_LOW : 1;      /*!< GPIO19_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< GPIO19_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO19_EDGE_LOW : 1;       /*!< GPIO19_EDGE_LOW                                                           */
      __IOM uint32_t GPIO19_EDGE_HIGH : 1;      /*!< GPIO19_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO20_LEVEL_LOW : 1;      /*!< GPIO20_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< GPIO20_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO20_EDGE_LOW : 1;       /*!< GPIO20_EDGE_LOW                                                           */
      __IOM uint32_t GPIO20_EDGE_HIGH : 1;      /*!< GPIO20_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO21_LEVEL_LOW : 1;      /*!< GPIO21_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< GPIO21_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO21_EDGE_LOW : 1;       /*!< GPIO21_EDGE_LOW                                                           */
      __IOM uint32_t GPIO21_EDGE_HIGH : 1;      /*!< GPIO21_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO22_LEVEL_LOW : 1;      /*!< GPIO22_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< GPIO22_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO22_EDGE_LOW : 1;       /*!< GPIO22_EDGE_LOW                                                           */
      __IOM uint32_t GPIO22_EDGE_HIGH : 1;      /*!< GPIO22_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO23_LEVEL_LOW : 1;      /*!< GPIO23_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< GPIO23_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO23_EDGE_LOW : 1;       /*!< GPIO23_EDGE_LOW                                                           */
      __IOM uint32_t GPIO23_EDGE_HIGH : 1;      /*!< GPIO23_EDGE_HIGH                                                          */
    } bit;
  } INTR2;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw Interrupts                                                            */
    
    struct {
      __IM  uint32_t GPIO24_LEVEL_LOW : 1;      /*!< GPIO24_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< GPIO24_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO24_EDGE_LOW : 1;       /*!< GPIO24_EDGE_LOW                                                           */
      __IOM uint32_t GPIO24_EDGE_HIGH : 1;      /*!< GPIO24_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO25_LEVEL_LOW : 1;      /*!< GPIO25_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< GPIO25_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO25_EDGE_LOW : 1;       /*!< GPIO25_EDGE_LOW                                                           */
      __IOM uint32_t GPIO25_EDGE_HIGH : 1;      /*!< GPIO25_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO26_LEVEL_LOW : 1;      /*!< GPIO26_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< GPIO26_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO26_EDGE_LOW : 1;       /*!< GPIO26_EDGE_LOW                                                           */
      __IOM uint32_t GPIO26_EDGE_HIGH : 1;      /*!< GPIO26_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO27_LEVEL_LOW : 1;      /*!< GPIO27_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< GPIO27_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO27_EDGE_LOW : 1;       /*!< GPIO27_EDGE_LOW                                                           */
      __IOM uint32_t GPIO27_EDGE_HIGH : 1;      /*!< GPIO27_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO28_LEVEL_LOW : 1;      /*!< GPIO28_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< GPIO28_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO28_EDGE_LOW : 1;       /*!< GPIO28_EDGE_LOW                                                           */
      __IOM uint32_t GPIO28_EDGE_HIGH : 1;      /*!< GPIO28_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO29_LEVEL_LOW : 1;      /*!< GPIO29_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< GPIO29_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO29_EDGE_LOW : 1;       /*!< GPIO29_EDGE_LOW                                                           */
      __IOM uint32_t GPIO29_EDGE_HIGH : 1;      /*!< GPIO29_EDGE_HIGH                                                          */
            uint32_t            : 8;
    } bit;
  } INTR3;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable for proc0                                                */
    
    struct {
      __IOM uint32_t GPIO0_LEVEL_LOW : 1;       /*!< GPIO0_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< GPIO0_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO0_EDGE_LOW : 1;        /*!< GPIO0_EDGE_LOW                                                            */
      __IOM uint32_t GPIO0_EDGE_HIGH : 1;       /*!< GPIO0_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO1_LEVEL_LOW : 1;       /*!< GPIO1_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< GPIO1_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO1_EDGE_LOW : 1;        /*!< GPIO1_EDGE_LOW                                                            */
      __IOM uint32_t GPIO1_EDGE_HIGH : 1;       /*!< GPIO1_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO2_LEVEL_LOW : 1;       /*!< GPIO2_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< GPIO2_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO2_EDGE_LOW : 1;        /*!< GPIO2_EDGE_LOW                                                            */
      __IOM uint32_t GPIO2_EDGE_HIGH : 1;       /*!< GPIO2_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO3_LEVEL_LOW : 1;       /*!< GPIO3_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< GPIO3_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO3_EDGE_LOW : 1;        /*!< GPIO3_EDGE_LOW                                                            */
      __IOM uint32_t GPIO3_EDGE_HIGH : 1;       /*!< GPIO3_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO4_LEVEL_LOW : 1;       /*!< GPIO4_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< GPIO4_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO4_EDGE_LOW : 1;        /*!< GPIO4_EDGE_LOW                                                            */
      __IOM uint32_t GPIO4_EDGE_HIGH : 1;       /*!< GPIO4_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO5_LEVEL_LOW : 1;       /*!< GPIO5_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< GPIO5_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO5_EDGE_LOW : 1;        /*!< GPIO5_EDGE_LOW                                                            */
      __IOM uint32_t GPIO5_EDGE_HIGH : 1;       /*!< GPIO5_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO6_LEVEL_LOW : 1;       /*!< GPIO6_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< GPIO6_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO6_EDGE_LOW : 1;        /*!< GPIO6_EDGE_LOW                                                            */
      __IOM uint32_t GPIO6_EDGE_HIGH : 1;       /*!< GPIO6_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO7_LEVEL_LOW : 1;       /*!< GPIO7_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< GPIO7_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO7_EDGE_LOW : 1;        /*!< GPIO7_EDGE_LOW                                                            */
      __IOM uint32_t GPIO7_EDGE_HIGH : 1;       /*!< GPIO7_EDGE_HIGH                                                           */
    } bit;
  } PROC0_INTE0;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable for proc0                                                */
    
    struct {
      __IOM uint32_t GPIO8_LEVEL_LOW : 1;       /*!< GPIO8_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< GPIO8_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO8_EDGE_LOW : 1;        /*!< GPIO8_EDGE_LOW                                                            */
      __IOM uint32_t GPIO8_EDGE_HIGH : 1;       /*!< GPIO8_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO9_LEVEL_LOW : 1;       /*!< GPIO9_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< GPIO9_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO9_EDGE_LOW : 1;        /*!< GPIO9_EDGE_LOW                                                            */
      __IOM uint32_t GPIO9_EDGE_HIGH : 1;       /*!< GPIO9_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO10_LEVEL_LOW : 1;      /*!< GPIO10_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< GPIO10_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO10_EDGE_LOW : 1;       /*!< GPIO10_EDGE_LOW                                                           */
      __IOM uint32_t GPIO10_EDGE_HIGH : 1;      /*!< GPIO10_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO11_LEVEL_LOW : 1;      /*!< GPIO11_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< GPIO11_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO11_EDGE_LOW : 1;       /*!< GPIO11_EDGE_LOW                                                           */
      __IOM uint32_t GPIO11_EDGE_HIGH : 1;      /*!< GPIO11_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO12_LEVEL_LOW : 1;      /*!< GPIO12_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< GPIO12_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO12_EDGE_LOW : 1;       /*!< GPIO12_EDGE_LOW                                                           */
      __IOM uint32_t GPIO12_EDGE_HIGH : 1;      /*!< GPIO12_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO13_LEVEL_LOW : 1;      /*!< GPIO13_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< GPIO13_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO13_EDGE_LOW : 1;       /*!< GPIO13_EDGE_LOW                                                           */
      __IOM uint32_t GPIO13_EDGE_HIGH : 1;      /*!< GPIO13_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO14_LEVEL_LOW : 1;      /*!< GPIO14_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< GPIO14_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO14_EDGE_LOW : 1;       /*!< GPIO14_EDGE_LOW                                                           */
      __IOM uint32_t GPIO14_EDGE_HIGH : 1;      /*!< GPIO14_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO15_LEVEL_LOW : 1;      /*!< GPIO15_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< GPIO15_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO15_EDGE_LOW : 1;       /*!< GPIO15_EDGE_LOW                                                           */
      __IOM uint32_t GPIO15_EDGE_HIGH : 1;      /*!< GPIO15_EDGE_HIGH                                                          */
    } bit;
  } PROC0_INTE1;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable for proc0                                                */
    
    struct {
      __IOM uint32_t GPIO16_LEVEL_LOW : 1;      /*!< GPIO16_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< GPIO16_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO16_EDGE_LOW : 1;       /*!< GPIO16_EDGE_LOW                                                           */
      __IOM uint32_t GPIO16_EDGE_HIGH : 1;      /*!< GPIO16_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO17_LEVEL_LOW : 1;      /*!< GPIO17_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< GPIO17_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO17_EDGE_LOW : 1;       /*!< GPIO17_EDGE_LOW                                                           */
      __IOM uint32_t GPIO17_EDGE_HIGH : 1;      /*!< GPIO17_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO18_LEVEL_LOW : 1;      /*!< GPIO18_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< GPIO18_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO18_EDGE_LOW : 1;       /*!< GPIO18_EDGE_LOW                                                           */
      __IOM uint32_t GPIO18_EDGE_HIGH : 1;      /*!< GPIO18_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO19_LEVEL_LOW : 1;      /*!< GPIO19_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< GPIO19_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO19_EDGE_LOW : 1;       /*!< GPIO19_EDGE_LOW                                                           */
      __IOM uint32_t GPIO19_EDGE_HIGH : 1;      /*!< GPIO19_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO20_LEVEL_LOW : 1;      /*!< GPIO20_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< GPIO20_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO20_EDGE_LOW : 1;       /*!< GPIO20_EDGE_LOW                                                           */
      __IOM uint32_t GPIO20_EDGE_HIGH : 1;      /*!< GPIO20_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO21_LEVEL_LOW : 1;      /*!< GPIO21_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< GPIO21_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO21_EDGE_LOW : 1;       /*!< GPIO21_EDGE_LOW                                                           */
      __IOM uint32_t GPIO21_EDGE_HIGH : 1;      /*!< GPIO21_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO22_LEVEL_LOW : 1;      /*!< GPIO22_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< GPIO22_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO22_EDGE_LOW : 1;       /*!< GPIO22_EDGE_LOW                                                           */
      __IOM uint32_t GPIO22_EDGE_HIGH : 1;      /*!< GPIO22_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO23_LEVEL_LOW : 1;      /*!< GPIO23_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< GPIO23_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO23_EDGE_LOW : 1;       /*!< GPIO23_EDGE_LOW                                                           */
      __IOM uint32_t GPIO23_EDGE_HIGH : 1;      /*!< GPIO23_EDGE_HIGH                                                          */
    } bit;
  } PROC0_INTE2;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable for proc0                                                */
    
    struct {
      __IOM uint32_t GPIO24_LEVEL_LOW : 1;      /*!< GPIO24_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< GPIO24_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO24_EDGE_LOW : 1;       /*!< GPIO24_EDGE_LOW                                                           */
      __IOM uint32_t GPIO24_EDGE_HIGH : 1;      /*!< GPIO24_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO25_LEVEL_LOW : 1;      /*!< GPIO25_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< GPIO25_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO25_EDGE_LOW : 1;       /*!< GPIO25_EDGE_LOW                                                           */
      __IOM uint32_t GPIO25_EDGE_HIGH : 1;      /*!< GPIO25_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO26_LEVEL_LOW : 1;      /*!< GPIO26_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< GPIO26_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO26_EDGE_LOW : 1;       /*!< GPIO26_EDGE_LOW                                                           */
      __IOM uint32_t GPIO26_EDGE_HIGH : 1;      /*!< GPIO26_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO27_LEVEL_LOW : 1;      /*!< GPIO27_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< GPIO27_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO27_EDGE_LOW : 1;       /*!< GPIO27_EDGE_LOW                                                           */
      __IOM uint32_t GPIO27_EDGE_HIGH : 1;      /*!< GPIO27_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO28_LEVEL_LOW : 1;      /*!< GPIO28_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< GPIO28_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO28_EDGE_LOW : 1;       /*!< GPIO28_EDGE_LOW                                                           */
      __IOM uint32_t GPIO28_EDGE_HIGH : 1;      /*!< GPIO28_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO29_LEVEL_LOW : 1;      /*!< GPIO29_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< GPIO29_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO29_EDGE_LOW : 1;       /*!< GPIO29_EDGE_LOW                                                           */
      __IOM uint32_t GPIO29_EDGE_HIGH : 1;      /*!< GPIO29_EDGE_HIGH                                                          */
            uint32_t            : 8;
    } bit;
  } PROC0_INTE3;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force for proc0                                                 */
    
    struct {
      __IOM uint32_t GPIO0_LEVEL_LOW : 1;       /*!< GPIO0_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< GPIO0_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO0_EDGE_LOW : 1;        /*!< GPIO0_EDGE_LOW                                                            */
      __IOM uint32_t GPIO0_EDGE_HIGH : 1;       /*!< GPIO0_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO1_LEVEL_LOW : 1;       /*!< GPIO1_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< GPIO1_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO1_EDGE_LOW : 1;        /*!< GPIO1_EDGE_LOW                                                            */
      __IOM uint32_t GPIO1_EDGE_HIGH : 1;       /*!< GPIO1_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO2_LEVEL_LOW : 1;       /*!< GPIO2_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< GPIO2_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO2_EDGE_LOW : 1;        /*!< GPIO2_EDGE_LOW                                                            */
      __IOM uint32_t GPIO2_EDGE_HIGH : 1;       /*!< GPIO2_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO3_LEVEL_LOW : 1;       /*!< GPIO3_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< GPIO3_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO3_EDGE_LOW : 1;        /*!< GPIO3_EDGE_LOW                                                            */
      __IOM uint32_t GPIO3_EDGE_HIGH : 1;       /*!< GPIO3_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO4_LEVEL_LOW : 1;       /*!< GPIO4_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< GPIO4_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO4_EDGE_LOW : 1;        /*!< GPIO4_EDGE_LOW                                                            */
      __IOM uint32_t GPIO4_EDGE_HIGH : 1;       /*!< GPIO4_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO5_LEVEL_LOW : 1;       /*!< GPIO5_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< GPIO5_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO5_EDGE_LOW : 1;        /*!< GPIO5_EDGE_LOW                                                            */
      __IOM uint32_t GPIO5_EDGE_HIGH : 1;       /*!< GPIO5_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO6_LEVEL_LOW : 1;       /*!< GPIO6_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< GPIO6_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO6_EDGE_LOW : 1;        /*!< GPIO6_EDGE_LOW                                                            */
      __IOM uint32_t GPIO6_EDGE_HIGH : 1;       /*!< GPIO6_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO7_LEVEL_LOW : 1;       /*!< GPIO7_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< GPIO7_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO7_EDGE_LOW : 1;        /*!< GPIO7_EDGE_LOW                                                            */
      __IOM uint32_t GPIO7_EDGE_HIGH : 1;       /*!< GPIO7_EDGE_HIGH                                                           */
    } bit;
  } PROC0_INTF0;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force for proc0                                                 */
    
    struct {
      __IOM uint32_t GPIO8_LEVEL_LOW : 1;       /*!< GPIO8_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< GPIO8_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO8_EDGE_LOW : 1;        /*!< GPIO8_EDGE_LOW                                                            */
      __IOM uint32_t GPIO8_EDGE_HIGH : 1;       /*!< GPIO8_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO9_LEVEL_LOW : 1;       /*!< GPIO9_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< GPIO9_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO9_EDGE_LOW : 1;        /*!< GPIO9_EDGE_LOW                                                            */
      __IOM uint32_t GPIO9_EDGE_HIGH : 1;       /*!< GPIO9_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO10_LEVEL_LOW : 1;      /*!< GPIO10_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< GPIO10_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO10_EDGE_LOW : 1;       /*!< GPIO10_EDGE_LOW                                                           */
      __IOM uint32_t GPIO10_EDGE_HIGH : 1;      /*!< GPIO10_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO11_LEVEL_LOW : 1;      /*!< GPIO11_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< GPIO11_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO11_EDGE_LOW : 1;       /*!< GPIO11_EDGE_LOW                                                           */
      __IOM uint32_t GPIO11_EDGE_HIGH : 1;      /*!< GPIO11_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO12_LEVEL_LOW : 1;      /*!< GPIO12_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< GPIO12_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO12_EDGE_LOW : 1;       /*!< GPIO12_EDGE_LOW                                                           */
      __IOM uint32_t GPIO12_EDGE_HIGH : 1;      /*!< GPIO12_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO13_LEVEL_LOW : 1;      /*!< GPIO13_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< GPIO13_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO13_EDGE_LOW : 1;       /*!< GPIO13_EDGE_LOW                                                           */
      __IOM uint32_t GPIO13_EDGE_HIGH : 1;      /*!< GPIO13_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO14_LEVEL_LOW : 1;      /*!< GPIO14_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< GPIO14_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO14_EDGE_LOW : 1;       /*!< GPIO14_EDGE_LOW                                                           */
      __IOM uint32_t GPIO14_EDGE_HIGH : 1;      /*!< GPIO14_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO15_LEVEL_LOW : 1;      /*!< GPIO15_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< GPIO15_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO15_EDGE_LOW : 1;       /*!< GPIO15_EDGE_LOW                                                           */
      __IOM uint32_t GPIO15_EDGE_HIGH : 1;      /*!< GPIO15_EDGE_HIGH                                                          */
    } bit;
  } PROC0_INTF1;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force for proc0                                                 */
    
    struct {
      __IOM uint32_t GPIO16_LEVEL_LOW : 1;      /*!< GPIO16_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< GPIO16_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO16_EDGE_LOW : 1;       /*!< GPIO16_EDGE_LOW                                                           */
      __IOM uint32_t GPIO16_EDGE_HIGH : 1;      /*!< GPIO16_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO17_LEVEL_LOW : 1;      /*!< GPIO17_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< GPIO17_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO17_EDGE_LOW : 1;       /*!< GPIO17_EDGE_LOW                                                           */
      __IOM uint32_t GPIO17_EDGE_HIGH : 1;      /*!< GPIO17_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO18_LEVEL_LOW : 1;      /*!< GPIO18_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< GPIO18_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO18_EDGE_LOW : 1;       /*!< GPIO18_EDGE_LOW                                                           */
      __IOM uint32_t GPIO18_EDGE_HIGH : 1;      /*!< GPIO18_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO19_LEVEL_LOW : 1;      /*!< GPIO19_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< GPIO19_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO19_EDGE_LOW : 1;       /*!< GPIO19_EDGE_LOW                                                           */
      __IOM uint32_t GPIO19_EDGE_HIGH : 1;      /*!< GPIO19_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO20_LEVEL_LOW : 1;      /*!< GPIO20_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< GPIO20_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO20_EDGE_LOW : 1;       /*!< GPIO20_EDGE_LOW                                                           */
      __IOM uint32_t GPIO20_EDGE_HIGH : 1;      /*!< GPIO20_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO21_LEVEL_LOW : 1;      /*!< GPIO21_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< GPIO21_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO21_EDGE_LOW : 1;       /*!< GPIO21_EDGE_LOW                                                           */
      __IOM uint32_t GPIO21_EDGE_HIGH : 1;      /*!< GPIO21_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO22_LEVEL_LOW : 1;      /*!< GPIO22_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< GPIO22_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO22_EDGE_LOW : 1;       /*!< GPIO22_EDGE_LOW                                                           */
      __IOM uint32_t GPIO22_EDGE_HIGH : 1;      /*!< GPIO22_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO23_LEVEL_LOW : 1;      /*!< GPIO23_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< GPIO23_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO23_EDGE_LOW : 1;       /*!< GPIO23_EDGE_LOW                                                           */
      __IOM uint32_t GPIO23_EDGE_HIGH : 1;      /*!< GPIO23_EDGE_HIGH                                                          */
    } bit;
  } PROC0_INTF2;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force for proc0                                                 */
    
    struct {
      __IOM uint32_t GPIO24_LEVEL_LOW : 1;      /*!< GPIO24_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< GPIO24_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO24_EDGE_LOW : 1;       /*!< GPIO24_EDGE_LOW                                                           */
      __IOM uint32_t GPIO24_EDGE_HIGH : 1;      /*!< GPIO24_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO25_LEVEL_LOW : 1;      /*!< GPIO25_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< GPIO25_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO25_EDGE_LOW : 1;       /*!< GPIO25_EDGE_LOW                                                           */
      __IOM uint32_t GPIO25_EDGE_HIGH : 1;      /*!< GPIO25_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO26_LEVEL_LOW : 1;      /*!< GPIO26_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< GPIO26_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO26_EDGE_LOW : 1;       /*!< GPIO26_EDGE_LOW                                                           */
      __IOM uint32_t GPIO26_EDGE_HIGH : 1;      /*!< GPIO26_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO27_LEVEL_LOW : 1;      /*!< GPIO27_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< GPIO27_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO27_EDGE_LOW : 1;       /*!< GPIO27_EDGE_LOW                                                           */
      __IOM uint32_t GPIO27_EDGE_HIGH : 1;      /*!< GPIO27_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO28_LEVEL_LOW : 1;      /*!< GPIO28_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< GPIO28_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO28_EDGE_LOW : 1;       /*!< GPIO28_EDGE_LOW                                                           */
      __IOM uint32_t GPIO28_EDGE_HIGH : 1;      /*!< GPIO28_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO29_LEVEL_LOW : 1;      /*!< GPIO29_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< GPIO29_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO29_EDGE_LOW : 1;       /*!< GPIO29_EDGE_LOW                                                           */
      __IOM uint32_t GPIO29_EDGE_HIGH : 1;      /*!< GPIO29_EDGE_HIGH                                                          */
            uint32_t            : 8;
    } bit;
  } PROC0_INTF3;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing for proc0                        */
    
    struct {
      __IM  uint32_t GPIO0_LEVEL_LOW : 1;       /*!< GPIO0_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< GPIO0_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO0_EDGE_LOW : 1;        /*!< GPIO0_EDGE_LOW                                                            */
      __IM  uint32_t GPIO0_EDGE_HIGH : 1;       /*!< GPIO0_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO1_LEVEL_LOW : 1;       /*!< GPIO1_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< GPIO1_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO1_EDGE_LOW : 1;        /*!< GPIO1_EDGE_LOW                                                            */
      __IM  uint32_t GPIO1_EDGE_HIGH : 1;       /*!< GPIO1_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO2_LEVEL_LOW : 1;       /*!< GPIO2_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< GPIO2_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO2_EDGE_LOW : 1;        /*!< GPIO2_EDGE_LOW                                                            */
      __IM  uint32_t GPIO2_EDGE_HIGH : 1;       /*!< GPIO2_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO3_LEVEL_LOW : 1;       /*!< GPIO3_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< GPIO3_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO3_EDGE_LOW : 1;        /*!< GPIO3_EDGE_LOW                                                            */
      __IM  uint32_t GPIO3_EDGE_HIGH : 1;       /*!< GPIO3_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO4_LEVEL_LOW : 1;       /*!< GPIO4_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< GPIO4_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO4_EDGE_LOW : 1;        /*!< GPIO4_EDGE_LOW                                                            */
      __IM  uint32_t GPIO4_EDGE_HIGH : 1;       /*!< GPIO4_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO5_LEVEL_LOW : 1;       /*!< GPIO5_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< GPIO5_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO5_EDGE_LOW : 1;        /*!< GPIO5_EDGE_LOW                                                            */
      __IM  uint32_t GPIO5_EDGE_HIGH : 1;       /*!< GPIO5_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO6_LEVEL_LOW : 1;       /*!< GPIO6_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< GPIO6_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO6_EDGE_LOW : 1;        /*!< GPIO6_EDGE_LOW                                                            */
      __IM  uint32_t GPIO6_EDGE_HIGH : 1;       /*!< GPIO6_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO7_LEVEL_LOW : 1;       /*!< GPIO7_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< GPIO7_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO7_EDGE_LOW : 1;        /*!< GPIO7_EDGE_LOW                                                            */
      __IM  uint32_t GPIO7_EDGE_HIGH : 1;       /*!< GPIO7_EDGE_HIGH                                                           */
    } bit;
  } PROC0_INTS0;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing for proc0                        */
    
    struct {
      __IM  uint32_t GPIO8_LEVEL_LOW : 1;       /*!< GPIO8_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< GPIO8_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO8_EDGE_LOW : 1;        /*!< GPIO8_EDGE_LOW                                                            */
      __IM  uint32_t GPIO8_EDGE_HIGH : 1;       /*!< GPIO8_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO9_LEVEL_LOW : 1;       /*!< GPIO9_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< GPIO9_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO9_EDGE_LOW : 1;        /*!< GPIO9_EDGE_LOW                                                            */
      __IM  uint32_t GPIO9_EDGE_HIGH : 1;       /*!< GPIO9_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO10_LEVEL_LOW : 1;      /*!< GPIO10_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< GPIO10_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO10_EDGE_LOW : 1;       /*!< GPIO10_EDGE_LOW                                                           */
      __IM  uint32_t GPIO10_EDGE_HIGH : 1;      /*!< GPIO10_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO11_LEVEL_LOW : 1;      /*!< GPIO11_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< GPIO11_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO11_EDGE_LOW : 1;       /*!< GPIO11_EDGE_LOW                                                           */
      __IM  uint32_t GPIO11_EDGE_HIGH : 1;      /*!< GPIO11_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO12_LEVEL_LOW : 1;      /*!< GPIO12_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< GPIO12_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO12_EDGE_LOW : 1;       /*!< GPIO12_EDGE_LOW                                                           */
      __IM  uint32_t GPIO12_EDGE_HIGH : 1;      /*!< GPIO12_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO13_LEVEL_LOW : 1;      /*!< GPIO13_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< GPIO13_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO13_EDGE_LOW : 1;       /*!< GPIO13_EDGE_LOW                                                           */
      __IM  uint32_t GPIO13_EDGE_HIGH : 1;      /*!< GPIO13_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO14_LEVEL_LOW : 1;      /*!< GPIO14_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< GPIO14_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO14_EDGE_LOW : 1;       /*!< GPIO14_EDGE_LOW                                                           */
      __IM  uint32_t GPIO14_EDGE_HIGH : 1;      /*!< GPIO14_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO15_LEVEL_LOW : 1;      /*!< GPIO15_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< GPIO15_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO15_EDGE_LOW : 1;       /*!< GPIO15_EDGE_LOW                                                           */
      __IM  uint32_t GPIO15_EDGE_HIGH : 1;      /*!< GPIO15_EDGE_HIGH                                                          */
    } bit;
  } PROC0_INTS1;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing for proc0                        */
    
    struct {
      __IM  uint32_t GPIO16_LEVEL_LOW : 1;      /*!< GPIO16_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< GPIO16_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO16_EDGE_LOW : 1;       /*!< GPIO16_EDGE_LOW                                                           */
      __IM  uint32_t GPIO16_EDGE_HIGH : 1;      /*!< GPIO16_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO17_LEVEL_LOW : 1;      /*!< GPIO17_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< GPIO17_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO17_EDGE_LOW : 1;       /*!< GPIO17_EDGE_LOW                                                           */
      __IM  uint32_t GPIO17_EDGE_HIGH : 1;      /*!< GPIO17_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO18_LEVEL_LOW : 1;      /*!< GPIO18_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< GPIO18_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO18_EDGE_LOW : 1;       /*!< GPIO18_EDGE_LOW                                                           */
      __IM  uint32_t GPIO18_EDGE_HIGH : 1;      /*!< GPIO18_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO19_LEVEL_LOW : 1;      /*!< GPIO19_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< GPIO19_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO19_EDGE_LOW : 1;       /*!< GPIO19_EDGE_LOW                                                           */
      __IM  uint32_t GPIO19_EDGE_HIGH : 1;      /*!< GPIO19_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO20_LEVEL_LOW : 1;      /*!< GPIO20_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< GPIO20_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO20_EDGE_LOW : 1;       /*!< GPIO20_EDGE_LOW                                                           */
      __IM  uint32_t GPIO20_EDGE_HIGH : 1;      /*!< GPIO20_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO21_LEVEL_LOW : 1;      /*!< GPIO21_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< GPIO21_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO21_EDGE_LOW : 1;       /*!< GPIO21_EDGE_LOW                                                           */
      __IM  uint32_t GPIO21_EDGE_HIGH : 1;      /*!< GPIO21_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO22_LEVEL_LOW : 1;      /*!< GPIO22_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< GPIO22_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO22_EDGE_LOW : 1;       /*!< GPIO22_EDGE_LOW                                                           */
      __IM  uint32_t GPIO22_EDGE_HIGH : 1;      /*!< GPIO22_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO23_LEVEL_LOW : 1;      /*!< GPIO23_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< GPIO23_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO23_EDGE_LOW : 1;       /*!< GPIO23_EDGE_LOW                                                           */
      __IM  uint32_t GPIO23_EDGE_HIGH : 1;      /*!< GPIO23_EDGE_HIGH                                                          */
    } bit;
  } PROC0_INTS2;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing for proc0                        */
    
    struct {
      __IM  uint32_t GPIO24_LEVEL_LOW : 1;      /*!< GPIO24_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< GPIO24_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO24_EDGE_LOW : 1;       /*!< GPIO24_EDGE_LOW                                                           */
      __IM  uint32_t GPIO24_EDGE_HIGH : 1;      /*!< GPIO24_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO25_LEVEL_LOW : 1;      /*!< GPIO25_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< GPIO25_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO25_EDGE_LOW : 1;       /*!< GPIO25_EDGE_LOW                                                           */
      __IM  uint32_t GPIO25_EDGE_HIGH : 1;      /*!< GPIO25_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO26_LEVEL_LOW : 1;      /*!< GPIO26_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< GPIO26_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO26_EDGE_LOW : 1;       /*!< GPIO26_EDGE_LOW                                                           */
      __IM  uint32_t GPIO26_EDGE_HIGH : 1;      /*!< GPIO26_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO27_LEVEL_LOW : 1;      /*!< GPIO27_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< GPIO27_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO27_EDGE_LOW : 1;       /*!< GPIO27_EDGE_LOW                                                           */
      __IM  uint32_t GPIO27_EDGE_HIGH : 1;      /*!< GPIO27_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO28_LEVEL_LOW : 1;      /*!< GPIO28_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< GPIO28_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO28_EDGE_LOW : 1;       /*!< GPIO28_EDGE_LOW                                                           */
      __IM  uint32_t GPIO28_EDGE_HIGH : 1;      /*!< GPIO28_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO29_LEVEL_LOW : 1;      /*!< GPIO29_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< GPIO29_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO29_EDGE_LOW : 1;       /*!< GPIO29_EDGE_LOW                                                           */
      __IM  uint32_t GPIO29_EDGE_HIGH : 1;      /*!< GPIO29_EDGE_HIGH                                                          */
            uint32_t            : 8;
    } bit;
  } PROC0_INTS3;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable for proc1                                                */
    
    struct {
      __IOM uint32_t GPIO0_LEVEL_LOW : 1;       /*!< GPIO0_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< GPIO0_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO0_EDGE_LOW : 1;        /*!< GPIO0_EDGE_LOW                                                            */
      __IOM uint32_t GPIO0_EDGE_HIGH : 1;       /*!< GPIO0_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO1_LEVEL_LOW : 1;       /*!< GPIO1_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< GPIO1_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO1_EDGE_LOW : 1;        /*!< GPIO1_EDGE_LOW                                                            */
      __IOM uint32_t GPIO1_EDGE_HIGH : 1;       /*!< GPIO1_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO2_LEVEL_LOW : 1;       /*!< GPIO2_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< GPIO2_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO2_EDGE_LOW : 1;        /*!< GPIO2_EDGE_LOW                                                            */
      __IOM uint32_t GPIO2_EDGE_HIGH : 1;       /*!< GPIO2_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO3_LEVEL_LOW : 1;       /*!< GPIO3_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< GPIO3_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO3_EDGE_LOW : 1;        /*!< GPIO3_EDGE_LOW                                                            */
      __IOM uint32_t GPIO3_EDGE_HIGH : 1;       /*!< GPIO3_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO4_LEVEL_LOW : 1;       /*!< GPIO4_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< GPIO4_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO4_EDGE_LOW : 1;        /*!< GPIO4_EDGE_LOW                                                            */
      __IOM uint32_t GPIO4_EDGE_HIGH : 1;       /*!< GPIO4_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO5_LEVEL_LOW : 1;       /*!< GPIO5_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< GPIO5_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO5_EDGE_LOW : 1;        /*!< GPIO5_EDGE_LOW                                                            */
      __IOM uint32_t GPIO5_EDGE_HIGH : 1;       /*!< GPIO5_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO6_LEVEL_LOW : 1;       /*!< GPIO6_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< GPIO6_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO6_EDGE_LOW : 1;        /*!< GPIO6_EDGE_LOW                                                            */
      __IOM uint32_t GPIO6_EDGE_HIGH : 1;       /*!< GPIO6_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO7_LEVEL_LOW : 1;       /*!< GPIO7_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< GPIO7_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO7_EDGE_LOW : 1;        /*!< GPIO7_EDGE_LOW                                                            */
      __IOM uint32_t GPIO7_EDGE_HIGH : 1;       /*!< GPIO7_EDGE_HIGH                                                           */
    } bit;
  } PROC1_INTE0;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable for proc1                                                */
    
    struct {
      __IOM uint32_t GPIO8_LEVEL_LOW : 1;       /*!< GPIO8_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< GPIO8_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO8_EDGE_LOW : 1;        /*!< GPIO8_EDGE_LOW                                                            */
      __IOM uint32_t GPIO8_EDGE_HIGH : 1;       /*!< GPIO8_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO9_LEVEL_LOW : 1;       /*!< GPIO9_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< GPIO9_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO9_EDGE_LOW : 1;        /*!< GPIO9_EDGE_LOW                                                            */
      __IOM uint32_t GPIO9_EDGE_HIGH : 1;       /*!< GPIO9_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO10_LEVEL_LOW : 1;      /*!< GPIO10_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< GPIO10_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO10_EDGE_LOW : 1;       /*!< GPIO10_EDGE_LOW                                                           */
      __IOM uint32_t GPIO10_EDGE_HIGH : 1;      /*!< GPIO10_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO11_LEVEL_LOW : 1;      /*!< GPIO11_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< GPIO11_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO11_EDGE_LOW : 1;       /*!< GPIO11_EDGE_LOW                                                           */
      __IOM uint32_t GPIO11_EDGE_HIGH : 1;      /*!< GPIO11_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO12_LEVEL_LOW : 1;      /*!< GPIO12_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< GPIO12_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO12_EDGE_LOW : 1;       /*!< GPIO12_EDGE_LOW                                                           */
      __IOM uint32_t GPIO12_EDGE_HIGH : 1;      /*!< GPIO12_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO13_LEVEL_LOW : 1;      /*!< GPIO13_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< GPIO13_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO13_EDGE_LOW : 1;       /*!< GPIO13_EDGE_LOW                                                           */
      __IOM uint32_t GPIO13_EDGE_HIGH : 1;      /*!< GPIO13_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO14_LEVEL_LOW : 1;      /*!< GPIO14_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< GPIO14_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO14_EDGE_LOW : 1;       /*!< GPIO14_EDGE_LOW                                                           */
      __IOM uint32_t GPIO14_EDGE_HIGH : 1;      /*!< GPIO14_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO15_LEVEL_LOW : 1;      /*!< GPIO15_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< GPIO15_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO15_EDGE_LOW : 1;       /*!< GPIO15_EDGE_LOW                                                           */
      __IOM uint32_t GPIO15_EDGE_HIGH : 1;      /*!< GPIO15_EDGE_HIGH                                                          */
    } bit;
  } PROC1_INTE1;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable for proc1                                                */
    
    struct {
      __IOM uint32_t GPIO16_LEVEL_LOW : 1;      /*!< GPIO16_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< GPIO16_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO16_EDGE_LOW : 1;       /*!< GPIO16_EDGE_LOW                                                           */
      __IOM uint32_t GPIO16_EDGE_HIGH : 1;      /*!< GPIO16_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO17_LEVEL_LOW : 1;      /*!< GPIO17_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< GPIO17_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO17_EDGE_LOW : 1;       /*!< GPIO17_EDGE_LOW                                                           */
      __IOM uint32_t GPIO17_EDGE_HIGH : 1;      /*!< GPIO17_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO18_LEVEL_LOW : 1;      /*!< GPIO18_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< GPIO18_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO18_EDGE_LOW : 1;       /*!< GPIO18_EDGE_LOW                                                           */
      __IOM uint32_t GPIO18_EDGE_HIGH : 1;      /*!< GPIO18_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO19_LEVEL_LOW : 1;      /*!< GPIO19_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< GPIO19_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO19_EDGE_LOW : 1;       /*!< GPIO19_EDGE_LOW                                                           */
      __IOM uint32_t GPIO19_EDGE_HIGH : 1;      /*!< GPIO19_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO20_LEVEL_LOW : 1;      /*!< GPIO20_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< GPIO20_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO20_EDGE_LOW : 1;       /*!< GPIO20_EDGE_LOW                                                           */
      __IOM uint32_t GPIO20_EDGE_HIGH : 1;      /*!< GPIO20_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO21_LEVEL_LOW : 1;      /*!< GPIO21_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< GPIO21_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO21_EDGE_LOW : 1;       /*!< GPIO21_EDGE_LOW                                                           */
      __IOM uint32_t GPIO21_EDGE_HIGH : 1;      /*!< GPIO21_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO22_LEVEL_LOW : 1;      /*!< GPIO22_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< GPIO22_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO22_EDGE_LOW : 1;       /*!< GPIO22_EDGE_LOW                                                           */
      __IOM uint32_t GPIO22_EDGE_HIGH : 1;      /*!< GPIO22_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO23_LEVEL_LOW : 1;      /*!< GPIO23_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< GPIO23_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO23_EDGE_LOW : 1;       /*!< GPIO23_EDGE_LOW                                                           */
      __IOM uint32_t GPIO23_EDGE_HIGH : 1;      /*!< GPIO23_EDGE_HIGH                                                          */
    } bit;
  } PROC1_INTE2;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable for proc1                                                */
    
    struct {
      __IOM uint32_t GPIO24_LEVEL_LOW : 1;      /*!< GPIO24_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< GPIO24_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO24_EDGE_LOW : 1;       /*!< GPIO24_EDGE_LOW                                                           */
      __IOM uint32_t GPIO24_EDGE_HIGH : 1;      /*!< GPIO24_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO25_LEVEL_LOW : 1;      /*!< GPIO25_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< GPIO25_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO25_EDGE_LOW : 1;       /*!< GPIO25_EDGE_LOW                                                           */
      __IOM uint32_t GPIO25_EDGE_HIGH : 1;      /*!< GPIO25_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO26_LEVEL_LOW : 1;      /*!< GPIO26_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< GPIO26_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO26_EDGE_LOW : 1;       /*!< GPIO26_EDGE_LOW                                                           */
      __IOM uint32_t GPIO26_EDGE_HIGH : 1;      /*!< GPIO26_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO27_LEVEL_LOW : 1;      /*!< GPIO27_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< GPIO27_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO27_EDGE_LOW : 1;       /*!< GPIO27_EDGE_LOW                                                           */
      __IOM uint32_t GPIO27_EDGE_HIGH : 1;      /*!< GPIO27_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO28_LEVEL_LOW : 1;      /*!< GPIO28_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< GPIO28_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO28_EDGE_LOW : 1;       /*!< GPIO28_EDGE_LOW                                                           */
      __IOM uint32_t GPIO28_EDGE_HIGH : 1;      /*!< GPIO28_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO29_LEVEL_LOW : 1;      /*!< GPIO29_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< GPIO29_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO29_EDGE_LOW : 1;       /*!< GPIO29_EDGE_LOW                                                           */
      __IOM uint32_t GPIO29_EDGE_HIGH : 1;      /*!< GPIO29_EDGE_HIGH                                                          */
            uint32_t            : 8;
    } bit;
  } PROC1_INTE3;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force for proc1                                                 */
    
    struct {
      __IOM uint32_t GPIO0_LEVEL_LOW : 1;       /*!< GPIO0_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< GPIO0_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO0_EDGE_LOW : 1;        /*!< GPIO0_EDGE_LOW                                                            */
      __IOM uint32_t GPIO0_EDGE_HIGH : 1;       /*!< GPIO0_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO1_LEVEL_LOW : 1;       /*!< GPIO1_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< GPIO1_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO1_EDGE_LOW : 1;        /*!< GPIO1_EDGE_LOW                                                            */
      __IOM uint32_t GPIO1_EDGE_HIGH : 1;       /*!< GPIO1_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO2_LEVEL_LOW : 1;       /*!< GPIO2_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< GPIO2_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO2_EDGE_LOW : 1;        /*!< GPIO2_EDGE_LOW                                                            */
      __IOM uint32_t GPIO2_EDGE_HIGH : 1;       /*!< GPIO2_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO3_LEVEL_LOW : 1;       /*!< GPIO3_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< GPIO3_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO3_EDGE_LOW : 1;        /*!< GPIO3_EDGE_LOW                                                            */
      __IOM uint32_t GPIO3_EDGE_HIGH : 1;       /*!< GPIO3_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO4_LEVEL_LOW : 1;       /*!< GPIO4_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< GPIO4_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO4_EDGE_LOW : 1;        /*!< GPIO4_EDGE_LOW                                                            */
      __IOM uint32_t GPIO4_EDGE_HIGH : 1;       /*!< GPIO4_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO5_LEVEL_LOW : 1;       /*!< GPIO5_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< GPIO5_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO5_EDGE_LOW : 1;        /*!< GPIO5_EDGE_LOW                                                            */
      __IOM uint32_t GPIO5_EDGE_HIGH : 1;       /*!< GPIO5_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO6_LEVEL_LOW : 1;       /*!< GPIO6_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< GPIO6_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO6_EDGE_LOW : 1;        /*!< GPIO6_EDGE_LOW                                                            */
      __IOM uint32_t GPIO6_EDGE_HIGH : 1;       /*!< GPIO6_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO7_LEVEL_LOW : 1;       /*!< GPIO7_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< GPIO7_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO7_EDGE_LOW : 1;        /*!< GPIO7_EDGE_LOW                                                            */
      __IOM uint32_t GPIO7_EDGE_HIGH : 1;       /*!< GPIO7_EDGE_HIGH                                                           */
    } bit;
  } PROC1_INTF0;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force for proc1                                                 */
    
    struct {
      __IOM uint32_t GPIO8_LEVEL_LOW : 1;       /*!< GPIO8_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< GPIO8_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO8_EDGE_LOW : 1;        /*!< GPIO8_EDGE_LOW                                                            */
      __IOM uint32_t GPIO8_EDGE_HIGH : 1;       /*!< GPIO8_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO9_LEVEL_LOW : 1;       /*!< GPIO9_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< GPIO9_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO9_EDGE_LOW : 1;        /*!< GPIO9_EDGE_LOW                                                            */
      __IOM uint32_t GPIO9_EDGE_HIGH : 1;       /*!< GPIO9_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO10_LEVEL_LOW : 1;      /*!< GPIO10_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< GPIO10_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO10_EDGE_LOW : 1;       /*!< GPIO10_EDGE_LOW                                                           */
      __IOM uint32_t GPIO10_EDGE_HIGH : 1;      /*!< GPIO10_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO11_LEVEL_LOW : 1;      /*!< GPIO11_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< GPIO11_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO11_EDGE_LOW : 1;       /*!< GPIO11_EDGE_LOW                                                           */
      __IOM uint32_t GPIO11_EDGE_HIGH : 1;      /*!< GPIO11_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO12_LEVEL_LOW : 1;      /*!< GPIO12_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< GPIO12_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO12_EDGE_LOW : 1;       /*!< GPIO12_EDGE_LOW                                                           */
      __IOM uint32_t GPIO12_EDGE_HIGH : 1;      /*!< GPIO12_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO13_LEVEL_LOW : 1;      /*!< GPIO13_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< GPIO13_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO13_EDGE_LOW : 1;       /*!< GPIO13_EDGE_LOW                                                           */
      __IOM uint32_t GPIO13_EDGE_HIGH : 1;      /*!< GPIO13_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO14_LEVEL_LOW : 1;      /*!< GPIO14_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< GPIO14_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO14_EDGE_LOW : 1;       /*!< GPIO14_EDGE_LOW                                                           */
      __IOM uint32_t GPIO14_EDGE_HIGH : 1;      /*!< GPIO14_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO15_LEVEL_LOW : 1;      /*!< GPIO15_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< GPIO15_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO15_EDGE_LOW : 1;       /*!< GPIO15_EDGE_LOW                                                           */
      __IOM uint32_t GPIO15_EDGE_HIGH : 1;      /*!< GPIO15_EDGE_HIGH                                                          */
    } bit;
  } PROC1_INTF1;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force for proc1                                                 */
    
    struct {
      __IOM uint32_t GPIO16_LEVEL_LOW : 1;      /*!< GPIO16_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< GPIO16_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO16_EDGE_LOW : 1;       /*!< GPIO16_EDGE_LOW                                                           */
      __IOM uint32_t GPIO16_EDGE_HIGH : 1;      /*!< GPIO16_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO17_LEVEL_LOW : 1;      /*!< GPIO17_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< GPIO17_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO17_EDGE_LOW : 1;       /*!< GPIO17_EDGE_LOW                                                           */
      __IOM uint32_t GPIO17_EDGE_HIGH : 1;      /*!< GPIO17_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO18_LEVEL_LOW : 1;      /*!< GPIO18_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< GPIO18_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO18_EDGE_LOW : 1;       /*!< GPIO18_EDGE_LOW                                                           */
      __IOM uint32_t GPIO18_EDGE_HIGH : 1;      /*!< GPIO18_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO19_LEVEL_LOW : 1;      /*!< GPIO19_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< GPIO19_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO19_EDGE_LOW : 1;       /*!< GPIO19_EDGE_LOW                                                           */
      __IOM uint32_t GPIO19_EDGE_HIGH : 1;      /*!< GPIO19_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO20_LEVEL_LOW : 1;      /*!< GPIO20_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< GPIO20_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO20_EDGE_LOW : 1;       /*!< GPIO20_EDGE_LOW                                                           */
      __IOM uint32_t GPIO20_EDGE_HIGH : 1;      /*!< GPIO20_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO21_LEVEL_LOW : 1;      /*!< GPIO21_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< GPIO21_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO21_EDGE_LOW : 1;       /*!< GPIO21_EDGE_LOW                                                           */
      __IOM uint32_t GPIO21_EDGE_HIGH : 1;      /*!< GPIO21_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO22_LEVEL_LOW : 1;      /*!< GPIO22_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< GPIO22_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO22_EDGE_LOW : 1;       /*!< GPIO22_EDGE_LOW                                                           */
      __IOM uint32_t GPIO22_EDGE_HIGH : 1;      /*!< GPIO22_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO23_LEVEL_LOW : 1;      /*!< GPIO23_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< GPIO23_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO23_EDGE_LOW : 1;       /*!< GPIO23_EDGE_LOW                                                           */
      __IOM uint32_t GPIO23_EDGE_HIGH : 1;      /*!< GPIO23_EDGE_HIGH                                                          */
    } bit;
  } PROC1_INTF2;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force for proc1                                                 */
    
    struct {
      __IOM uint32_t GPIO24_LEVEL_LOW : 1;      /*!< GPIO24_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< GPIO24_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO24_EDGE_LOW : 1;       /*!< GPIO24_EDGE_LOW                                                           */
      __IOM uint32_t GPIO24_EDGE_HIGH : 1;      /*!< GPIO24_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO25_LEVEL_LOW : 1;      /*!< GPIO25_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< GPIO25_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO25_EDGE_LOW : 1;       /*!< GPIO25_EDGE_LOW                                                           */
      __IOM uint32_t GPIO25_EDGE_HIGH : 1;      /*!< GPIO25_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO26_LEVEL_LOW : 1;      /*!< GPIO26_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< GPIO26_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO26_EDGE_LOW : 1;       /*!< GPIO26_EDGE_LOW                                                           */
      __IOM uint32_t GPIO26_EDGE_HIGH : 1;      /*!< GPIO26_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO27_LEVEL_LOW : 1;      /*!< GPIO27_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< GPIO27_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO27_EDGE_LOW : 1;       /*!< GPIO27_EDGE_LOW                                                           */
      __IOM uint32_t GPIO27_EDGE_HIGH : 1;      /*!< GPIO27_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO28_LEVEL_LOW : 1;      /*!< GPIO28_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< GPIO28_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO28_EDGE_LOW : 1;       /*!< GPIO28_EDGE_LOW                                                           */
      __IOM uint32_t GPIO28_EDGE_HIGH : 1;      /*!< GPIO28_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO29_LEVEL_LOW : 1;      /*!< GPIO29_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< GPIO29_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO29_EDGE_LOW : 1;       /*!< GPIO29_EDGE_LOW                                                           */
      __IOM uint32_t GPIO29_EDGE_HIGH : 1;      /*!< GPIO29_EDGE_HIGH                                                          */
            uint32_t            : 8;
    } bit;
  } PROC1_INTF3;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing for proc1                        */
    
    struct {
      __IM  uint32_t GPIO0_LEVEL_LOW : 1;       /*!< GPIO0_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< GPIO0_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO0_EDGE_LOW : 1;        /*!< GPIO0_EDGE_LOW                                                            */
      __IM  uint32_t GPIO0_EDGE_HIGH : 1;       /*!< GPIO0_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO1_LEVEL_LOW : 1;       /*!< GPIO1_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< GPIO1_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO1_EDGE_LOW : 1;        /*!< GPIO1_EDGE_LOW                                                            */
      __IM  uint32_t GPIO1_EDGE_HIGH : 1;       /*!< GPIO1_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO2_LEVEL_LOW : 1;       /*!< GPIO2_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< GPIO2_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO2_EDGE_LOW : 1;        /*!< GPIO2_EDGE_LOW                                                            */
      __IM  uint32_t GPIO2_EDGE_HIGH : 1;       /*!< GPIO2_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO3_LEVEL_LOW : 1;       /*!< GPIO3_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< GPIO3_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO3_EDGE_LOW : 1;        /*!< GPIO3_EDGE_LOW                                                            */
      __IM  uint32_t GPIO3_EDGE_HIGH : 1;       /*!< GPIO3_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO4_LEVEL_LOW : 1;       /*!< GPIO4_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< GPIO4_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO4_EDGE_LOW : 1;        /*!< GPIO4_EDGE_LOW                                                            */
      __IM  uint32_t GPIO4_EDGE_HIGH : 1;       /*!< GPIO4_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO5_LEVEL_LOW : 1;       /*!< GPIO5_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< GPIO5_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO5_EDGE_LOW : 1;        /*!< GPIO5_EDGE_LOW                                                            */
      __IM  uint32_t GPIO5_EDGE_HIGH : 1;       /*!< GPIO5_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO6_LEVEL_LOW : 1;       /*!< GPIO6_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< GPIO6_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO6_EDGE_LOW : 1;        /*!< GPIO6_EDGE_LOW                                                            */
      __IM  uint32_t GPIO6_EDGE_HIGH : 1;       /*!< GPIO6_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO7_LEVEL_LOW : 1;       /*!< GPIO7_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< GPIO7_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO7_EDGE_LOW : 1;        /*!< GPIO7_EDGE_LOW                                                            */
      __IM  uint32_t GPIO7_EDGE_HIGH : 1;       /*!< GPIO7_EDGE_HIGH                                                           */
    } bit;
  } PROC1_INTS0;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing for proc1                        */
    
    struct {
      __IM  uint32_t GPIO8_LEVEL_LOW : 1;       /*!< GPIO8_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< GPIO8_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO8_EDGE_LOW : 1;        /*!< GPIO8_EDGE_LOW                                                            */
      __IM  uint32_t GPIO8_EDGE_HIGH : 1;       /*!< GPIO8_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO9_LEVEL_LOW : 1;       /*!< GPIO9_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< GPIO9_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO9_EDGE_LOW : 1;        /*!< GPIO9_EDGE_LOW                                                            */
      __IM  uint32_t GPIO9_EDGE_HIGH : 1;       /*!< GPIO9_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO10_LEVEL_LOW : 1;      /*!< GPIO10_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< GPIO10_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO10_EDGE_LOW : 1;       /*!< GPIO10_EDGE_LOW                                                           */
      __IM  uint32_t GPIO10_EDGE_HIGH : 1;      /*!< GPIO10_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO11_LEVEL_LOW : 1;      /*!< GPIO11_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< GPIO11_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO11_EDGE_LOW : 1;       /*!< GPIO11_EDGE_LOW                                                           */
      __IM  uint32_t GPIO11_EDGE_HIGH : 1;      /*!< GPIO11_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO12_LEVEL_LOW : 1;      /*!< GPIO12_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< GPIO12_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO12_EDGE_LOW : 1;       /*!< GPIO12_EDGE_LOW                                                           */
      __IM  uint32_t GPIO12_EDGE_HIGH : 1;      /*!< GPIO12_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO13_LEVEL_LOW : 1;      /*!< GPIO13_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< GPIO13_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO13_EDGE_LOW : 1;       /*!< GPIO13_EDGE_LOW                                                           */
      __IM  uint32_t GPIO13_EDGE_HIGH : 1;      /*!< GPIO13_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO14_LEVEL_LOW : 1;      /*!< GPIO14_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< GPIO14_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO14_EDGE_LOW : 1;       /*!< GPIO14_EDGE_LOW                                                           */
      __IM  uint32_t GPIO14_EDGE_HIGH : 1;      /*!< GPIO14_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO15_LEVEL_LOW : 1;      /*!< GPIO15_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< GPIO15_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO15_EDGE_LOW : 1;       /*!< GPIO15_EDGE_LOW                                                           */
      __IM  uint32_t GPIO15_EDGE_HIGH : 1;      /*!< GPIO15_EDGE_HIGH                                                          */
    } bit;
  } PROC1_INTS1;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing for proc1                        */
    
    struct {
      __IM  uint32_t GPIO16_LEVEL_LOW : 1;      /*!< GPIO16_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< GPIO16_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO16_EDGE_LOW : 1;       /*!< GPIO16_EDGE_LOW                                                           */
      __IM  uint32_t GPIO16_EDGE_HIGH : 1;      /*!< GPIO16_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO17_LEVEL_LOW : 1;      /*!< GPIO17_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< GPIO17_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO17_EDGE_LOW : 1;       /*!< GPIO17_EDGE_LOW                                                           */
      __IM  uint32_t GPIO17_EDGE_HIGH : 1;      /*!< GPIO17_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO18_LEVEL_LOW : 1;      /*!< GPIO18_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< GPIO18_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO18_EDGE_LOW : 1;       /*!< GPIO18_EDGE_LOW                                                           */
      __IM  uint32_t GPIO18_EDGE_HIGH : 1;      /*!< GPIO18_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO19_LEVEL_LOW : 1;      /*!< GPIO19_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< GPIO19_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO19_EDGE_LOW : 1;       /*!< GPIO19_EDGE_LOW                                                           */
      __IM  uint32_t GPIO19_EDGE_HIGH : 1;      /*!< GPIO19_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO20_LEVEL_LOW : 1;      /*!< GPIO20_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< GPIO20_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO20_EDGE_LOW : 1;       /*!< GPIO20_EDGE_LOW                                                           */
      __IM  uint32_t GPIO20_EDGE_HIGH : 1;      /*!< GPIO20_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO21_LEVEL_LOW : 1;      /*!< GPIO21_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< GPIO21_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO21_EDGE_LOW : 1;       /*!< GPIO21_EDGE_LOW                                                           */
      __IM  uint32_t GPIO21_EDGE_HIGH : 1;      /*!< GPIO21_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO22_LEVEL_LOW : 1;      /*!< GPIO22_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< GPIO22_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO22_EDGE_LOW : 1;       /*!< GPIO22_EDGE_LOW                                                           */
      __IM  uint32_t GPIO22_EDGE_HIGH : 1;      /*!< GPIO22_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO23_LEVEL_LOW : 1;      /*!< GPIO23_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< GPIO23_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO23_EDGE_LOW : 1;       /*!< GPIO23_EDGE_LOW                                                           */
      __IM  uint32_t GPIO23_EDGE_HIGH : 1;      /*!< GPIO23_EDGE_HIGH                                                          */
    } bit;
  } PROC1_INTS2;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing for proc1                        */
    
    struct {
      __IM  uint32_t GPIO24_LEVEL_LOW : 1;      /*!< GPIO24_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< GPIO24_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO24_EDGE_LOW : 1;       /*!< GPIO24_EDGE_LOW                                                           */
      __IM  uint32_t GPIO24_EDGE_HIGH : 1;      /*!< GPIO24_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO25_LEVEL_LOW : 1;      /*!< GPIO25_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< GPIO25_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO25_EDGE_LOW : 1;       /*!< GPIO25_EDGE_LOW                                                           */
      __IM  uint32_t GPIO25_EDGE_HIGH : 1;      /*!< GPIO25_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO26_LEVEL_LOW : 1;      /*!< GPIO26_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< GPIO26_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO26_EDGE_LOW : 1;       /*!< GPIO26_EDGE_LOW                                                           */
      __IM  uint32_t GPIO26_EDGE_HIGH : 1;      /*!< GPIO26_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO27_LEVEL_LOW : 1;      /*!< GPIO27_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< GPIO27_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO27_EDGE_LOW : 1;       /*!< GPIO27_EDGE_LOW                                                           */
      __IM  uint32_t GPIO27_EDGE_HIGH : 1;      /*!< GPIO27_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO28_LEVEL_LOW : 1;      /*!< GPIO28_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< GPIO28_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO28_EDGE_LOW : 1;       /*!< GPIO28_EDGE_LOW                                                           */
      __IM  uint32_t GPIO28_EDGE_HIGH : 1;      /*!< GPIO28_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO29_LEVEL_LOW : 1;      /*!< GPIO29_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< GPIO29_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO29_EDGE_LOW : 1;       /*!< GPIO29_EDGE_LOW                                                           */
      __IM  uint32_t GPIO29_EDGE_HIGH : 1;      /*!< GPIO29_EDGE_HIGH                                                          */
            uint32_t            : 8;
    } bit;
  } PROC1_INTS3;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable for dormant_wake                                         */
    
    struct {
      __IOM uint32_t GPIO0_LEVEL_LOW : 1;       /*!< GPIO0_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< GPIO0_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO0_EDGE_LOW : 1;        /*!< GPIO0_EDGE_LOW                                                            */
      __IOM uint32_t GPIO0_EDGE_HIGH : 1;       /*!< GPIO0_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO1_LEVEL_LOW : 1;       /*!< GPIO1_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< GPIO1_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO1_EDGE_LOW : 1;        /*!< GPIO1_EDGE_LOW                                                            */
      __IOM uint32_t GPIO1_EDGE_HIGH : 1;       /*!< GPIO1_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO2_LEVEL_LOW : 1;       /*!< GPIO2_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< GPIO2_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO2_EDGE_LOW : 1;        /*!< GPIO2_EDGE_LOW                                                            */
      __IOM uint32_t GPIO2_EDGE_HIGH : 1;       /*!< GPIO2_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO3_LEVEL_LOW : 1;       /*!< GPIO3_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< GPIO3_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO3_EDGE_LOW : 1;        /*!< GPIO3_EDGE_LOW                                                            */
      __IOM uint32_t GPIO3_EDGE_HIGH : 1;       /*!< GPIO3_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO4_LEVEL_LOW : 1;       /*!< GPIO4_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< GPIO4_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO4_EDGE_LOW : 1;        /*!< GPIO4_EDGE_LOW                                                            */
      __IOM uint32_t GPIO4_EDGE_HIGH : 1;       /*!< GPIO4_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO5_LEVEL_LOW : 1;       /*!< GPIO5_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< GPIO5_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO5_EDGE_LOW : 1;        /*!< GPIO5_EDGE_LOW                                                            */
      __IOM uint32_t GPIO5_EDGE_HIGH : 1;       /*!< GPIO5_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO6_LEVEL_LOW : 1;       /*!< GPIO6_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< GPIO6_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO6_EDGE_LOW : 1;        /*!< GPIO6_EDGE_LOW                                                            */
      __IOM uint32_t GPIO6_EDGE_HIGH : 1;       /*!< GPIO6_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO7_LEVEL_LOW : 1;       /*!< GPIO7_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< GPIO7_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO7_EDGE_LOW : 1;        /*!< GPIO7_EDGE_LOW                                                            */
      __IOM uint32_t GPIO7_EDGE_HIGH : 1;       /*!< GPIO7_EDGE_HIGH                                                           */
    } bit;
  } DORMANT_WAKE_INTE0;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable for dormant_wake                                         */
    
    struct {
      __IOM uint32_t GPIO8_LEVEL_LOW : 1;       /*!< GPIO8_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< GPIO8_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO8_EDGE_LOW : 1;        /*!< GPIO8_EDGE_LOW                                                            */
      __IOM uint32_t GPIO8_EDGE_HIGH : 1;       /*!< GPIO8_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO9_LEVEL_LOW : 1;       /*!< GPIO9_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< GPIO9_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO9_EDGE_LOW : 1;        /*!< GPIO9_EDGE_LOW                                                            */
      __IOM uint32_t GPIO9_EDGE_HIGH : 1;       /*!< GPIO9_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO10_LEVEL_LOW : 1;      /*!< GPIO10_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< GPIO10_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO10_EDGE_LOW : 1;       /*!< GPIO10_EDGE_LOW                                                           */
      __IOM uint32_t GPIO10_EDGE_HIGH : 1;      /*!< GPIO10_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO11_LEVEL_LOW : 1;      /*!< GPIO11_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< GPIO11_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO11_EDGE_LOW : 1;       /*!< GPIO11_EDGE_LOW                                                           */
      __IOM uint32_t GPIO11_EDGE_HIGH : 1;      /*!< GPIO11_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO12_LEVEL_LOW : 1;      /*!< GPIO12_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< GPIO12_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO12_EDGE_LOW : 1;       /*!< GPIO12_EDGE_LOW                                                           */
      __IOM uint32_t GPIO12_EDGE_HIGH : 1;      /*!< GPIO12_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO13_LEVEL_LOW : 1;      /*!< GPIO13_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< GPIO13_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO13_EDGE_LOW : 1;       /*!< GPIO13_EDGE_LOW                                                           */
      __IOM uint32_t GPIO13_EDGE_HIGH : 1;      /*!< GPIO13_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO14_LEVEL_LOW : 1;      /*!< GPIO14_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< GPIO14_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO14_EDGE_LOW : 1;       /*!< GPIO14_EDGE_LOW                                                           */
      __IOM uint32_t GPIO14_EDGE_HIGH : 1;      /*!< GPIO14_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO15_LEVEL_LOW : 1;      /*!< GPIO15_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< GPIO15_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO15_EDGE_LOW : 1;       /*!< GPIO15_EDGE_LOW                                                           */
      __IOM uint32_t GPIO15_EDGE_HIGH : 1;      /*!< GPIO15_EDGE_HIGH                                                          */
    } bit;
  } DORMANT_WAKE_INTE1;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable for dormant_wake                                         */
    
    struct {
      __IOM uint32_t GPIO16_LEVEL_LOW : 1;      /*!< GPIO16_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< GPIO16_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO16_EDGE_LOW : 1;       /*!< GPIO16_EDGE_LOW                                                           */
      __IOM uint32_t GPIO16_EDGE_HIGH : 1;      /*!< GPIO16_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO17_LEVEL_LOW : 1;      /*!< GPIO17_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< GPIO17_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO17_EDGE_LOW : 1;       /*!< GPIO17_EDGE_LOW                                                           */
      __IOM uint32_t GPIO17_EDGE_HIGH : 1;      /*!< GPIO17_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO18_LEVEL_LOW : 1;      /*!< GPIO18_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< GPIO18_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO18_EDGE_LOW : 1;       /*!< GPIO18_EDGE_LOW                                                           */
      __IOM uint32_t GPIO18_EDGE_HIGH : 1;      /*!< GPIO18_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO19_LEVEL_LOW : 1;      /*!< GPIO19_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< GPIO19_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO19_EDGE_LOW : 1;       /*!< GPIO19_EDGE_LOW                                                           */
      __IOM uint32_t GPIO19_EDGE_HIGH : 1;      /*!< GPIO19_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO20_LEVEL_LOW : 1;      /*!< GPIO20_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< GPIO20_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO20_EDGE_LOW : 1;       /*!< GPIO20_EDGE_LOW                                                           */
      __IOM uint32_t GPIO20_EDGE_HIGH : 1;      /*!< GPIO20_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO21_LEVEL_LOW : 1;      /*!< GPIO21_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< GPIO21_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO21_EDGE_LOW : 1;       /*!< GPIO21_EDGE_LOW                                                           */
      __IOM uint32_t GPIO21_EDGE_HIGH : 1;      /*!< GPIO21_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO22_LEVEL_LOW : 1;      /*!< GPIO22_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< GPIO22_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO22_EDGE_LOW : 1;       /*!< GPIO22_EDGE_LOW                                                           */
      __IOM uint32_t GPIO22_EDGE_HIGH : 1;      /*!< GPIO22_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO23_LEVEL_LOW : 1;      /*!< GPIO23_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< GPIO23_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO23_EDGE_LOW : 1;       /*!< GPIO23_EDGE_LOW                                                           */
      __IOM uint32_t GPIO23_EDGE_HIGH : 1;      /*!< GPIO23_EDGE_HIGH                                                          */
    } bit;
  } DORMANT_WAKE_INTE2;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable for dormant_wake                                         */
    
    struct {
      __IOM uint32_t GPIO24_LEVEL_LOW : 1;      /*!< GPIO24_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< GPIO24_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO24_EDGE_LOW : 1;       /*!< GPIO24_EDGE_LOW                                                           */
      __IOM uint32_t GPIO24_EDGE_HIGH : 1;      /*!< GPIO24_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO25_LEVEL_LOW : 1;      /*!< GPIO25_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< GPIO25_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO25_EDGE_LOW : 1;       /*!< GPIO25_EDGE_LOW                                                           */
      __IOM uint32_t GPIO25_EDGE_HIGH : 1;      /*!< GPIO25_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO26_LEVEL_LOW : 1;      /*!< GPIO26_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< GPIO26_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO26_EDGE_LOW : 1;       /*!< GPIO26_EDGE_LOW                                                           */
      __IOM uint32_t GPIO26_EDGE_HIGH : 1;      /*!< GPIO26_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO27_LEVEL_LOW : 1;      /*!< GPIO27_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< GPIO27_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO27_EDGE_LOW : 1;       /*!< GPIO27_EDGE_LOW                                                           */
      __IOM uint32_t GPIO27_EDGE_HIGH : 1;      /*!< GPIO27_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO28_LEVEL_LOW : 1;      /*!< GPIO28_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< GPIO28_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO28_EDGE_LOW : 1;       /*!< GPIO28_EDGE_LOW                                                           */
      __IOM uint32_t GPIO28_EDGE_HIGH : 1;      /*!< GPIO28_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO29_LEVEL_LOW : 1;      /*!< GPIO29_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< GPIO29_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO29_EDGE_LOW : 1;       /*!< GPIO29_EDGE_LOW                                                           */
      __IOM uint32_t GPIO29_EDGE_HIGH : 1;      /*!< GPIO29_EDGE_HIGH                                                          */
            uint32_t            : 8;
    } bit;
  } DORMANT_WAKE_INTE3;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force for dormant_wake                                          */
    
    struct {
      __IOM uint32_t GPIO0_LEVEL_LOW : 1;       /*!< GPIO0_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< GPIO0_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO0_EDGE_LOW : 1;        /*!< GPIO0_EDGE_LOW                                                            */
      __IOM uint32_t GPIO0_EDGE_HIGH : 1;       /*!< GPIO0_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO1_LEVEL_LOW : 1;       /*!< GPIO1_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< GPIO1_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO1_EDGE_LOW : 1;        /*!< GPIO1_EDGE_LOW                                                            */
      __IOM uint32_t GPIO1_EDGE_HIGH : 1;       /*!< GPIO1_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO2_LEVEL_LOW : 1;       /*!< GPIO2_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< GPIO2_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO2_EDGE_LOW : 1;        /*!< GPIO2_EDGE_LOW                                                            */
      __IOM uint32_t GPIO2_EDGE_HIGH : 1;       /*!< GPIO2_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO3_LEVEL_LOW : 1;       /*!< GPIO3_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< GPIO3_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO3_EDGE_LOW : 1;        /*!< GPIO3_EDGE_LOW                                                            */
      __IOM uint32_t GPIO3_EDGE_HIGH : 1;       /*!< GPIO3_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO4_LEVEL_LOW : 1;       /*!< GPIO4_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< GPIO4_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO4_EDGE_LOW : 1;        /*!< GPIO4_EDGE_LOW                                                            */
      __IOM uint32_t GPIO4_EDGE_HIGH : 1;       /*!< GPIO4_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO5_LEVEL_LOW : 1;       /*!< GPIO5_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< GPIO5_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO5_EDGE_LOW : 1;        /*!< GPIO5_EDGE_LOW                                                            */
      __IOM uint32_t GPIO5_EDGE_HIGH : 1;       /*!< GPIO5_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO6_LEVEL_LOW : 1;       /*!< GPIO6_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< GPIO6_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO6_EDGE_LOW : 1;        /*!< GPIO6_EDGE_LOW                                                            */
      __IOM uint32_t GPIO6_EDGE_HIGH : 1;       /*!< GPIO6_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO7_LEVEL_LOW : 1;       /*!< GPIO7_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< GPIO7_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO7_EDGE_LOW : 1;        /*!< GPIO7_EDGE_LOW                                                            */
      __IOM uint32_t GPIO7_EDGE_HIGH : 1;       /*!< GPIO7_EDGE_HIGH                                                           */
    } bit;
  } DORMANT_WAKE_INTF0;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force for dormant_wake                                          */
    
    struct {
      __IOM uint32_t GPIO8_LEVEL_LOW : 1;       /*!< GPIO8_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< GPIO8_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO8_EDGE_LOW : 1;        /*!< GPIO8_EDGE_LOW                                                            */
      __IOM uint32_t GPIO8_EDGE_HIGH : 1;       /*!< GPIO8_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO9_LEVEL_LOW : 1;       /*!< GPIO9_LEVEL_LOW                                                           */
      __IOM uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< GPIO9_LEVEL_HIGH                                                          */
      __IOM uint32_t GPIO9_EDGE_LOW : 1;        /*!< GPIO9_EDGE_LOW                                                            */
      __IOM uint32_t GPIO9_EDGE_HIGH : 1;       /*!< GPIO9_EDGE_HIGH                                                           */
      __IOM uint32_t GPIO10_LEVEL_LOW : 1;      /*!< GPIO10_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< GPIO10_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO10_EDGE_LOW : 1;       /*!< GPIO10_EDGE_LOW                                                           */
      __IOM uint32_t GPIO10_EDGE_HIGH : 1;      /*!< GPIO10_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO11_LEVEL_LOW : 1;      /*!< GPIO11_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< GPIO11_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO11_EDGE_LOW : 1;       /*!< GPIO11_EDGE_LOW                                                           */
      __IOM uint32_t GPIO11_EDGE_HIGH : 1;      /*!< GPIO11_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO12_LEVEL_LOW : 1;      /*!< GPIO12_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< GPIO12_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO12_EDGE_LOW : 1;       /*!< GPIO12_EDGE_LOW                                                           */
      __IOM uint32_t GPIO12_EDGE_HIGH : 1;      /*!< GPIO12_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO13_LEVEL_LOW : 1;      /*!< GPIO13_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< GPIO13_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO13_EDGE_LOW : 1;       /*!< GPIO13_EDGE_LOW                                                           */
      __IOM uint32_t GPIO13_EDGE_HIGH : 1;      /*!< GPIO13_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO14_LEVEL_LOW : 1;      /*!< GPIO14_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< GPIO14_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO14_EDGE_LOW : 1;       /*!< GPIO14_EDGE_LOW                                                           */
      __IOM uint32_t GPIO14_EDGE_HIGH : 1;      /*!< GPIO14_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO15_LEVEL_LOW : 1;      /*!< GPIO15_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< GPIO15_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO15_EDGE_LOW : 1;       /*!< GPIO15_EDGE_LOW                                                           */
      __IOM uint32_t GPIO15_EDGE_HIGH : 1;      /*!< GPIO15_EDGE_HIGH                                                          */
    } bit;
  } DORMANT_WAKE_INTF1;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force for dormant_wake                                          */
    
    struct {
      __IOM uint32_t GPIO16_LEVEL_LOW : 1;      /*!< GPIO16_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< GPIO16_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO16_EDGE_LOW : 1;       /*!< GPIO16_EDGE_LOW                                                           */
      __IOM uint32_t GPIO16_EDGE_HIGH : 1;      /*!< GPIO16_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO17_LEVEL_LOW : 1;      /*!< GPIO17_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< GPIO17_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO17_EDGE_LOW : 1;       /*!< GPIO17_EDGE_LOW                                                           */
      __IOM uint32_t GPIO17_EDGE_HIGH : 1;      /*!< GPIO17_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO18_LEVEL_LOW : 1;      /*!< GPIO18_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< GPIO18_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO18_EDGE_LOW : 1;       /*!< GPIO18_EDGE_LOW                                                           */
      __IOM uint32_t GPIO18_EDGE_HIGH : 1;      /*!< GPIO18_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO19_LEVEL_LOW : 1;      /*!< GPIO19_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< GPIO19_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO19_EDGE_LOW : 1;       /*!< GPIO19_EDGE_LOW                                                           */
      __IOM uint32_t GPIO19_EDGE_HIGH : 1;      /*!< GPIO19_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO20_LEVEL_LOW : 1;      /*!< GPIO20_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< GPIO20_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO20_EDGE_LOW : 1;       /*!< GPIO20_EDGE_LOW                                                           */
      __IOM uint32_t GPIO20_EDGE_HIGH : 1;      /*!< GPIO20_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO21_LEVEL_LOW : 1;      /*!< GPIO21_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< GPIO21_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO21_EDGE_LOW : 1;       /*!< GPIO21_EDGE_LOW                                                           */
      __IOM uint32_t GPIO21_EDGE_HIGH : 1;      /*!< GPIO21_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO22_LEVEL_LOW : 1;      /*!< GPIO22_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< GPIO22_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO22_EDGE_LOW : 1;       /*!< GPIO22_EDGE_LOW                                                           */
      __IOM uint32_t GPIO22_EDGE_HIGH : 1;      /*!< GPIO22_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO23_LEVEL_LOW : 1;      /*!< GPIO23_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< GPIO23_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO23_EDGE_LOW : 1;       /*!< GPIO23_EDGE_LOW                                                           */
      __IOM uint32_t GPIO23_EDGE_HIGH : 1;      /*!< GPIO23_EDGE_HIGH                                                          */
    } bit;
  } DORMANT_WAKE_INTF2;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force for dormant_wake                                          */
    
    struct {
      __IOM uint32_t GPIO24_LEVEL_LOW : 1;      /*!< GPIO24_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< GPIO24_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO24_EDGE_LOW : 1;       /*!< GPIO24_EDGE_LOW                                                           */
      __IOM uint32_t GPIO24_EDGE_HIGH : 1;      /*!< GPIO24_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO25_LEVEL_LOW : 1;      /*!< GPIO25_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< GPIO25_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO25_EDGE_LOW : 1;       /*!< GPIO25_EDGE_LOW                                                           */
      __IOM uint32_t GPIO25_EDGE_HIGH : 1;      /*!< GPIO25_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO26_LEVEL_LOW : 1;      /*!< GPIO26_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< GPIO26_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO26_EDGE_LOW : 1;       /*!< GPIO26_EDGE_LOW                                                           */
      __IOM uint32_t GPIO26_EDGE_HIGH : 1;      /*!< GPIO26_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO27_LEVEL_LOW : 1;      /*!< GPIO27_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< GPIO27_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO27_EDGE_LOW : 1;       /*!< GPIO27_EDGE_LOW                                                           */
      __IOM uint32_t GPIO27_EDGE_HIGH : 1;      /*!< GPIO27_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO28_LEVEL_LOW : 1;      /*!< GPIO28_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< GPIO28_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO28_EDGE_LOW : 1;       /*!< GPIO28_EDGE_LOW                                                           */
      __IOM uint32_t GPIO28_EDGE_HIGH : 1;      /*!< GPIO28_EDGE_HIGH                                                          */
      __IOM uint32_t GPIO29_LEVEL_LOW : 1;      /*!< GPIO29_LEVEL_LOW                                                          */
      __IOM uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< GPIO29_LEVEL_HIGH                                                         */
      __IOM uint32_t GPIO29_EDGE_LOW : 1;       /*!< GPIO29_EDGE_LOW                                                           */
      __IOM uint32_t GPIO29_EDGE_HIGH : 1;      /*!< GPIO29_EDGE_HIGH                                                          */
            uint32_t            : 8;
    } bit;
  } DORMANT_WAKE_INTF3;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing for dormant_wake                 */
    
    struct {
      __IM  uint32_t GPIO0_LEVEL_LOW : 1;       /*!< GPIO0_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< GPIO0_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO0_EDGE_LOW : 1;        /*!< GPIO0_EDGE_LOW                                                            */
      __IM  uint32_t GPIO0_EDGE_HIGH : 1;       /*!< GPIO0_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO1_LEVEL_LOW : 1;       /*!< GPIO1_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< GPIO1_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO1_EDGE_LOW : 1;        /*!< GPIO1_EDGE_LOW                                                            */
      __IM  uint32_t GPIO1_EDGE_HIGH : 1;       /*!< GPIO1_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO2_LEVEL_LOW : 1;       /*!< GPIO2_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< GPIO2_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO2_EDGE_LOW : 1;        /*!< GPIO2_EDGE_LOW                                                            */
      __IM  uint32_t GPIO2_EDGE_HIGH : 1;       /*!< GPIO2_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO3_LEVEL_LOW : 1;       /*!< GPIO3_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< GPIO3_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO3_EDGE_LOW : 1;        /*!< GPIO3_EDGE_LOW                                                            */
      __IM  uint32_t GPIO3_EDGE_HIGH : 1;       /*!< GPIO3_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO4_LEVEL_LOW : 1;       /*!< GPIO4_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< GPIO4_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO4_EDGE_LOW : 1;        /*!< GPIO4_EDGE_LOW                                                            */
      __IM  uint32_t GPIO4_EDGE_HIGH : 1;       /*!< GPIO4_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO5_LEVEL_LOW : 1;       /*!< GPIO5_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< GPIO5_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO5_EDGE_LOW : 1;        /*!< GPIO5_EDGE_LOW                                                            */
      __IM  uint32_t GPIO5_EDGE_HIGH : 1;       /*!< GPIO5_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO6_LEVEL_LOW : 1;       /*!< GPIO6_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< GPIO6_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO6_EDGE_LOW : 1;        /*!< GPIO6_EDGE_LOW                                                            */
      __IM  uint32_t GPIO6_EDGE_HIGH : 1;       /*!< GPIO6_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO7_LEVEL_LOW : 1;       /*!< GPIO7_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< GPIO7_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO7_EDGE_LOW : 1;        /*!< GPIO7_EDGE_LOW                                                            */
      __IM  uint32_t GPIO7_EDGE_HIGH : 1;       /*!< GPIO7_EDGE_HIGH                                                           */
    } bit;
  } DORMANT_WAKE_INTS0;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing for dormant_wake                 */
    
    struct {
      __IM  uint32_t GPIO8_LEVEL_LOW : 1;       /*!< GPIO8_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< GPIO8_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO8_EDGE_LOW : 1;        /*!< GPIO8_EDGE_LOW                                                            */
      __IM  uint32_t GPIO8_EDGE_HIGH : 1;       /*!< GPIO8_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO9_LEVEL_LOW : 1;       /*!< GPIO9_LEVEL_LOW                                                           */
      __IM  uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< GPIO9_LEVEL_HIGH                                                          */
      __IM  uint32_t GPIO9_EDGE_LOW : 1;        /*!< GPIO9_EDGE_LOW                                                            */
      __IM  uint32_t GPIO9_EDGE_HIGH : 1;       /*!< GPIO9_EDGE_HIGH                                                           */
      __IM  uint32_t GPIO10_LEVEL_LOW : 1;      /*!< GPIO10_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< GPIO10_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO10_EDGE_LOW : 1;       /*!< GPIO10_EDGE_LOW                                                           */
      __IM  uint32_t GPIO10_EDGE_HIGH : 1;      /*!< GPIO10_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO11_LEVEL_LOW : 1;      /*!< GPIO11_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< GPIO11_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO11_EDGE_LOW : 1;       /*!< GPIO11_EDGE_LOW                                                           */
      __IM  uint32_t GPIO11_EDGE_HIGH : 1;      /*!< GPIO11_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO12_LEVEL_LOW : 1;      /*!< GPIO12_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< GPIO12_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO12_EDGE_LOW : 1;       /*!< GPIO12_EDGE_LOW                                                           */
      __IM  uint32_t GPIO12_EDGE_HIGH : 1;      /*!< GPIO12_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO13_LEVEL_LOW : 1;      /*!< GPIO13_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< GPIO13_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO13_EDGE_LOW : 1;       /*!< GPIO13_EDGE_LOW                                                           */
      __IM  uint32_t GPIO13_EDGE_HIGH : 1;      /*!< GPIO13_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO14_LEVEL_LOW : 1;      /*!< GPIO14_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< GPIO14_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO14_EDGE_LOW : 1;       /*!< GPIO14_EDGE_LOW                                                           */
      __IM  uint32_t GPIO14_EDGE_HIGH : 1;      /*!< GPIO14_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO15_LEVEL_LOW : 1;      /*!< GPIO15_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< GPIO15_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO15_EDGE_LOW : 1;       /*!< GPIO15_EDGE_LOW                                                           */
      __IM  uint32_t GPIO15_EDGE_HIGH : 1;      /*!< GPIO15_EDGE_HIGH                                                          */
    } bit;
  } DORMANT_WAKE_INTS1;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing for dormant_wake                 */
    
    struct {
      __IM  uint32_t GPIO16_LEVEL_LOW : 1;      /*!< GPIO16_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< GPIO16_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO16_EDGE_LOW : 1;       /*!< GPIO16_EDGE_LOW                                                           */
      __IM  uint32_t GPIO16_EDGE_HIGH : 1;      /*!< GPIO16_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO17_LEVEL_LOW : 1;      /*!< GPIO17_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< GPIO17_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO17_EDGE_LOW : 1;       /*!< GPIO17_EDGE_LOW                                                           */
      __IM  uint32_t GPIO17_EDGE_HIGH : 1;      /*!< GPIO17_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO18_LEVEL_LOW : 1;      /*!< GPIO18_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< GPIO18_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO18_EDGE_LOW : 1;       /*!< GPIO18_EDGE_LOW                                                           */
      __IM  uint32_t GPIO18_EDGE_HIGH : 1;      /*!< GPIO18_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO19_LEVEL_LOW : 1;      /*!< GPIO19_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< GPIO19_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO19_EDGE_LOW : 1;       /*!< GPIO19_EDGE_LOW                                                           */
      __IM  uint32_t GPIO19_EDGE_HIGH : 1;      /*!< GPIO19_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO20_LEVEL_LOW : 1;      /*!< GPIO20_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< GPIO20_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO20_EDGE_LOW : 1;       /*!< GPIO20_EDGE_LOW                                                           */
      __IM  uint32_t GPIO20_EDGE_HIGH : 1;      /*!< GPIO20_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO21_LEVEL_LOW : 1;      /*!< GPIO21_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< GPIO21_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO21_EDGE_LOW : 1;       /*!< GPIO21_EDGE_LOW                                                           */
      __IM  uint32_t GPIO21_EDGE_HIGH : 1;      /*!< GPIO21_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO22_LEVEL_LOW : 1;      /*!< GPIO22_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< GPIO22_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO22_EDGE_LOW : 1;       /*!< GPIO22_EDGE_LOW                                                           */
      __IM  uint32_t GPIO22_EDGE_HIGH : 1;      /*!< GPIO22_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO23_LEVEL_LOW : 1;      /*!< GPIO23_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< GPIO23_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO23_EDGE_LOW : 1;       /*!< GPIO23_EDGE_LOW                                                           */
      __IM  uint32_t GPIO23_EDGE_HIGH : 1;      /*!< GPIO23_EDGE_HIGH                                                          */
    } bit;
  } DORMANT_WAKE_INTS2;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing for dormant_wake                 */
    
    struct {
      __IM  uint32_t GPIO24_LEVEL_LOW : 1;      /*!< GPIO24_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< GPIO24_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO24_EDGE_LOW : 1;       /*!< GPIO24_EDGE_LOW                                                           */
      __IM  uint32_t GPIO24_EDGE_HIGH : 1;      /*!< GPIO24_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO25_LEVEL_LOW : 1;      /*!< GPIO25_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< GPIO25_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO25_EDGE_LOW : 1;       /*!< GPIO25_EDGE_LOW                                                           */
      __IM  uint32_t GPIO25_EDGE_HIGH : 1;      /*!< GPIO25_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO26_LEVEL_LOW : 1;      /*!< GPIO26_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< GPIO26_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO26_EDGE_LOW : 1;       /*!< GPIO26_EDGE_LOW                                                           */
      __IM  uint32_t GPIO26_EDGE_HIGH : 1;      /*!< GPIO26_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO27_LEVEL_LOW : 1;      /*!< GPIO27_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< GPIO27_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO27_EDGE_LOW : 1;       /*!< GPIO27_EDGE_LOW                                                           */
      __IM  uint32_t GPIO27_EDGE_HIGH : 1;      /*!< GPIO27_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO28_LEVEL_LOW : 1;      /*!< GPIO28_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< GPIO28_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO28_EDGE_LOW : 1;       /*!< GPIO28_EDGE_LOW                                                           */
      __IM  uint32_t GPIO28_EDGE_HIGH : 1;      /*!< GPIO28_EDGE_HIGH                                                          */
      __IM  uint32_t GPIO29_LEVEL_LOW : 1;      /*!< GPIO29_LEVEL_LOW                                                          */
      __IM  uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< GPIO29_LEVEL_HIGH                                                         */
      __IM  uint32_t GPIO29_EDGE_LOW : 1;       /*!< GPIO29_EDGE_LOW                                                           */
      __IM  uint32_t GPIO29_EDGE_HIGH : 1;      /*!< GPIO29_EDGE_HIGH                                                          */
            uint32_t            : 8;
    } bit;
  } DORMANT_WAKE_INTS3;
} IO_BANK0_Type;                                /*!< Size = 400 (0x190)                                                        */



/* =========================================================================================================================== */
/* ================                                          SYSINFO                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief SYSINFO (SYSINFO)
  */

typedef struct {                                /*!< SYSINFO Structure                                                         */
  
  union {
    __IOM uint32_t reg;                         /*!< JEDEC JEP-106 compliant chip identifier.                                  */
    
    struct {
      __IM  uint32_t MANUFACTURER : 12;         /*!< MANUFACTURER                                                              */
      __IM  uint32_t PART       : 16;           /*!< PART                                                                      */
      __IM  uint32_t REVISION   : 4;            /*!< REVISION                                                                  */
    } bit;
  } CHIP_ID;
  
  union {
    __IOM uint32_t reg;                         /*!< Platform register. Allows software to know what environment
                                                     it is running in.                                                         */
    
    struct {
      __IM  uint32_t FPGA       : 1;            /*!< FPGA                                                                      */
      __IM  uint32_t ASIC       : 1;            /*!< ASIC                                                                      */
            uint32_t            : 30;
    } bit;
  } PLATFORM;
  __IM  uint32_t  RESERVED[2];
  
  union {
    __IOM uint32_t reg;                         /*!< Git hash of the chip source. Used to identify chip version.               */
    
    struct {
      __IM  uint32_t GITREF_RP2040 : 32;        /*!< GITREF_RP2040                                                             */
    } bit;
  } GITREF_RP2040;
} SYSINFO_Type;                                 /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                            PPB                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief PPB (PPB)
  */

typedef struct {                                /*!< PPB Structure                                                             */
  __IM  uint32_t  RESERVED[14340];
  
  union {
    __IOM uint32_t reg;                         /*!< Use the SysTick Control and Status Register to enable the SysTick
                                                     features.                                                                 */
    
    struct {
      __IOM uint32_t ENABLE     : 1;            /*!< Enable SysTick counter: 0 = Counter disabled. 1 = Counter enabled.        */
      __IOM uint32_t TICKINT    : 1;            /*!< Enables SysTick exception request: 0 = Counting down to zero
                                                     does not assert the SysTick exception request. 1 = Counting
                                                     down to zero to asserts the SysTick exception request.                    */
      __IOM uint32_t CLKSOURCE  : 1;            /*!< SysTick clock source. Always reads as one if SYST_CALIB reports
                                                     NOREF. Selects the SysTick timer clock source: 0 = External
                                                     reference clock. 1 = Processor clock.                                     */
            uint32_t            : 13;
      __IM  uint32_t COUNTFLAG  : 1;            /*!< Returns 1 if timer counted to 0 since last time this was read.
                                                     Clears on read by application or debugger.                                */
            uint32_t            : 15;
    } bit;
  } SYST_CSR;
  
  union {
    __IOM uint32_t reg;                         /*!< Use the SysTick Reload Value Register to specify the start value
                                                     to load into the current value register when the counter
                                                     reaches 0. It can be any value between 0 and 0x00FFFFFF.
                                                     A start value of 0 is possible, but has no effect because
                                                     the SysTick interrupt and COUNTFLAG are activated when
                                                     counting from 1 to 0. The reset value of this register
                                                     is UNKNOWN. To generate a multi-shot timer with a period
                                                     of N processor clock cycles, use a RELOAD value of N-1.
                                                     For example, if the SysTick interrupt is required every
                                                     100 clock pulses, set RELOAD to 99.                                       */
    
    struct {
      __IOM uint32_t RELOAD     : 24;           /*!< Value to load into the SysTick Current Value Register when the
                                                     counter reaches 0.                                                        */
            uint32_t            : 8;
    } bit;
  } SYST_RVR;
  
  union {
    __IOM uint32_t reg;                         /*!< Use the SysTick Current Value Register to find the current value
                                                     in the register. The reset value of this register is UNKNOWN.             */
    
    struct {
      __IOM uint32_t CURRENT    : 24;           /*!< Reads return the current value of the SysTick counter. This
                                                     register is write-clear. Writing to it with any value clears
                                                     the register to 0. Clearing this register also clears the
                                                     COUNTFLAG bit of the SysTick Control and Status Register.                 */
            uint32_t            : 8;
    } bit;
  } SYST_CVR;
  
  union {
    __IOM uint32_t reg;                         /*!< Use the SysTick Calibration Value Register to enable software
                                                     to scale to any required speed using divide and multiply.                 */
    
    struct {
      __IM  uint32_t TENMS      : 24;           /*!< An optional Reload value to be used for 10ms (100Hz) timing,
                                                     subject to system clock skew errors. If the value reads
                                                     as 0, the calibration value is not known.                                 */
            uint32_t            : 6;
      __IM  uint32_t SKEW       : 1;            /*!< If reads as 1, the calibration value for 10ms is inexact (due
                                                     to clock frequency).                                                      */
      __IM  uint32_t NOREF      : 1;            /*!< If reads as 1, the Reference clock is not provided - the CLKSOURCE
                                                     bit of the SysTick Control and Status register will be
                                                     forced to 1 and cannot be cleared to 0.                                   */
    } bit;
  } SYST_CALIB;
  __IM  uint32_t  RESERVED1[56];
  
  union {
    __IOM uint32_t reg;                         /*!< Use the Interrupt Set-Enable Register to enable interrupts and
                                                     determine which interrupts are currently enabled. If a
                                                     pending interrupt is enabled, the NVIC activates the interrupt
                                                     based on its priority. If an interrupt is not enabled,
                                                     asserting its interrupt signal changes the interrupt state
                                                     to pending, but the NVIC never activates the interrupt,
                                                     regardless of its priority.                                               */
    
    struct {
      __IOM uint32_t SETENA     : 32;           /*!< Interrupt set-enable bits. Write: 0 = No effect. 1 = Enable
                                                     interrupt. Read: 0 = Interrupt disabled. 1 = Interrupt
                                                     enabled.                                                                  */
    } bit;
  } NVIC_ISER;
  __IM  uint32_t  RESERVED2[31];
  
  union {
    __IOM uint32_t reg;                         /*!< Use the Interrupt Clear-Enable Registers to disable interrupts
                                                     and determine which interrupts are currently enabled.                     */
    
    struct {
      __IOM uint32_t CLRENA     : 32;           /*!< Interrupt clear-enable bits. Write: 0 = No effect. 1 = Disable
                                                     interrupt. Read: 0 = Interrupt disabled. 1 = Interrupt
                                                     enabled.                                                                  */
    } bit;
  } NVIC_ICER;
  __IM  uint32_t  RESERVED3[31];
  
  union {
    __IOM uint32_t reg;                         /*!< The NVIC_ISPR forces interrupts into the pending state, and
                                                     shows which interrupts are pending.                                       */
    
    struct {
      __IOM uint32_t SETPEND    : 32;           /*!< Interrupt set-pending bits. Write: 0 = No effect. 1 = Changes
                                                     interrupt state to pending. Read: 0 = Interrupt is not
                                                     pending. 1 = Interrupt is pending. Note: Writing 1 to the
                                                     NVIC_ISPR bit corresponding to: An interrupt that is pending
                                                     has no effect. A disabled interrupt sets the state of that
                                                     interrupt to pending.                                                     */
    } bit;
  } NVIC_ISPR;
  __IM  uint32_t  RESERVED4[31];
  
  union {
    __IOM uint32_t reg;                         /*!< Use the Interrupt Clear-Pending Register to clear pending interrupts
                                                     and determine which interrupts are currently pending.                     */
    
    struct {
      __IOM uint32_t CLRPEND    : 32;           /*!< Interrupt clear-pending bits. Write: 0 = No effect. 1 = Removes
                                                     pending state and interrupt. Read: 0 = Interrupt is not
                                                     pending. 1 = Interrupt is pending.                                        */
    } bit;
  } NVIC_ICPR;
  __IM  uint32_t  RESERVED5[95];
  
  union {
    __IOM uint32_t reg;                         /*!< Use the Interrupt Priority Registers to assign a priority from
                                                     0 to 3 to each of the available interrupts. 0 is the highest
                                                     priority, and 3 is the lowest. Note: Writing 1 to an NVIC_ICPR
                                                     bit does not affect the active state of the corresponding
                                                     interrupt. These registers are only word-accessible                       */
    
    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_0       : 2;            /*!< Priority of interrupt 0                                                   */
            uint32_t            : 6;
      __IOM uint32_t IP_1       : 2;            /*!< Priority of interrupt 1                                                   */
            uint32_t            : 6;
      __IOM uint32_t IP_2       : 2;            /*!< Priority of interrupt 2                                                   */
            uint32_t            : 6;
      __IOM uint32_t IP_3       : 2;            /*!< Priority of interrupt 3                                                   */
    } bit;
  } NVIC_IPR0;
  
  union {
    __IOM uint32_t reg;                         /*!< Use the Interrupt Priority Registers to assign a priority from
                                                     0 to 3 to each of the available interrupts. 0 is the highest
                                                     priority, and 3 is the lowest.                                            */
    
    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_4       : 2;            /*!< Priority of interrupt 4                                                   */
            uint32_t            : 6;
      __IOM uint32_t IP_5       : 2;            /*!< Priority of interrupt 5                                                   */
            uint32_t            : 6;
      __IOM uint32_t IP_6       : 2;            /*!< Priority of interrupt 6                                                   */
            uint32_t            : 6;
      __IOM uint32_t IP_7       : 2;            /*!< Priority of interrupt 7                                                   */
    } bit;
  } NVIC_IPR1;
  
  union {
    __IOM uint32_t reg;                         /*!< Use the Interrupt Priority Registers to assign a priority from
                                                     0 to 3 to each of the available interrupts. 0 is the highest
                                                     priority, and 3 is the lowest.                                            */
    
    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_8       : 2;            /*!< Priority of interrupt 8                                                   */
            uint32_t            : 6;
      __IOM uint32_t IP_9       : 2;            /*!< Priority of interrupt 9                                                   */
            uint32_t            : 6;
      __IOM uint32_t IP_10      : 2;            /*!< Priority of interrupt 10                                                  */
            uint32_t            : 6;
      __IOM uint32_t IP_11      : 2;            /*!< Priority of interrupt 11                                                  */
    } bit;
  } NVIC_IPR2;
  
  union {
    __IOM uint32_t reg;                         /*!< Use the Interrupt Priority Registers to assign a priority from
                                                     0 to 3 to each of the available interrupts. 0 is the highest
                                                     priority, and 3 is the lowest.                                            */
    
    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_12      : 2;            /*!< Priority of interrupt 12                                                  */
            uint32_t            : 6;
      __IOM uint32_t IP_13      : 2;            /*!< Priority of interrupt 13                                                  */
            uint32_t            : 6;
      __IOM uint32_t IP_14      : 2;            /*!< Priority of interrupt 14                                                  */
            uint32_t            : 6;
      __IOM uint32_t IP_15      : 2;            /*!< Priority of interrupt 15                                                  */
    } bit;
  } NVIC_IPR3;
  
  union {
    __IOM uint32_t reg;                         /*!< Use the Interrupt Priority Registers to assign a priority from
                                                     0 to 3 to each of the available interrupts. 0 is the highest
                                                     priority, and 3 is the lowest.                                            */
    
    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_16      : 2;            /*!< Priority of interrupt 16                                                  */
            uint32_t            : 6;
      __IOM uint32_t IP_17      : 2;            /*!< Priority of interrupt 17                                                  */
            uint32_t            : 6;
      __IOM uint32_t IP_18      : 2;            /*!< Priority of interrupt 18                                                  */
            uint32_t            : 6;
      __IOM uint32_t IP_19      : 2;            /*!< Priority of interrupt 19                                                  */
    } bit;
  } NVIC_IPR4;
  
  union {
    __IOM uint32_t reg;                         /*!< Use the Interrupt Priority Registers to assign a priority from
                                                     0 to 3 to each of the available interrupts. 0 is the highest
                                                     priority, and 3 is the lowest.                                            */
    
    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_20      : 2;            /*!< Priority of interrupt 20                                                  */
            uint32_t            : 6;
      __IOM uint32_t IP_21      : 2;            /*!< Priority of interrupt 21                                                  */
            uint32_t            : 6;
      __IOM uint32_t IP_22      : 2;            /*!< Priority of interrupt 22                                                  */
            uint32_t            : 6;
      __IOM uint32_t IP_23      : 2;            /*!< Priority of interrupt 23                                                  */
    } bit;
  } NVIC_IPR5;
  
  union {
    __IOM uint32_t reg;                         /*!< Use the Interrupt Priority Registers to assign a priority from
                                                     0 to 3 to each of the available interrupts. 0 is the highest
                                                     priority, and 3 is the lowest.                                            */
    
    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_24      : 2;            /*!< Priority of interrupt 24                                                  */
            uint32_t            : 6;
      __IOM uint32_t IP_25      : 2;            /*!< Priority of interrupt 25                                                  */
            uint32_t            : 6;
      __IOM uint32_t IP_26      : 2;            /*!< Priority of interrupt 26                                                  */
            uint32_t            : 6;
      __IOM uint32_t IP_27      : 2;            /*!< Priority of interrupt 27                                                  */
    } bit;
  } NVIC_IPR6;
  
  union {
    __IOM uint32_t reg;                         /*!< Use the Interrupt Priority Registers to assign a priority from
                                                     0 to 3 to each of the available interrupts. 0 is the highest
                                                     priority, and 3 is the lowest.                                            */
    
    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_28      : 2;            /*!< Priority of interrupt 28                                                  */
            uint32_t            : 6;
      __IOM uint32_t IP_29      : 2;            /*!< Priority of interrupt 29                                                  */
            uint32_t            : 6;
      __IOM uint32_t IP_30      : 2;            /*!< Priority of interrupt 30                                                  */
            uint32_t            : 6;
      __IOM uint32_t IP_31      : 2;            /*!< Priority of interrupt 31                                                  */
    } bit;
  } NVIC_IPR7;
  __IM  uint32_t  RESERVED6[568];
  
  union {
    __IOM uint32_t reg;                         /*!< Read the CPU ID Base Register to determine: the ID number of
                                                     the processor core, the version number of the processor
                                                     core, the implementation details of the processor core.                   */
    
    struct {
      __IM  uint32_t REVISION   : 4;            /*!< Minor revision number m in the rnpm revision status: 0x1 = Patch
                                                     1.                                                                        */
      __IM  uint32_t PARTNO     : 12;           /*!< Number of processor within family: 0xC60 = Cortex-M0+                     */
      __IM  uint32_t ARCHITECTURE : 4;          /*!< Constant that defines the architecture of the processor: 0xC
                                                     = ARMv6-M architecture.                                                   */
      __IM  uint32_t VARIANT    : 4;            /*!< Major revision number n in the rnpm revision status: 0x0 = Revision
                                                     0.                                                                        */
      __IM  uint32_t IMPLEMENTER : 8;           /*!< Implementor code: 0x41 = ARM                                              */
    } bit;
  } CPUID;
  
  union {
    __IOM uint32_t reg;                         /*!< Use the Interrupt Control State Register to set a pending Non-Maskable
                                                     Interrupt (NMI), set or clear a pending PendSV, set or
                                                     clear a pending SysTick, check for pending exceptions,
                                                     check the vector number of the highest priority pended
                                                     exception, check the vector number of the active exception.               */
    
    struct {
      __IM  uint32_t VECTACTIVE : 9;            /*!< Active exception number field. Reset clears the VECTACTIVE field.         */
            uint32_t            : 3;
      __IM  uint32_t VECTPENDING : 9;           /*!< Indicates the exception number for the highest priority pending
                                                     exception: 0 = no pending exceptions. Non zero = The pending
                                                     state includes the effect of memory-mapped enable and mask
                                                     registers. It does not include the PRIMASK special-purpose
                                                     register qualifier.                                                       */
            uint32_t            : 1;
      __IM  uint32_t ISRPENDING : 1;            /*!< External interrupt pending flag                                           */
      __IM  uint32_t ISRPREEMPT : 1;            /*!< The system can only access this bit when the core is halted.
                                                     It indicates that a pending interrupt is to be taken in
                                                     the next running cycle. If C_MASKINTS is clear in the Debug
                                                     Halting Control and Status Register, the interrupt is serviced.           */
            uint32_t            : 1;
      __IOM uint32_t PENDSTCLR  : 1;            /*!< SysTick exception clear-pending bit. Write: 0 = No effect. 1
                                                     = Removes the pending state from the SysTick exception.
                                                     This bit is WO. On a register read its value is Unknown.                  */
      __IOM uint32_t PENDSTSET  : 1;            /*!< SysTick exception set-pending bit. Write: 0 = No effect. 1 =
                                                     Changes SysTick exception state to pending. Read: 0 = SysTick
                                                     exception is not pending. 1 = SysTick exception is pending.               */
      __IOM uint32_t PENDSVCLR  : 1;            /*!< PendSV clear-pending bit. Write: 0 = No effect. 1 = Removes
                                                     the pending state from the PendSV exception.                              */
      __IOM uint32_t PENDSVSET  : 1;            /*!< PendSV set-pending bit. Write: 0 = No effect. 1 = Changes PendSV
                                                     exception state to pending. Read: 0 = PendSV exception
                                                     is not pending. 1 = PendSV exception is pending. Writing
                                                     1 to this bit is the only way to set the PendSV exception
                                                     state to pending.                                                         */
            uint32_t            : 2;
      __IOM uint32_t NMIPENDSET : 1;            /*!< Setting this bit will activate an NMI. Since NMI is the highest
                                                     priority exception, it will activate as soon as it is registered.
                                                     NMI set-pending bit. Write: 0 = No effect. 1 = Changes
                                                     NMI exception state to pending. Read: 0 = NMI exception
                                                     is not pending. 1 = NMI exception is pending. Because NMI
                                                     is the highest-priority exception, normally the processor
                                                     enters the NMI exception handler as soon as it detects
                                                     a write of 1 to this bit. Entering the handler then clears
                                                     this bit to 0. This means a read of this bit by the NMI
                                                     exception handler returns 1 only if the NMI signal is reasserted
                                                     while the processor is executing that handler.                            */
    } bit;
  } ICSR;
  
  union {
    __IOM uint32_t reg;                         /*!< The VTOR holds the vector table offset address.                           */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t TBLOFF     : 24;           /*!< Bits [31:8] of the indicate the vector table offset address.              */
    } bit;
  } VTOR;
  
  union {
    __IOM uint32_t reg;                         /*!< Use the Application Interrupt and Reset Control Register to:
                                                     determine data endianness, clear all active state information
                                                     from debug halt mode, request a system reset.                             */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t VECTCLRACTIVE : 1;         /*!< Clears all active state information for fixed and configurable
                                                     exceptions. This bit: is self-clearing, can only be set
                                                     by the DAP when the core is halted. When set: clears all
                                                     active exception status of the processor, forces a return
                                                     to Thread mode, forces an IPSR of 0. A debugger must re-initialize
                                                     the stack.                                                                */
      __IOM uint32_t SYSRESETREQ : 1;           /*!< Writing 1 to this bit causes the SYSRESETREQ signal to the outer
                                                     system to be asserted to request a reset. The intention
                                                     is to force a large system reset of all major components
                                                     except for debug. The C_HALT bit in the DHCSR is cleared
                                                     as a result of the system reset requested. The debugger
                                                     does not lose contact with the device.                                    */
            uint32_t            : 12;
      __IM  uint32_t ENDIANESS  : 1;            /*!< Data endianness implemented: 0 = Little-endian.                           */
      __IOM uint32_t VECTKEY    : 16;           /*!< Register key: Reads as Unknown On writes, write 0x05FA to VECTKEY,
                                                     otherwise the write is ignored.                                           */
    } bit;
  } AIRCR;
  
  union {
    __IOM uint32_t reg;                         /*!< System Control Register. Use the System Control Register for
                                                     power-management functions: signal to the system when the
                                                     processor can enter a low power state, control how the
                                                     processor enters and exits low power states.                              */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t SLEEPONEXIT : 1;           /*!< Indicates sleep-on-exit when returning from Handler mode to
                                                     Thread mode: 0 = Do not sleep when returning to Thread
                                                     mode. 1 = Enter sleep, or deep sleep, on return from an
                                                     ISR to Thread mode. Setting this bit to 1 enables an interrupt
                                                     driven application to avoid returning to an empty main
                                                     application.                                                              */
      __IOM uint32_t SLEEPDEEP  : 1;            /*!< Controls whether the processor uses sleep or deep sleep as its
                                                     low power mode: 0 = Sleep. 1 = Deep sleep.                                */
            uint32_t            : 1;
      __IOM uint32_t SEVONPEND  : 1;            /*!< Send Event on Pending bit: 0 = Only enabled interrupts or events
                                                     can wakeup the processor, disabled interrupts are excluded.
                                                     1 = Enabled events and all interrupts, including disabled
                                                     interrupts, can wakeup the processor. When an event or
                                                     interrupt becomes pending, the event signal wakes up the
                                                     processor from WFE. If the processor is not waiting for
                                                     an event, the event is registered and affects the next
                                                     WFE. The processor also wakes up on execution of an SEV
                                                     instruction or an external event.                                         */
            uint32_t            : 27;
    } bit;
  } SCR;
  
  union {
    __IOM uint32_t reg;                         /*!< The Configuration and Control Register permanently enables stack
                                                     alignment and causes unaligned accesses to result in a
                                                     Hard Fault.                                                               */
    
    struct {
            uint32_t            : 3;
      __IM  uint32_t UNALIGN_TRP : 1;           /*!< Always reads as one, indicates that all unaligned accesses generate
                                                     a HardFault.                                                              */
            uint32_t            : 5;
      __IM  uint32_t STKALIGN   : 1;            /*!< Always reads as one, indicates 8-byte stack alignment on exception
                                                     entry. On exception entry, the processor uses bit[9] of
                                                     the stacked PSR to indicate the stack alignment. On return
                                                     from the exception it uses this stacked bit to restore
                                                     the correct stack alignment.                                              */
            uint32_t            : 22;
    } bit;
  } CCR;
  __IM  uint32_t  RESERVED7;
  
  union {
    __IOM uint32_t reg;                         /*!< System handlers are a special class of exception handler that
                                                     can have their priority set to any of the priority levels.
                                                     Use the System Handler Priority Register 2 to set the priority
                                                     of SVCall.                                                                */
    
    struct {
            uint32_t            : 30;
      __IOM uint32_t PRI_11     : 2;            /*!< Priority of system handler 11, SVCall                                     */
    } bit;
  } SHPR2;
  
  union {
    __IOM uint32_t reg;                         /*!< System handlers are a special class of exception handler that
                                                     can have their priority set to any of the priority levels.
                                                     Use the System Handler Priority Register 3 to set the priority
                                                     of PendSV and SysTick.                                                    */
    
    struct {
            uint32_t            : 22;
      __IOM uint32_t PRI_14     : 2;            /*!< Priority of system handler 14, PendSV                                     */
            uint32_t            : 6;
      __IOM uint32_t PRI_15     : 2;            /*!< Priority of system handler 15, SysTick                                    */
    } bit;
  } SHPR3;
  
  union {
    __IOM uint32_t reg;                         /*!< Use the System Handler Control and State Register to determine
                                                     or clear the pending status of SVCall.                                    */
    
    struct {
            uint32_t            : 15;
      __IOM uint32_t SVCALLPENDED : 1;          /*!< Reads as 1 if SVCall is Pending. Write 1 to set pending SVCall,
                                                     write 0 to clear pending SVCall.                                          */
            uint32_t            : 16;
    } bit;
  } SHCSR;
  __IM  uint32_t  RESERVED8[26];
  
  union {
    __IOM uint32_t reg;                         /*!< Read the MPU Type Register to determine if the processor implements
                                                     an MPU, and how many regions the MPU supports.                            */
    
    struct {
      __IM  uint32_t SEPARATE   : 1;            /*!< Indicates support for separate instruction and data address
                                                     maps. Reads as 0 as ARMv6-M only supports a unified MPU.                  */
            uint32_t            : 7;
      __IM  uint32_t DREGION    : 8;            /*!< Number of regions supported by the MPU.                                   */
      __IM  uint32_t IREGION    : 8;            /*!< Instruction region. Reads as zero as ARMv6-M only supports a
                                                     unified MPU.                                                              */
            uint32_t            : 8;
    } bit;
  } MPU_TYPE;
  
  union {
    __IOM uint32_t reg;                         /*!< Use the MPU Control Register to enable and disable the MPU,
                                                     and to control whether the default memory map is enabled
                                                     as a background region for privileged accesses, and whether
                                                     the MPU is enabled for HardFaults and NMIs.                               */
    
    struct {
      __IOM uint32_t ENABLE     : 1;            /*!< Enables the MPU. If the MPU is disabled, privileged and unprivileged
                                                     accesses use the default memory map. 0 = MPU disabled.
                                                     1 = MPU enabled.                                                          */
      __IOM uint32_t HFNMIENA   : 1;            /*!< Controls the use of the MPU for HardFaults and NMIs. Setting
                                                     this bit when ENABLE is clear results in UNPREDICTABLE
                                                     behaviour. When the MPU is enabled: 0 = MPU is disabled
                                                     during HardFault and NMI handlers, regardless of the value
                                                     of the ENABLE bit. 1 = the MPU is enabled during HardFault
                                                     and NMI handlers.                                                         */
      __IOM uint32_t PRIVDEFENA : 1;            /*!< Controls whether the default memory map is enabled as a background
                                                     region for privileged accesses. This bit is ignored when
                                                     ENABLE is clear. 0 = If the MPU is enabled, disables use
                                                     of the default memory map. Any memory access to a location
                                                     not covered by any enabled region causes a fault. 1 = If
                                                     the MPU is enabled, enables use of the default memory map
                                                     as a background region for privileged software accesses.
                                                     When enabled, the background region acts as if it is region
                                                     number -1. Any region that is defined and enabled has priority
                                                     over this default map.                                                    */
            uint32_t            : 29;
    } bit;
  } MPU_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Use the MPU Region Number Register to select the region currently
                                                     accessed by MPU_RBAR and MPU_RASR.                                        */
    
    struct {
      __IOM uint32_t REGION     : 4;            /*!< Indicates the MPU region referenced by the MPU_RBAR and MPU_RASR
                                                     registers. The MPU supports 8 memory regions, so the permitted
                                                     values of this field are 0-7.                                             */
            uint32_t            : 28;
    } bit;
  } MPU_RNR;
  
  union {
    __IOM uint32_t reg;                         /*!< Read the MPU Region Base Address Register to determine the base
                                                     address of the region identified by MPU_RNR. Write to update
                                                     the base address of said region or that of a specified
                                                     region, with whose number MPU_RNR will also be updated.                   */
    
    struct {
      __IOM uint32_t REGION     : 4;            /*!< On writes, specifies the number of the region whose base address
                                                     to update provided VALID is set written as 1. On reads,
                                                     returns bits [3:0] of MPU_RNR.                                            */
      __IOM uint32_t VALID      : 1;            /*!< On writes, indicates whether the write must update the base
                                                     address of the region identified by the REGION field, updating
                                                     the MPU_RNR to indicate this new region. Write: 0 = MPU_RNR
                                                     not changed, and the processor: Updates the base address
                                                     for the region specified in the MPU_RNR. Ignores the value
                                                     of the REGION field. 1 = The processor: Updates the value
                                                     of the MPU_RNR to the value of the REGION field. Updates
                                                     the base address for the region specified in the REGION
                                                     field. Always reads as zero.                                              */
            uint32_t            : 3;
      __IOM uint32_t ADDR       : 24;           /*!< Base address of the region.                                               */
    } bit;
  } MPU_RBAR;
  
  union {
    __IOM uint32_t reg;                         /*!< Use the MPU Region Attribute and Size Register to define the
                                                     size, access behaviour and memory type of the region identified
                                                     by MPU_RNR, and enable that region.                                       */
    
    struct {
      __IOM uint32_t ENABLE     : 1;            /*!< Enables the region.                                                       */
      __IOM uint32_t SIZE       : 5;            /*!< Indicates the region size. Region size in bytes = 2^(SIZE+1).
                                                     The minimum permitted value is 7 (b00111) = 256Bytes                      */
            uint32_t            : 2;
      __IOM uint32_t SRD        : 8;            /*!< Subregion Disable. For regions of 256 bytes or larger, each
                                                     bit of this field controls whether one of the eight equal
                                                     subregions is enabled.                                                    */
      __IOM uint32_t ATTRS      : 16;           /*!< The MPU Region Attribute field. Use to define the region attribute
                                                     control. 28 = XN: Instruction access disable bit: 0 = Instruction
                                                     fetches enabled. 1 = Instruction fetches disabled. 26:24
                                                     = AP: Access permission field 18 = S: Shareable bit 17
                                                     = C: Cacheable bit 16 = B: Bufferable bit                                 */
    } bit;
  } MPU_RASR;
} PPB_Type;                                     /*!< Size = 60836 (0xeda4)                                                     */



/* =========================================================================================================================== */
/* ================                                            SSI                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief DW_apb_ssi has the following features: 
            * APB interface  Allows for easy integration into a DesignWare Synthesizable Components for AMBA 2 implementation. 
            * APB3 and APB4 protocol support. 
            * Scalable APB data bus width  Supports APB data bus widths of 8, 16, and 32 bits. 
            * Serial-master or serial-slave operation  Enables serial communication with serial-master or serial-slave peripheral devices. 
            * Programmable Dual/Quad/Octal SPI support in Master Mode. 
            * Dual Data Rate (DDR) and Read Data Strobe (RDS) Support - Enables the DW_apb_ssi master to perform operations with the device in DDR and RDS modes when working in Dual/Quad/Octal mode of operation. 
            * Data Mask Support - Enables the DW_apb_ssi to selectively update the bytes in the device. This feature is applicable only in enhanced SPI modes. 
            * eXecute-In-Place (XIP) support - Enables the DW_apb_ssi master to behave as a memory mapped I/O and fetches the data from the device based on the APB read request. This feature is applicable only in enhanced SPI modes. 
            * DMA Controller Interface  Enables the DW_apb_ssi to interface to a DMA controller over the bus using a handshaking interface for transfer requests. 
            * Independent masking of interrupts  Master collision, transmit FIFO overflow, transmit FIFO empty, receive FIFO full, receive FIFO underflow, and receive FIFO overflow interrupts can all be masked independently. 
            * Multi-master contention detection  Informs the processor of multiple serial-master accesses on the serial bus. 
            * Bypass of meta-stability flip-flops for synchronous clocks  When the APB clock (pclk) and the DW_apb_ssi serial clock (ssi_clk) are synchronous, meta-stable flip-flops are not used when transferring control signals across these clock domains. 
            * Programmable delay on the sample time of the received serial data bit (rxd); enables programmable control of routing delays resulting in higher serial data-bit rates. 
            * Programmable features: 
            - Serial interface operation  Choice of Motorola SPI, Texas Instruments Synchronous Serial Protocol or National Semiconductor Microwire. 
            - Clock bit-rate  Dynamic control of the serial bit rate of the data transfer; used in only serial-master mode of operation. 
            - Data Item size (4 to 32 bits)  Item size of each data transfer under the control of the programmer. 
            * Configured features: 
            - FIFO depth  16 words deep. The FIFO width is fixed at 32 bits. 
            - 1 slave select output. 
            - Hardware slave-select  Dedicated hardware slave-select line. 
            - Combined interrupt line - one combined interrupt line from the DW_apb_ssi to the interrupt controller. 
            - Interrupt polarity  active high interrupt lines. 
            - Serial clock polarity  low serial-clock polarity directly after reset. 
            - Serial clock phase  capture on first edge of serial-clock directly after reset. (SSI)
  */

typedef struct {                                /*!< SSI Structure                                                             */
  
  union {
    __IOM uint32_t reg;                         /*!< Control register 0                                                        */
    
    struct {
      __IOM uint32_t DFS        : 4;            /*!< Data frame size                                                           */
      __IOM uint32_t FRF        : 2;            /*!< Frame format                                                              */
      __IOM uint32_t SCPH       : 1;            /*!< Serial clock phase                                                        */
      __IOM uint32_t SCPOL      : 1;            /*!< Serial clock polarity                                                     */
      __IOM uint32_t TMOD       : 2;            /*!< Transfer mode                                                             */
      __IOM uint32_t SLV_OE     : 1;            /*!< Slave output enable                                                       */
      __IOM uint32_t SRL        : 1;            /*!< Shift register loop (test mode)                                           */
      __IOM uint32_t CFS        : 4;            /*!< Control frame size Value of n -> n+1 clocks per frame.                    */
      __IOM uint32_t DFS_32     : 5;            /*!< Data frame size in 32b transfer mode Value of n -> n+1 clocks
                                                     per frame.                                                                */
      __IOM uint32_t SPI_FRF    : 2;            /*!< SPI frame format                                                          */
            uint32_t            : 1;
      __IOM uint32_t SSTE       : 1;            /*!< Slave select toggle enable                                                */
            uint32_t            : 7;
    } bit;
  } CTRLR0;
  
  union {
    __IOM uint32_t reg;                         /*!< Master Control register 1                                                 */
    
    struct {
      __IOM uint32_t NDF        : 16;           /*!< Number of data frames                                                     */
            uint32_t            : 16;
    } bit;
  } CTRLR1;
  
  union {
    __IOM uint32_t reg;                         /*!< SSI Enable                                                                */
    
    struct {
      __IOM uint32_t SSI_EN     : 1;            /*!< SSI enable                                                                */
            uint32_t            : 31;
    } bit;
  } SSIENR;
  
  union {
    __IOM uint32_t reg;                         /*!< Microwire Control                                                         */
    
    struct {
      __IOM uint32_t MWMOD      : 1;            /*!< Microwire transfer mode                                                   */
      __IOM uint32_t MDD        : 1;            /*!< Microwire control                                                         */
      __IOM uint32_t MHS        : 1;            /*!< Microwire handshaking                                                     */
            uint32_t            : 29;
    } bit;
  } MWCR;
  
  union {
    __IOM uint32_t reg;                         /*!< Slave enable                                                              */
    
    struct {
      __IOM uint32_t SER        : 1;            /*!< For each bit: 0 -> slave not selected 1 -> slave selected                 */
            uint32_t            : 31;
    } bit;
  } SER;
  
  union {
    __IOM uint32_t reg;                         /*!< Baud rate                                                                 */
    
    struct {
      __IOM uint32_t SCKDV      : 16;           /*!< SSI clock divider                                                         */
            uint32_t            : 16;
    } bit;
  } BAUDR;
  
  union {
    __IOM uint32_t reg;                         /*!< TX FIFO threshold level                                                   */
    
    struct {
      __IOM uint32_t TFT        : 8;            /*!< Transmit FIFO threshold                                                   */
            uint32_t            : 24;
    } bit;
  } TXFTLR;
  
  union {
    __IOM uint32_t reg;                         /*!< RX FIFO threshold level                                                   */
    
    struct {
      __IOM uint32_t RFT        : 8;            /*!< Receive FIFO threshold                                                    */
            uint32_t            : 24;
    } bit;
  } RXFTLR;
  
  union {
    __IOM uint32_t reg;                         /*!< TX FIFO level                                                             */
    
    struct {
      __IM  uint32_t TFTFL      : 8;            /*!< Transmit FIFO level                                                       */
            uint32_t            : 24;
    } bit;
  } TXFLR;
  
  union {
    __IOM uint32_t reg;                         /*!< RX FIFO level                                                             */
    
    struct {
      __IM  uint32_t RXTFL      : 8;            /*!< Receive FIFO level                                                        */
            uint32_t            : 24;
    } bit;
  } RXFLR;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register                                                           */
    
    struct {
      __IM  uint32_t BUSY       : 1;            /*!< SSI busy flag                                                             */
      __IM  uint32_t TFNF       : 1;            /*!< Transmit FIFO not full                                                    */
      __IM  uint32_t TFE        : 1;            /*!< Transmit FIFO empty                                                       */
      __IM  uint32_t RFNE       : 1;            /*!< Receive FIFO not empty                                                    */
      __IM  uint32_t RFF        : 1;            /*!< Receive FIFO full                                                         */
      __IM  uint32_t TXE        : 1;            /*!< Transmission error                                                        */
      __IM  uint32_t DCOL       : 1;            /*!< Data collision error                                                      */
            uint32_t            : 25;
    } bit;
  } SR;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt mask                                                            */
    
    struct {
      __IOM uint32_t TXEIM      : 1;            /*!< Transmit FIFO empty interrupt mask                                        */
      __IOM uint32_t TXOIM      : 1;            /*!< Transmit FIFO overflow interrupt mask                                     */
      __IOM uint32_t RXUIM      : 1;            /*!< Receive FIFO underflow interrupt mask                                     */
      __IOM uint32_t RXOIM      : 1;            /*!< Receive FIFO overflow interrupt mask                                      */
      __IOM uint32_t RXFIM      : 1;            /*!< Receive FIFO full interrupt mask                                          */
      __IOM uint32_t MSTIM      : 1;            /*!< Multi-master contention interrupt mask                                    */
            uint32_t            : 26;
    } bit;
  } IMR;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status                                                          */
    
    struct {
      __IM  uint32_t TXEIS      : 1;            /*!< Transmit FIFO empty interrupt status                                      */
      __IM  uint32_t TXOIS      : 1;            /*!< Transmit FIFO overflow interrupt status                                   */
      __IM  uint32_t RXUIS      : 1;            /*!< Receive FIFO underflow interrupt status                                   */
      __IM  uint32_t RXOIS      : 1;            /*!< Receive FIFO overflow interrupt status                                    */
      __IM  uint32_t RXFIS      : 1;            /*!< Receive FIFO full interrupt status                                        */
      __IM  uint32_t MSTIS      : 1;            /*!< Multi-master contention interrupt status                                  */
            uint32_t            : 26;
    } bit;
  } ISR;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw interrupt status                                                      */
    
    struct {
      __IM  uint32_t TXEIR      : 1;            /*!< Transmit FIFO empty raw interrupt status                                  */
      __IM  uint32_t TXOIR      : 1;            /*!< Transmit FIFO overflow raw interrupt status                               */
      __IM  uint32_t RXUIR      : 1;            /*!< Receive FIFO underflow raw interrupt status                               */
      __IM  uint32_t RXOIR      : 1;            /*!< Receive FIFO overflow raw interrupt status                                */
      __IM  uint32_t RXFIR      : 1;            /*!< Receive FIFO full raw interrupt status                                    */
      __IM  uint32_t MSTIR      : 1;            /*!< Multi-master contention raw interrupt status                              */
            uint32_t            : 26;
    } bit;
  } RISR;
  
  union {
    __IOM uint32_t reg;                         /*!< TX FIFO overflow interrupt clear                                          */
    
    struct {
      __IM  uint32_t TXOICR     : 1;            /*!< Clear-on-read transmit FIFO overflow interrupt                            */
            uint32_t            : 31;
    } bit;
  } TXOICR;
  
  union {
    __IOM uint32_t reg;                         /*!< RX FIFO overflow interrupt clear                                          */
    
    struct {
      __IM  uint32_t RXOICR     : 1;            /*!< Clear-on-read receive FIFO overflow interrupt                             */
            uint32_t            : 31;
    } bit;
  } RXOICR;
  
  union {
    __IOM uint32_t reg;                         /*!< RX FIFO underflow interrupt clear                                         */
    
    struct {
      __IM  uint32_t RXUICR     : 1;            /*!< Clear-on-read receive FIFO underflow interrupt                            */
            uint32_t            : 31;
    } bit;
  } RXUICR;
  
  union {
    __IOM uint32_t reg;                         /*!< Multi-master interrupt clear                                              */
    
    struct {
      __IM  uint32_t MSTICR     : 1;            /*!< Clear-on-read multi-master contention interrupt                           */
            uint32_t            : 31;
    } bit;
  } MSTICR;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear                                                           */
    
    struct {
      __IM  uint32_t ICR        : 1;            /*!< Clear-on-read all active interrupts                                       */
            uint32_t            : 31;
    } bit;
  } ICR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA control                                                               */
    
    struct {
      __IOM uint32_t RDMAE      : 1;            /*!< Receive DMA enable                                                        */
      __IOM uint32_t TDMAE      : 1;            /*!< Transmit DMA enable                                                       */
            uint32_t            : 30;
    } bit;
  } DMACR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA TX data level                                                         */
    
    struct {
      __IOM uint32_t DMATDL     : 8;            /*!< Transmit data watermark level                                             */
            uint32_t            : 24;
    } bit;
  } DMATDLR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA RX data level                                                         */
    
    struct {
      __IOM uint32_t DMARDL     : 8;            /*!< Receive data watermark level (DMARDLR+1)                                  */
            uint32_t            : 24;
    } bit;
  } DMARDLR;
  
  union {
    __IOM uint32_t reg;                         /*!< Identification register                                                   */
    
    struct {
      __IM  uint32_t IDCODE     : 32;           /*!< Peripheral dentification code                                             */
    } bit;
  } IDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Version ID                                                                */
    
    struct {
      __IM  uint32_t SSI_COMP_VERSION : 32;     /*!< SNPS component version (format X.YY)                                      */
    } bit;
  } SSI_VERSION_ID;
  
  union {
    __IOM uint32_t reg;                         /*!< Data Register 0 (of 36)                                                   */
    
    struct {
      __IOM uint32_t DR         : 32;           /*!< First data register of 36                                                 */
    } bit;
  } DR0;
  __IM  uint32_t  RESERVED[35];
  
  union {
    __IOM uint32_t reg;                         /*!< RX sample delay                                                           */
    
    struct {
      __IOM uint32_t RSD        : 8;            /*!< RXD sample delay (in SCLK cycles)                                         */
            uint32_t            : 24;
    } bit;
  } RX_SAMPLE_DLY;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI control                                                               */
    
    struct {
      __IOM uint32_t TRANS_TYPE : 2;            /*!< Address and instruction transfer format                                   */
      __IOM uint32_t ADDR_L     : 4;            /*!< Address length (0b-60b in 4b increments)                                  */
            uint32_t            : 2;
      __IOM uint32_t INST_L     : 2;            /*!< Instruction length (0/4/8/16b)                                            */
            uint32_t            : 1;
      __IOM uint32_t WAIT_CYCLES : 5;           /*!< Wait cycles between control frame transmit and data reception
                                                     (in SCLK cycles)                                                          */
      __IOM uint32_t SPI_DDR_EN : 1;            /*!< SPI DDR transfer enable                                                   */
      __IOM uint32_t INST_DDR_EN : 1;           /*!< Instruction DDR transfer enable                                           */
      __IOM uint32_t SPI_RXDS_EN : 1;           /*!< Read data strobe enable                                                   */
            uint32_t            : 5;
      __IOM uint32_t XIP_CMD    : 8;            /*!< SPI Command to send in XIP mode (INST_L = 8-bit) or to append
                                                     to Address (INST_L = 0-bit)                                               */
    } bit;
  } SPI_CTRLR0;
  
  union {
    __IOM uint32_t reg;                         /*!< TX drive edge                                                             */
    
    struct {
      __IOM uint32_t TDE        : 8;            /*!< TXD drive edge                                                            */
            uint32_t            : 24;
    } bit;
  } TXD_DRIVE_EDGE;
} SSI_Type;                                     /*!< Size = 252 (0xfc)                                                         */



/* =========================================================================================================================== */
/* ================                                         XIP_CTRL                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief QSPI flash execute-in-place block (XIP_CTRL)
  */

typedef struct {                                /*!< XIP_CTRL Structure                                                        */
  
  union {
    __IOM uint32_t reg;                         /*!< Cache control                                                             */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< When 1, enable the cache. When the cache is disabled, all XIP
                                                     accesses will go straight to the flash, without querying
                                                     the cache. When enabled, cacheable XIP accesses will query
                                                     the cache, and the flash will not be accessed if the tag
                                                     matches and the valid bit is set. If the cache is enabled,
                                                     cache-as-SRAM accesses have no effect on the cache data
                                                     RAM, and will produce a bus error response.                               */
      __IOM uint32_t ERR_BADWRITE : 1;          /*!< When 1, writes to any alias other than 0x0 (caching, allocating)
                                                     will produce a bus fault. When 0, these writes are silently
                                                     ignored. In either case, writes to the 0x0 alias will deallocate
                                                     on tag match, as usual.                                                   */
            uint32_t            : 1;
      __IOM uint32_t POWER_DOWN : 1;            /*!< When 1, the cache memories are powered down. They retain state,
                                                     but can not be accessed. This reduces static power dissipation.
                                                     Writing 1 to this bit forces CTRL_EN to 0, i.e. the cache
                                                     cannot be enabled when powered down. Cache-as-SRAM accesses
                                                     will produce a bus error response when the cache is powered
                                                     down.                                                                     */
            uint32_t            : 28;
    } bit;
  } CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Cache Flush control                                                       */
    
    struct {
      __OM  uint32_t FLUSH      : 1;            /*!< Write 1 to flush the cache. This clears the tag memory, but
                                                     the data memory retains its contents. (This means cache-as-SRAM
                                                     contents is not affected by flush or reset.) Reading will
                                                     hold the bus (stall the processor) until the flush completes.
                                                     Alternatively STAT can be polled until completion.                        */
            uint32_t            : 31;
    } bit;
  } FLUSH;
  
  union {
    __IOM uint32_t reg;                         /*!< Cache Status                                                              */
    
    struct {
      __IM  uint32_t FLUSH_READY : 1;           /*!< Reads as 0 while a cache flush is in progress, and 1 otherwise.
                                                     The cache is flushed whenever the XIP block is reset, and
                                                     also when requested via the FLUSH register.                               */
      __IM  uint32_t FIFO_EMPTY : 1;            /*!< When 1, indicates the XIP streaming FIFO is completely empty.             */
      __IM  uint32_t FIFO_FULL  : 1;            /*!< When 1, indicates the XIP streaming FIFO is completely full.
                                                     The streaming FIFO is 2 entries deep, so the full and empty
                                                     flag allow its level to be ascertained.                                   */
            uint32_t            : 29;
    } bit;
  } STAT;
  
  union {
    __IOM uint32_t reg;                         /*!< Cache Hit counter                                                         */
    
    struct {
      __IOM uint32_t CTR_HIT    : 32;           /*!< A 32 bit saturating counter that increments upon each cache
                                                     hit, i.e. when an XIP access is serviced directly from
                                                     cached data. Write any value to clear.                                    */
    } bit;
  } CTR_HIT;
  
  union {
    __IOM uint32_t reg;                         /*!< Cache Access counter                                                      */
    
    struct {
      __IOM uint32_t CTR_ACC    : 32;           /*!< A 32 bit saturating counter that increments upon each XIP access,
                                                     whether the cache is hit or not. This includes noncacheable
                                                     accesses. Write any value to clear.                                       */
    } bit;
  } CTR_ACC;
  
  union {
    __IOM uint32_t reg;                         /*!< FIFO stream address                                                       */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t STREAM_ADDR : 30;          /*!< The address of the next word to be streamed from flash to the
                                                     streaming FIFO. Increments automatically after each flash
                                                     access. Write the initial access address here before starting
                                                     a streaming read.                                                         */
    } bit;
  } STREAM_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< FIFO stream control                                                       */
    
    struct {
      __IOM uint32_t STREAM_CTR : 22;           /*!< Write a nonzero value to start a streaming read. This will then
                                                     progress in the background, using flash idle cycles to
                                                     transfer a linear data block from flash to the streaming
                                                     FIFO. Decrements automatically (1 at a time) as the stream
                                                     progresses, and halts on reaching 0. Write 0 to halt an
                                                     in-progress stream, and discard any in-flight read, so
                                                     that a new stream can immediately be started (after draining
                                                     the FIFO and reinitialising STREAM_ADDR)                                  */
            uint32_t            : 10;
    } bit;
  } STREAM_CTR;
  
  union {
    __IOM uint32_t reg;                         /*!< FIFO stream data                                                          */
    
    struct {
      __IM  uint32_t STREAM_FIFO : 32;          /*!< Streamed data is buffered here, for retrieval by the system
                                                     DMA. This FIFO can also be accessed via the XIP_AUX slave,
                                                     to avoid exposing the DMA to bus stalls caused by other
                                                     XIP traffic.                                                              */
    } bit;
  } STREAM_FIFO;
} XIP_CTRL_Type;                                /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                          SYSCFG                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Register block for various chip control signals (SYSCFG)
  */

typedef struct {                                /*!< SYSCFG Structure                                                          */
  
  union {
    __IOM uint32_t reg;                         /*!< Processor core 0 NMI source mask                                          */
    
    struct {
      __IOM uint32_t PROC0_NMI_MASK : 32;       /*!< Set a bit high to enable NMI from that IRQ                                */
    } bit;
  } PROC0_NMI_MASK;
  
  union {
    __IOM uint32_t reg;                         /*!< Processor core 1 NMI source mask                                          */
    
    struct {
      __IOM uint32_t PROC1_NMI_MASK : 32;       /*!< Set a bit high to enable NMI from that IRQ                                */
    } bit;
  } PROC1_NMI_MASK;
  
  union {
    __IOM uint32_t reg;                         /*!< Configuration for processors                                              */
    
    struct {
      __IM  uint32_t PROC0_HALTED : 1;          /*!< Indication that proc0 has halted                                          */
      __IM  uint32_t PROC1_HALTED : 1;          /*!< Indication that proc1 has halted                                          */
            uint32_t            : 22;
      __IOM uint32_t PROC0_DAP_INSTID : 4;      /*!< Configure proc0 DAP instance ID. Recommend that this is NOT
                                                     changed until you require debug access in multi-chip environment
                                                     WARNING: do not set to 15 as this is reserved for RescueDP                */
      __IOM uint32_t PROC1_DAP_INSTID : 4;      /*!< Configure proc1 DAP instance ID. Recommend that this is NOT
                                                     changed until you require debug access in multi-chip environment
                                                     WARNING: do not set to 15 as this is reserved for RescueDP                */
    } bit;
  } PROC_CONFIG;
  
  union {
    __IOM uint32_t reg;                         /*!< For each bit, if 1, bypass the input synchronizer between that
                                                     GPIO and the GPIO input register in the SIO. The input
                                                     synchronizers should generally be unbypassed, to avoid
                                                     injecting metastabilities into processors. If you're feeling
                                                     brave, you can bypass to save two cycles of input latency.
                                                     This register applies to GPIO 0...29.                                     */
    
    struct {
      __IOM uint32_t PROC_IN_SYNC_BYPASS : 30;  /*!< PROC_IN_SYNC_BYPASS                                                       */
            uint32_t            : 2;
    } bit;
  } PROC_IN_SYNC_BYPASS;
  
  union {
    __IOM uint32_t reg;                         /*!< For each bit, if 1, bypass the input synchronizer between that
                                                     GPIO and the GPIO input register in the SIO. The input
                                                     synchronizers should generally be unbypassed, to avoid
                                                     injecting metastabilities into processors. If you're feeling
                                                     brave, you can bypass to save two cycles of input latency.
                                                     This register applies to GPIO 30...35 (the QSPI IOs).                     */
    
    struct {
      __IOM uint32_t PROC_IN_SYNC_BYPASS_HI : 6;/*!< PROC_IN_SYNC_BYPASS_HI                                                    */
            uint32_t            : 26;
    } bit;
  } PROC_IN_SYNC_BYPASS_HI;
  
  union {
    __IOM uint32_t reg;                         /*!< Directly control the SWD debug port of either processor                   */
    
    struct {
      __IM  uint32_t PROC0_SWDO : 1;            /*!< Observe the value of processor 0 SWDIO output.                            */
      __IOM uint32_t PROC0_SWDI : 1;            /*!< Directly drive processor 0 SWDIO input, if PROC0_ATTACH is set            */
      __IOM uint32_t PROC0_SWCLK : 1;           /*!< Directly drive processor 0 SWCLK, if PROC0_ATTACH is set                  */
      __IOM uint32_t PROC0_ATTACH : 1;          /*!< Attach processor 0 debug port to syscfg controls, and disconnect
                                                     it from external SWD pads.                                                */
      __IM  uint32_t PROC1_SWDO : 1;            /*!< Observe the value of processor 1 SWDIO output.                            */
      __IOM uint32_t PROC1_SWDI : 1;            /*!< Directly drive processor 1 SWDIO input, if PROC1_ATTACH is set            */
      __IOM uint32_t PROC1_SWCLK : 1;           /*!< Directly drive processor 1 SWCLK, if PROC1_ATTACH is set                  */
      __IOM uint32_t PROC1_ATTACH : 1;          /*!< Attach processor 1 debug port to syscfg controls, and disconnect
                                                     it from external SWD pads.                                                */
            uint32_t            : 24;
    } bit;
  } DBGFORCE;
  
  union {
    __IOM uint32_t reg;                         /*!< Control power downs to memories. Set high to power down memories.
                                                     Use with extreme caution                                                  */
    
    struct {
      __IOM uint32_t SRAM0      : 1;            /*!< SRAM0                                                                     */
      __IOM uint32_t SRAM1      : 1;            /*!< SRAM1                                                                     */
      __IOM uint32_t SRAM2      : 1;            /*!< SRAM2                                                                     */
      __IOM uint32_t SRAM3      : 1;            /*!< SRAM3                                                                     */
      __IOM uint32_t SRAM4      : 1;            /*!< SRAM4                                                                     */
      __IOM uint32_t SRAM5      : 1;            /*!< SRAM5                                                                     */
      __IOM uint32_t USB        : 1;            /*!< USB                                                                       */
      __IOM uint32_t ROM        : 1;            /*!< ROM                                                                       */
            uint32_t            : 24;
    } bit;
  } MEMPOWERDOWN;
} SYSCFG_Type;                                  /*!< Size = 28 (0x1c)                                                          */



/* =========================================================================================================================== */
/* ================                                           XOSC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Controls the crystal oscillator (XOSC)
  */

typedef struct {                                /*!< XOSC Structure                                                            */
  
  union {
    __IOM uint32_t reg;                         /*!< Crystal Oscillator Control                                                */
    
    struct {
      __IOM uint32_t FREQ_RANGE : 12;           /*!< Frequency range. An invalid setting will retain the previous
                                                     value. The actual value being used can be read from STATUS_FREQ_RANGE.
                                                     This resets to 0xAA0 and cannot be changed.                               */
      __IOM uint32_t ENABLE     : 12;           /*!< On power-up this field is initialised to DISABLE and the chip
                                                     runs from the ROSC. If the chip has subsequently been programmed
                                                     to run from the XOSC then DISABLE may lock-up the chip.
                                                     If this is a concern then run the clk_ref from the ROSC
                                                     and enable the clk_sys RESUS feature. The 12-bit code is
                                                     intended to give some protection against accidental writes.
                                                     An invalid setting will enable the oscillator.                            */
            uint32_t            : 8;
    } bit;
  } CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Crystal Oscillator Status                                                 */
    
    struct {
      __IM  uint32_t FREQ_RANGE : 2;            /*!< The current frequency range setting, always reads 0                       */
            uint32_t            : 10;
      __IM  uint32_t ENABLED    : 1;            /*!< Oscillator is enabled but not necessarily running and stable,
                                                     resets to 0                                                               */
            uint32_t            : 11;
      __IOM uint32_t BADWRITE   : 1;            /*!< An invalid value has been written to CTRL_ENABLE or CTRL_FREQ_RANGE
                                                     or DORMANT                                                                */
            uint32_t            : 6;
      __IM  uint32_t STABLE     : 1;            /*!< Oscillator is running and stable                                          */
    } bit;
  } STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< Crystal Oscillator pause control                                          */
    
    struct {
      __IOM uint32_t DORMANT    : 32;           /*!< This is used to save power by pausing the XOSC On power-up this
                                                     field is initialised to WAKE An invalid write will also
                                                     select WAKE Warning: stop the PLLs before selecting dormant
                                                     mode Warning: setup the irq before selecting dormant mode                 */
    } bit;
  } DORMANT;
  
  union {
    __IOM uint32_t reg;                         /*!< Controls the startup delay                                                */
    
    struct {
      __IOM uint32_t DELAY      : 14;           /*!< in multiples of 256*xtal_period. The reset value of 0xc4 corresponds
                                                     to approx 50 000 cycles.                                                  */
            uint32_t            : 6;
      __IOM uint32_t X4         : 1;            /*!< Multiplies the startup_delay by 4. This is of little value to
                                                     the user given that the delay can be programmed directly.                 */
            uint32_t            : 11;
    } bit;
  } STARTUP;
  __IM  uint32_t  RESERVED[3];
  
  union {
    __IOM uint32_t reg;                         /*!< A down counter running at the xosc frequency which counts to
                                                     zero and stops. To start the counter write a non-zero value.
                                                     Can be used for short software pauses when setting up time
                                                     sensitive hardware.                                                       */
    
    struct {
      __IOM uint32_t COUNT      : 8;            /*!< COUNT                                                                     */
            uint32_t            : 24;
    } bit;
  } COUNT;
} XOSC_Type;                                    /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                          PLL_SYS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief PLL_SYS (PLL_SYS)
  */

typedef struct {                                /*!< PLL_SYS Structure                                                         */
  
  union {
    __IOM uint32_t reg;                         /*!< Control and Status GENERAL CONSTRAINTS: Reference clock frequency
                                                     min=5MHz, max=800MHz Feedback divider min=16, max=320 VCO
                                                     frequency min=750MHz, max=1600MHz                                         */
    
    struct {
      __IOM uint32_t REFDIV     : 6;            /*!< Divides the PLL input reference clock. Behaviour is undefined
                                                     for div=0. PLL output will be unpredictable during refdiv
                                                     changes, wait for lock=1 before using it.                                 */
            uint32_t            : 2;
      __IOM uint32_t BYPASS     : 1;            /*!< Passes the reference clock to the output instead of the divided
                                                     VCO. The VCO continues to run so the user can switch between
                                                     the reference clock and the divided VCO but the output
                                                     will glitch when doing so.                                                */
            uint32_t            : 22;
      __IM  uint32_t LOCK       : 1;            /*!< PLL is locked                                                             */
    } bit;
  } CS;
  
  union {
    __IOM uint32_t reg;                         /*!< Controls the PLL power modes.                                             */
    
    struct {
      __IOM uint32_t PD         : 1;            /*!< PLL powerdown To save power set high when PLL output not required.        */
            uint32_t            : 1;
      __IOM uint32_t DSMPD      : 1;            /*!< PLL DSM powerdown Nothing is achieved by setting this low.                */
      __IOM uint32_t POSTDIVPD  : 1;            /*!< PLL post divider powerdown To save power set high when PLL output
                                                     not required or bypass=1.                                                 */
            uint32_t            : 1;
      __IOM uint32_t VCOPD      : 1;            /*!< PLL VCO powerdown To save power set high when PLL output not
                                                     required or bypass=1.                                                     */
            uint32_t            : 26;
    } bit;
  } PWR;
  
  union {
    __IOM uint32_t reg;                         /*!< Feedback divisor (note: this PLL does not support fractional
                                                     division)                                                                 */
    
    struct {
      __IOM uint32_t FBDIV_INT  : 12;           /*!< see ctrl reg description for constraints                                  */
            uint32_t            : 20;
    } bit;
  } FBDIV_INT;
  
  union {
    __IOM uint32_t reg;                         /*!< Controls the PLL post dividers for the primary output (note:
                                                     this PLL does not have a secondary output) the primary
                                                     output is driven from VCO divided by postdiv1*postdiv2                    */
    
    struct {
            uint32_t            : 12;
      __IOM uint32_t POSTDIV2   : 3;            /*!< divide by 1-7                                                             */
            uint32_t            : 1;
      __IOM uint32_t POSTDIV1   : 3;            /*!< divide by 1-7                                                             */
            uint32_t            : 13;
    } bit;
  } PRIM;
} PLL_SYS_Type;                                 /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                           UART0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief UART0 (UART0)
  */

typedef struct {                                /*!< UART0 Structure                                                           */
  
  union {
    __IOM uint32_t reg;                         /*!< Data Register, UARTDR                                                     */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< Receive (read) data character. Transmit (write) data character.           */
      __IM  uint32_t FE         : 1;            /*!< Framing error. When set to 1, it indicates that the received
                                                     character did not have a valid stop bit (a valid stop bit
                                                     is 1). In FIFO mode, this error is associated with the
                                                     character at the top of the FIFO.                                         */
      __IM  uint32_t PE         : 1;            /*!< Parity error. When set to 1, it indicates that the parity of
                                                     the received data character does not match the parity that
                                                     the EPS and SPS bits in the Line Control Register, UARTLCR_H.
                                                     In FIFO mode, this error is associated with the character
                                                     at the top of the FIFO.                                                   */
      __IM  uint32_t BE         : 1;            /*!< Break error. This bit is set to 1 if a break condition was detected,
                                                     indicating that the received data input was held LOW for
                                                     longer than a full-word transmission time (defined as start,
                                                     data, parity and stop bits). In FIFO mode, this error is
                                                     associated with the character at the top of the FIFO. When
                                                     a break occurs, only one 0 character is loaded into the
                                                     FIFO. The next character is only enabled after the receive
                                                     data input goes to a 1 (marking state), and the next valid
                                                     start bit is received.                                                    */
      __IM  uint32_t OE         : 1;            /*!< Overrun error. This bit is set to 1 if data is received and
                                                     the receive FIFO is already full. This is cleared to 0
                                                     once there is an empty space in the FIFO and a new character
                                                     can be written to it.                                                     */
            uint32_t            : 20;
    } bit;
  } UARTDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Receive Status Register/Error Clear Register, UARTRSR/UARTECR             */
    
    struct {
      __IOM uint32_t FE         : 1;            /*!< Framing error. When set to 1, it indicates that the received
                                                     character did not have a valid stop bit (a valid stop bit
                                                     is 1). This bit is cleared to 0 by a write to UARTECR.
                                                     In FIFO mode, this error is associated with the character
                                                     at the top of the FIFO.                                                   */
      __IOM uint32_t PE         : 1;            /*!< Parity error. When set to 1, it indicates that the parity of
                                                     the received data character does not match the parity that
                                                     the EPS and SPS bits in the Line Control Register, UARTLCR_H.
                                                     This bit is cleared to 0 by a write to UARTECR. In FIFO
                                                     mode, this error is associated with the character at the
                                                     top of the FIFO.                                                          */
      __IOM uint32_t BE         : 1;            /*!< Break error. This bit is set to 1 if a break condition was detected,
                                                     indicating that the received data input was held LOW for
                                                     longer than a full-word transmission time (defined as start,
                                                     data, parity, and stop bits). This bit is cleared to 0
                                                     after a write to UARTECR. In FIFO mode, this error is associated
                                                     with the character at the top of the FIFO. When a break
                                                     occurs, only one 0 character is loaded into the FIFO. The
                                                     next character is only enabled after the receive data input
                                                     goes to a 1 (marking state) and the next valid start bit
                                                     is received.                                                              */
      __IOM uint32_t OE         : 1;            /*!< Overrun error. This bit is set to 1 if data is received and
                                                     the FIFO is already full. This bit is cleared to 0 by a
                                                     write to UARTECR. The FIFO contents remain valid because
                                                     no more data is written when the FIFO is full, only the
                                                     contents of the shift register are overwritten. The CPU
                                                     must now read the data, to empty the FIFO.                                */
            uint32_t            : 28;
    } bit;
  } UARTRSR;
  __IM  uint32_t  RESERVED[4];
  
  union {
    __IOM uint32_t reg;                         /*!< Flag Register, UARTFR                                                     */
    
    struct {
      __IM  uint32_t CTS        : 1;            /*!< Clear to send. This bit is the complement of the UART clear
                                                     to send, nUARTCTS, modem status input. That is, the bit
                                                     is 1 when nUARTCTS is LOW.                                                */
      __IM  uint32_t DSR        : 1;            /*!< Data set ready. This bit is the complement of the UART data
                                                     set ready, nUARTDSR, modem status input. That is, the bit
                                                     is 1 when nUARTDSR is LOW.                                                */
      __IM  uint32_t DCD        : 1;            /*!< Data carrier detect. This bit is the complement of the UART
                                                     data carrier detect, nUARTDCD, modem status input. That
                                                     is, the bit is 1 when nUARTDCD is LOW.                                    */
      __IM  uint32_t BUSY       : 1;            /*!< UART busy. If this bit is set to 1, the UART is busy transmitting
                                                     data. This bit remains set until the complete byte, including
                                                     all the stop bits, has been sent from the shift register.
                                                     This bit is set as soon as the transmit FIFO becomes non-empty,
                                                     regardless of whether the UART is enabled or not.                         */
      __IM  uint32_t RXFE       : 1;            /*!< Receive FIFO empty. The meaning of this bit depends on the state
                                                     of the FEN bit in the UARTLCR_H Register. If the FIFO is
                                                     disabled, this bit is set when the receive holding register
                                                     is empty. If the FIFO is enabled, the RXFE bit is set when
                                                     the receive FIFO is empty.                                                */
      __IM  uint32_t TXFF       : 1;            /*!< Transmit FIFO full. The meaning of this bit depends on the state
                                                     of the FEN bit in the UARTLCR_H Register. If the FIFO is
                                                     disabled, this bit is set when the transmit holding register
                                                     is full. If the FIFO is enabled, the TXFF bit is set when
                                                     the transmit FIFO is full.                                                */
      __IM  uint32_t RXFF       : 1;            /*!< Receive FIFO full. The meaning of this bit depends on the state
                                                     of the FEN bit in the UARTLCR_H Register. If the FIFO is
                                                     disabled, this bit is set when the receive holding register
                                                     is full. If the FIFO is enabled, the RXFF bit is set when
                                                     the receive FIFO is full.                                                 */
      __IM  uint32_t TXFE       : 1;            /*!< Transmit FIFO empty. The meaning of this bit depends on the
                                                     state of the FEN bit in the Line Control Register, UARTLCR_H.
                                                     If the FIFO is disabled, this bit is set when the transmit
                                                     holding register is empty. If the FIFO is enabled, the
                                                     TXFE bit is set when the transmit FIFO is empty. This bit
                                                     does not indicate if there is data in the transmit shift
                                                     register.                                                                 */
      __IM  uint32_t RI         : 1;            /*!< Ring indicator. This bit is the complement of the UART ring
                                                     indicator, nUARTRI, modem status input. That is, the bit
                                                     is 1 when nUARTRI is LOW.                                                 */
            uint32_t            : 23;
    } bit;
  } UARTFR;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t reg;                         /*!< IrDA Low-Power Counter Register, UARTILPR                                 */
    
    struct {
      __IOM uint32_t ILPDVSR    : 8;            /*!< 8-bit low-power divisor value. These bits are cleared to 0 at
                                                     reset.                                                                    */
            uint32_t            : 24;
    } bit;
  } UARTILPR;
  
  union {
    __IOM uint32_t reg;                         /*!< Integer Baud Rate Register, UARTIBRD                                      */
    
    struct {
      __IOM uint32_t BAUD_DIVINT : 16;          /*!< The integer baud rate divisor. These bits are cleared to 0 on
                                                     reset.                                                                    */
            uint32_t            : 16;
    } bit;
  } UARTIBRD;
  
  union {
    __IOM uint32_t reg;                         /*!< Fractional Baud Rate Register, UARTFBRD                                   */
    
    struct {
      __IOM uint32_t BAUD_DIVFRAC : 6;          /*!< The fractional baud rate divisor. These bits are cleared to
                                                     0 on reset.                                                               */
            uint32_t            : 26;
    } bit;
  } UARTFBRD;
  
  union {
    __IOM uint32_t reg;                         /*!< Line Control Register, UARTLCR_H                                          */
    
    struct {
      __IOM uint32_t BRK        : 1;            /*!< Send break. If this bit is set to 1, a low-level is continually
                                                     output on the UARTTXD output, after completing transmission
                                                     of the current character. For the proper execution of the
                                                     break command, the software must set this bit for at least
                                                     two complete frames. For normal use, this bit must be cleared
                                                     to 0.                                                                     */
      __IOM uint32_t PEN        : 1;            /*!< Parity enable: 0 = parity is disabled and no parity bit added
                                                     to the data frame 1 = parity checking and generation is
                                                     enabled.                                                                  */
      __IOM uint32_t EPS        : 1;            /*!< Even parity select. Controls the type of parity the UART uses
                                                     during transmission and reception: 0 = odd parity. The
                                                     UART generates or checks for an odd number of 1s in the
                                                     data and parity bits. 1 = even parity. The UART generates
                                                     or checks for an even number of 1s in the data and parity
                                                     bits. This bit has no effect when the PEN bit disables
                                                     parity checking and generation.                                           */
      __IOM uint32_t STP2       : 1;            /*!< Two stop bits select. If this bit is set to 1, two stop bits
                                                     are transmitted at the end of the frame. The receive logic
                                                     does not check for two stop bits being received.                          */
      __IOM uint32_t FEN        : 1;            /*!< Enable FIFOs: 0 = FIFOs are disabled (character mode) that is,
                                                     the FIFOs become 1-byte-deep holding registers 1 = transmit
                                                     and receive FIFO buffers are enabled (FIFO mode).                         */
      __IOM uint32_t WLEN       : 2;            /*!< Word length. These bits indicate the number of data bits transmitted
                                                     or received in a frame as follows: b11 = 8 bits b10 = 7
                                                     bits b01 = 6 bits b00 = 5 bits.                                           */
      __IOM uint32_t SPS        : 1;            /*!< Stick parity select. 0 = stick parity is disabled 1 = either:
                                                     * if the EPS bit is 0 then the parity bit is transmitted
                                                     and checked as a 1 * if the EPS bit is 1 then the parity
                                                     bit is transmitted and checked as a 0. This bit has no
                                                     effect when the PEN bit disables parity checking and generation.          */
            uint32_t            : 24;
    } bit;
  } UARTLCR_H;
  
  union {
    __IOM uint32_t reg;                         /*!< Control Register, UARTCR                                                  */
    
    struct {
      __IOM uint32_t UARTEN     : 1;            /*!< UART enable: 0 = UART is disabled. If the UART is disabled in
                                                     the middle of transmission or reception, it completes the
                                                     current character before stopping. 1 = the UART is enabled.
                                                     Data transmission and reception occurs for either UART
                                                     signals or SIR signals depending on the setting of the
                                                     SIREN bit.                                                                */
      __IOM uint32_t SIREN      : 1;            /*!< SIR enable: 0 = IrDA SIR ENDEC is disabled. nSIROUT remains
                                                     LOW (no light pulse generated), and signal transitions
                                                     on SIRIN have no effect. 1 = IrDA SIR ENDEC is enabled.
                                                     Data is transmitted and received on nSIROUT and SIRIN.
                                                     UARTTXD remains HIGH, in the marking state. Signal transitions
                                                     on UARTRXD or modem status inputs have no effect. This
                                                     bit has no effect if the UARTEN bit disables the UART.                    */
      __IOM uint32_t SIRLP      : 1;            /*!< SIR low-power IrDA mode. This bit selects the IrDA encoding
                                                     mode. If this bit is cleared to 0, low-level bits are transmitted
                                                     as an active high pulse with a width of 3 / 16th of the
                                                     bit period. If this bit is set to 1, low-level bits are
                                                     transmitted with a pulse width that is 3 times the period
                                                     of the IrLPBaud16 input signal, regardless of the selected
                                                     bit rate. Setting this bit uses less power, but might reduce
                                                     transmission distances.                                                   */
            uint32_t            : 4;
      __IOM uint32_t LBE        : 1;            /*!< Loopback enable. If this bit is set to 1 and the SIREN bit is
                                                     set to 1 and the SIRTEST bit in the Test Control Register,
                                                     UARTTCR is set to 1, then the nSIROUT path is inverted,
                                                     and fed through to the SIRIN path. The SIRTEST bit in the
                                                     test register must be set to 1 to override the normal half-duplex
                                                     SIR operation. This must be the requirement for accessing
                                                     the test registers during normal operation, and SIRTEST
                                                     must be cleared to 0 when loopback testing is finished.
                                                     This feature reduces the amount of external coupling required
                                                     during system test. If this bit is set to 1, and the SIRTEST
                                                     bit is set to 0, the UARTTXD path is fed through to the
                                                     UARTRXD path. In either SIR mode or UART mode, when this
                                                     bit is set, the modem outputs are also fed through to the
                                                     modem inputs. This bit is cleared to 0 on reset, to disable
                                                     loopback.                                                                 */
      __IOM uint32_t TXE        : 1;            /*!< Transmit enable. If this bit is set to 1, the transmit section
                                                     of the UART is enabled. Data transmission occurs for either
                                                     UART signals, or SIR signals depending on the setting of
                                                     the SIREN bit. When the UART is disabled in the middle
                                                     of transmission, it completes the current character before
                                                     stopping.                                                                 */
      __IOM uint32_t RXE        : 1;            /*!< Receive enable. If this bit is set to 1, the receive section
                                                     of the UART is enabled. Data reception occurs for either
                                                     UART signals or SIR signals depending on the setting of
                                                     the SIREN bit. When the UART is disabled in the middle
                                                     of reception, it completes the current character before
                                                     stopping.                                                                 */
      __IOM uint32_t DTR        : 1;            /*!< Data transmit ready. This bit is the complement of the UART
                                                     data transmit ready, nUARTDTR, modem status output. That
                                                     is, when the bit is programmed to a 1 then nUARTDTR is
                                                     LOW.                                                                      */
      __IOM uint32_t RTS        : 1;            /*!< Request to send. This bit is the complement of the UART request
                                                     to send, nUARTRTS, modem status output. That is, when the
                                                     bit is programmed to a 1 then nUARTRTS is LOW.                            */
      __IOM uint32_t OUT1       : 1;            /*!< This bit is the complement of the UART Out1 (nUARTOut1) modem
                                                     status output. That is, when the bit is programmed to a
                                                     1 the output is 0. For DTE this can be used as Data Carrier
                                                     Detect (DCD).                                                             */
      __IOM uint32_t OUT2       : 1;            /*!< This bit is the complement of the UART Out2 (nUARTOut2) modem
                                                     status output. That is, when the bit is programmed to a
                                                     1, the output is 0. For DTE this can be used as Ring Indicator
                                                     (RI).                                                                     */
      __IOM uint32_t RTSEN      : 1;            /*!< RTS hardware flow control enable. If this bit is set to 1, RTS
                                                     hardware flow control is enabled. Data is only requested
                                                     when there is space in the receive FIFO for it to be received.            */
      __IOM uint32_t CTSEN      : 1;            /*!< CTS hardware flow control enable. If this bit is set to 1, CTS
                                                     hardware flow control is enabled. Data is only transmitted
                                                     when the nUARTCTS signal is asserted.                                     */
            uint32_t            : 16;
    } bit;
  } UARTCR;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt FIFO Level Select Register, UARTIFLS                            */
    
    struct {
      __IOM uint32_t TXIFLSEL   : 3;            /*!< Transmit interrupt FIFO level select. The trigger points for
                                                     the transmit interrupt are as follows: b000 = Transmit
                                                     FIFO becomes <= 1 / 8 full b001 = Transmit FIFO becomes
                                                     <= 1 / 4 full b010 = Transmit FIFO becomes <= 1 / 2 full
                                                     b011 = Transmit FIFO becomes <= 3 / 4 full b100 = Transmit
                                                     FIFO becomes <= 7 / 8 full b101-b111 = reserved.                          */
      __IOM uint32_t RXIFLSEL   : 3;            /*!< Receive interrupt FIFO level select. The trigger points for
                                                     the receive interrupt are as follows: b000 = Receive FIFO
                                                     becomes >= 1 / 8 full b001 = Receive FIFO becomes >= 1
                                                     / 4 full b010 = Receive FIFO becomes >= 1 / 2 full b011
                                                     = Receive FIFO becomes >= 3 / 4 full b100 = Receive FIFO
                                                     becomes >= 7 / 8 full b101-b111 = reserved.                               */
            uint32_t            : 26;
    } bit;
  } UARTIFLS;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Mask Set/Clear Register, UARTIMSC                               */
    
    struct {
      __IOM uint32_t RIMIM      : 1;            /*!< nUARTRI modem interrupt mask. A read returns the current mask
                                                     for the UARTRIINTR interrupt. On a write of 1, the mask
                                                     of the UARTRIINTR interrupt is set. A write of 0 clears
                                                     the mask.                                                                 */
      __IOM uint32_t CTSMIM     : 1;            /*!< nUARTCTS modem interrupt mask. A read returns the current mask
                                                     for the UARTCTSINTR interrupt. On a write of 1, the mask
                                                     of the UARTCTSINTR interrupt is set. A write of 0 clears
                                                     the mask.                                                                 */
      __IOM uint32_t DCDMIM     : 1;            /*!< nUARTDCD modem interrupt mask. A read returns the current mask
                                                     for the UARTDCDINTR interrupt. On a write of 1, the mask
                                                     of the UARTDCDINTR interrupt is set. A write of 0 clears
                                                     the mask.                                                                 */
      __IOM uint32_t DSRMIM     : 1;            /*!< nUARTDSR modem interrupt mask. A read returns the current mask
                                                     for the UARTDSRINTR interrupt. On a write of 1, the mask
                                                     of the UARTDSRINTR interrupt is set. A write of 0 clears
                                                     the mask.                                                                 */
      __IOM uint32_t RXIM       : 1;            /*!< Receive interrupt mask. A read returns the current mask for
                                                     the UARTRXINTR interrupt. On a write of 1, the mask of
                                                     the UARTRXINTR interrupt is set. A write of 0 clears the
                                                     mask.                                                                     */
      __IOM uint32_t TXIM       : 1;            /*!< Transmit interrupt mask. A read returns the current mask for
                                                     the UARTTXINTR interrupt. On a write of 1, the mask of
                                                     the UARTTXINTR interrupt is set. A write of 0 clears the
                                                     mask.                                                                     */
      __IOM uint32_t RTIM       : 1;            /*!< Receive timeout interrupt mask. A read returns the current mask
                                                     for the UARTRTINTR interrupt. On a write of 1, the mask
                                                     of the UARTRTINTR interrupt is set. A write of 0 clears
                                                     the mask.                                                                 */
      __IOM uint32_t FEIM       : 1;            /*!< Framing error interrupt mask. A read returns the current mask
                                                     for the UARTFEINTR interrupt. On a write of 1, the mask
                                                     of the UARTFEINTR interrupt is set. A write of 0 clears
                                                     the mask.                                                                 */
      __IOM uint32_t PEIM       : 1;            /*!< Parity error interrupt mask. A read returns the current mask
                                                     for the UARTPEINTR interrupt. On a write of 1, the mask
                                                     of the UARTPEINTR interrupt is set. A write of 0 clears
                                                     the mask.                                                                 */
      __IOM uint32_t BEIM       : 1;            /*!< Break error interrupt mask. A read returns the current mask
                                                     for the UARTBEINTR interrupt. On a write of 1, the mask
                                                     of the UARTBEINTR interrupt is set. A write of 0 clears
                                                     the mask.                                                                 */
      __IOM uint32_t OEIM       : 1;            /*!< Overrun error interrupt mask. A read returns the current mask
                                                     for the UARTOEINTR interrupt. On a write of 1, the mask
                                                     of the UARTOEINTR interrupt is set. A write of 0 clears
                                                     the mask.                                                                 */
            uint32_t            : 21;
    } bit;
  } UARTIMSC;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw Interrupt Status Register, UARTRIS                                    */
    
    struct {
      __IM  uint32_t RIRMIS     : 1;            /*!< nUARTRI modem interrupt status. Returns the raw interrupt state
                                                     of the UARTRIINTR interrupt.                                              */
      __IM  uint32_t CTSRMIS    : 1;            /*!< nUARTCTS modem interrupt status. Returns the raw interrupt state
                                                     of the UARTCTSINTR interrupt.                                             */
      __IM  uint32_t DCDRMIS    : 1;            /*!< nUARTDCD modem interrupt status. Returns the raw interrupt state
                                                     of the UARTDCDINTR interrupt.                                             */
      __IM  uint32_t DSRRMIS    : 1;            /*!< nUARTDSR modem interrupt status. Returns the raw interrupt state
                                                     of the UARTDSRINTR interrupt.                                             */
      __IM  uint32_t RXRIS      : 1;            /*!< Receive interrupt status. Returns the raw interrupt state of
                                                     the UARTRXINTR interrupt.                                                 */
      __IM  uint32_t TXRIS      : 1;            /*!< Transmit interrupt status. Returns the raw interrupt state of
                                                     the UARTTXINTR interrupt.                                                 */
      __IM  uint32_t RTRIS      : 1;            /*!< Receive timeout interrupt status. Returns the raw interrupt
                                                     state of the UARTRTINTR interrupt. a                                      */
      __IM  uint32_t FERIS      : 1;            /*!< Framing error interrupt status. Returns the raw interrupt state
                                                     of the UARTFEINTR interrupt.                                              */
      __IM  uint32_t PERIS      : 1;            /*!< Parity error interrupt status. Returns the raw interrupt state
                                                     of the UARTPEINTR interrupt.                                              */
      __IM  uint32_t BERIS      : 1;            /*!< Break error interrupt status. Returns the raw interrupt state
                                                     of the UARTBEINTR interrupt.                                              */
      __IM  uint32_t OERIS      : 1;            /*!< Overrun error interrupt status. Returns the raw interrupt state
                                                     of the UARTOEINTR interrupt.                                              */
            uint32_t            : 21;
    } bit;
  } UARTRIS;
  
  union {
    __IOM uint32_t reg;                         /*!< Masked Interrupt Status Register, UARTMIS                                 */
    
    struct {
      __IM  uint32_t RIMMIS     : 1;            /*!< nUARTRI modem masked interrupt status. Returns the masked interrupt
                                                     state of the UARTRIINTR interrupt.                                        */
      __IM  uint32_t CTSMMIS    : 1;            /*!< nUARTCTS modem masked interrupt status. Returns the masked interrupt
                                                     state of the UARTCTSINTR interrupt.                                       */
      __IM  uint32_t DCDMMIS    : 1;            /*!< nUARTDCD modem masked interrupt status. Returns the masked interrupt
                                                     state of the UARTDCDINTR interrupt.                                       */
      __IM  uint32_t DSRMMIS    : 1;            /*!< nUARTDSR modem masked interrupt status. Returns the masked interrupt
                                                     state of the UARTDSRINTR interrupt.                                       */
      __IM  uint32_t RXMIS      : 1;            /*!< Receive masked interrupt status. Returns the masked interrupt
                                                     state of the UARTRXINTR interrupt.                                        */
      __IM  uint32_t TXMIS      : 1;            /*!< Transmit masked interrupt status. Returns the masked interrupt
                                                     state of the UARTTXINTR interrupt.                                        */
      __IM  uint32_t RTMIS      : 1;            /*!< Receive timeout masked interrupt status. Returns the masked
                                                     interrupt state of the UARTRTINTR interrupt.                              */
      __IM  uint32_t FEMIS      : 1;            /*!< Framing error masked interrupt status. Returns the masked interrupt
                                                     state of the UARTFEINTR interrupt.                                        */
      __IM  uint32_t PEMIS      : 1;            /*!< Parity error masked interrupt status. Returns the masked interrupt
                                                     state of the UARTPEINTR interrupt.                                        */
      __IM  uint32_t BEMIS      : 1;            /*!< Break error masked interrupt status. Returns the masked interrupt
                                                     state of the UARTBEINTR interrupt.                                        */
      __IM  uint32_t OEMIS      : 1;            /*!< Overrun error masked interrupt status. Returns the masked interrupt
                                                     state of the UARTOEINTR interrupt.                                        */
            uint32_t            : 21;
    } bit;
  } UARTMIS;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Clear Register, UARTICR                                         */
    
    struct {
      __IOM uint32_t RIMIC      : 1;            /*!< nUARTRI modem interrupt clear. Clears the UARTRIINTR interrupt.           */
      __IOM uint32_t CTSMIC     : 1;            /*!< nUARTCTS modem interrupt clear. Clears the UARTCTSINTR interrupt.         */
      __IOM uint32_t DCDMIC     : 1;            /*!< nUARTDCD modem interrupt clear. Clears the UARTDCDINTR interrupt.         */
      __IOM uint32_t DSRMIC     : 1;            /*!< nUARTDSR modem interrupt clear. Clears the UARTDSRINTR interrupt.         */
      __IOM uint32_t RXIC       : 1;            /*!< Receive interrupt clear. Clears the UARTRXINTR interrupt.                 */
      __IOM uint32_t TXIC       : 1;            /*!< Transmit interrupt clear. Clears the UARTTXINTR interrupt.                */
      __IOM uint32_t RTIC       : 1;            /*!< Receive timeout interrupt clear. Clears the UARTRTINTR interrupt.         */
      __IOM uint32_t FEIC       : 1;            /*!< Framing error interrupt clear. Clears the UARTFEINTR interrupt.           */
      __IOM uint32_t PEIC       : 1;            /*!< Parity error interrupt clear. Clears the UARTPEINTR interrupt.            */
      __IOM uint32_t BEIC       : 1;            /*!< Break error interrupt clear. Clears the UARTBEINTR interrupt.             */
      __IOM uint32_t OEIC       : 1;            /*!< Overrun error interrupt clear. Clears the UARTOEINTR interrupt.           */
            uint32_t            : 21;
    } bit;
  } UARTICR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Control Register, UARTDMACR                                           */
    
    struct {
      __IOM uint32_t RXDMAE     : 1;            /*!< Receive DMA enable. If this bit is set to 1, DMA for the receive
                                                     FIFO is enabled.                                                          */
      __IOM uint32_t TXDMAE     : 1;            /*!< Transmit DMA enable. If this bit is set to 1, DMA for the transmit
                                                     FIFO is enabled.                                                          */
      __IOM uint32_t DMAONERR   : 1;            /*!< DMA on error. If this bit is set to 1, the DMA receive request
                                                     outputs, UARTRXDMASREQ or UARTRXDMABREQ, are disabled when
                                                     the UART error interrupt is asserted.                                     */
            uint32_t            : 29;
    } bit;
  } UARTDMACR;
  __IM  uint32_t  RESERVED2[997];
  
  union {
    __IOM uint32_t reg;                         /*!< UARTPeriphID0 Register                                                    */
    
    struct {
      __IM  uint32_t PARTNUMBER0 : 8;           /*!< These bits read back as 0x11                                              */
            uint32_t            : 24;
    } bit;
  } UARTPERIPHID0;
  
  union {
    __IOM uint32_t reg;                         /*!< UARTPeriphID1 Register                                                    */
    
    struct {
      __IM  uint32_t PARTNUMBER1 : 4;           /*!< These bits read back as 0x0                                               */
      __IM  uint32_t DESIGNER0  : 4;            /*!< These bits read back as 0x1                                               */
            uint32_t            : 24;
    } bit;
  } UARTPERIPHID1;
  
  union {
    __IOM uint32_t reg;                         /*!< UARTPeriphID2 Register                                                    */
    
    struct {
      __IM  uint32_t DESIGNER1  : 4;            /*!< These bits read back as 0x4                                               */
      __IM  uint32_t REVISION   : 4;            /*!< This field depends on the revision of the UART: r1p0 0x0 r1p1
                                                     0x1 r1p3 0x2 r1p4 0x2 r1p5 0x3                                            */
            uint32_t            : 24;
    } bit;
  } UARTPERIPHID2;
  
  union {
    __IOM uint32_t reg;                         /*!< UARTPeriphID3 Register                                                    */
    
    struct {
      __IM  uint32_t CONFIGURATION : 8;         /*!< These bits read back as 0x00                                              */
            uint32_t            : 24;
    } bit;
  } UARTPERIPHID3;
  
  union {
    __IOM uint32_t reg;                         /*!< UARTPCellID0 Register                                                     */
    
    struct {
      __IM  uint32_t UARTPCELLID0 : 8;          /*!< These bits read back as 0x0D                                              */
            uint32_t            : 24;
    } bit;
  } UARTPCELLID0;
  
  union {
    __IOM uint32_t reg;                         /*!< UARTPCellID1 Register                                                     */
    
    struct {
      __IM  uint32_t UARTPCELLID1 : 8;          /*!< These bits read back as 0xF0                                              */
            uint32_t            : 24;
    } bit;
  } UARTPCELLID1;
  
  union {
    __IOM uint32_t reg;                         /*!< UARTPCellID2 Register                                                     */
    
    struct {
      __IM  uint32_t UARTPCELLID2 : 8;          /*!< These bits read back as 0x05                                              */
            uint32_t            : 24;
    } bit;
  } UARTPCELLID2;
  
  union {
    __IOM uint32_t reg;                         /*!< UARTPCellID3 Register                                                     */
    
    struct {
      __IM  uint32_t UARTPCELLID3 : 8;          /*!< These bits read back as 0xB1                                              */
            uint32_t            : 24;
    } bit;
  } UARTPCELLID3;
} UART0_Type;                                   /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           ROSC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief ROSC (ROSC)
  */

typedef struct {                                /*!< ROSC Structure                                                            */
  
  union {
    __IOM uint32_t reg;                         /*!< Ring Oscillator control                                                   */
    
    struct {
      __IOM uint32_t FREQ_RANGE : 12;           /*!< Controls the number of delay stages in the ROSC ring LOW uses
                                                     stages 0 to 7 MEDIUM uses stages 2 to 7 HIGH uses stages
                                                     4 to 7 TOOHIGH uses stages 6 to 7 and should not be used
                                                     because its frequency exceeds design specifications The
                                                     clock output will not glitch when changing the range up
                                                     one step at a time The clock output will glitch when changing
                                                     the range down Note: the values here are gray coded which
                                                     is why HIGH comes before TOOHIGH                                          */
      __IOM uint32_t ENABLE     : 12;           /*!< On power-up this field is initialised to ENABLE The system clock
                                                     must be switched to another source before setting this
                                                     field to DISABLE otherwise the chip will lock up The 12-bit
                                                     code is intended to give some protection against accidental
                                                     writes. An invalid setting will enable the oscillator.                    */
            uint32_t            : 8;
    } bit;
  } CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< The FREQA & FREQB registers control the frequency by controlling
                                                     the drive strength of each stage The drive strength has
                                                     4 levels determined by the number of bits set Increasing
                                                     the number of bits set increases the drive strength and
                                                     increases the oscillation frequency 0 bits set is the default
                                                     drive strength 1 bit set doubles the drive strength 2 bits
                                                     set triples drive strength 3 bits set quadruples drive
                                                     strength                                                                  */
    
    struct {
      __IOM uint32_t DS0        : 3;            /*!< Stage 0 drive strength                                                    */
            uint32_t            : 1;
      __IOM uint32_t DS1        : 3;            /*!< Stage 1 drive strength                                                    */
            uint32_t            : 1;
      __IOM uint32_t DS2        : 3;            /*!< Stage 2 drive strength                                                    */
            uint32_t            : 1;
      __IOM uint32_t DS3        : 3;            /*!< Stage 3 drive strength                                                    */
            uint32_t            : 1;
      __IOM uint32_t PASSWD     : 16;           /*!< Set to 0x9696 to apply the settings Any other value in this
                                                     field will set all drive strengths to 0                                   */
    } bit;
  } FREQA;
  
  union {
    __IOM uint32_t reg;                         /*!< For a detailed description see freqa register                             */
    
    struct {
      __IOM uint32_t DS4        : 3;            /*!< Stage 4 drive strength                                                    */
            uint32_t            : 1;
      __IOM uint32_t DS5        : 3;            /*!< Stage 5 drive strength                                                    */
            uint32_t            : 1;
      __IOM uint32_t DS6        : 3;            /*!< Stage 6 drive strength                                                    */
            uint32_t            : 1;
      __IOM uint32_t DS7        : 3;            /*!< Stage 7 drive strength                                                    */
            uint32_t            : 1;
      __IOM uint32_t PASSWD     : 16;           /*!< Set to 0x9696 to apply the settings Any other value in this
                                                     field will set all drive strengths to 0                                   */
    } bit;
  } FREQB;
  
  union {
    __IOM uint32_t reg;                         /*!< Ring Oscillator pause control                                             */
    
    struct {
      __IOM uint32_t DORMANT    : 32;           /*!< This is used to save power by pausing the ROSC On power-up this
                                                     field is initialised to WAKE An invalid write will also
                                                     select WAKE Warning: setup the irq before selecting dormant
                                                     mode                                                                      */
    } bit;
  } DORMANT;
  
  union {
    __IOM uint32_t reg;                         /*!< Controls the output divider                                               */
    
    struct {
      __IOM uint32_t DIV        : 12;           /*!< set to 0xaa0 + div where div = 0 divides by 32 div = 1-31 divides
                                                     by div any other value sets div=31 this register resets
                                                     to div=16                                                                 */
            uint32_t            : 20;
    } bit;
  } DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Controls the phase shifted output                                         */
    
    struct {
      __IOM uint32_t SHIFT      : 2;            /*!< phase shift the phase-shifted output by SHIFT input clocks this
                                                     can be changed on-the-fly must be set to 0 before setting
                                                     div=1                                                                     */
      __IOM uint32_t FLIP       : 1;            /*!< invert the phase-shifted output this is ignored when div=1                */
      __IOM uint32_t ENABLE     : 1;            /*!< enable the phase-shifted output this can be changed on-the-fly            */
      __IOM uint32_t PASSWD     : 8;            /*!< set to 0xaa any other value enables the output with shift=0               */
            uint32_t            : 20;
    } bit;
  } PHASE;
  
  union {
    __IOM uint32_t reg;                         /*!< Ring Oscillator Status                                                    */
    
    struct {
            uint32_t            : 12;
      __IM  uint32_t ENABLED    : 1;            /*!< Oscillator is enabled but not necessarily running and stable
                                                     this resets to 0 but transitions to 1 during chip startup                 */
            uint32_t            : 3;
      __IM  uint32_t DIV_RUNNING : 1;           /*!< post-divider is running this resets to 0 but transitions to
                                                     1 during chip startup                                                     */
            uint32_t            : 7;
      __IOM uint32_t BADWRITE   : 1;            /*!< An invalid value has been written to CTRL_ENABLE or CTRL_FREQ_RANGE
                                                     or FREQA or FREQB or DIV or PHASE or DORMANT                              */
            uint32_t            : 6;
      __IM  uint32_t STABLE     : 1;            /*!< Oscillator is running and stable                                          */
    } bit;
  } STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< This just reads the state of the oscillator output so randomness
                                                     is compromised if the ring oscillator is stopped or run
                                                     at a harmonic of the bus frequency                                        */
    
    struct {
      __IM  uint32_t RANDOMBIT  : 1;            /*!< RANDOMBIT                                                                 */
            uint32_t            : 31;
    } bit;
  } RANDOMBIT;
  
  union {
    __IOM uint32_t reg;                         /*!< A down counter running at the ROSC frequency which counts to
                                                     zero and stops. To start the counter write a non-zero value.
                                                     Can be used for short software pauses when setting up time
                                                     sensitive hardware.                                                       */
    
    struct {
      __IOM uint32_t COUNT      : 8;            /*!< COUNT                                                                     */
            uint32_t            : 24;
    } bit;
  } COUNT;
} ROSC_Type;                                    /*!< Size = 36 (0x24)                                                          */



/* =========================================================================================================================== */
/* ================                                         WATCHDOG                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief WATCHDOG (WATCHDOG)
  */

typedef struct {                                /*!< WATCHDOG Structure                                                        */
  
  union {
    __IOM uint32_t reg;                         /*!< Watchdog control The rst_wdsel register determines which subsystems
                                                     are reset when the watchdog is triggered. The watchdog
                                                     can be triggered in software.                                             */
    
    struct {
      __IM  uint32_t TIME       : 24;           /*!< Indicates the number of ticks / 2 (see errata RP2040-E1) before
                                                     a watchdog reset will be triggered                                        */
      __IOM uint32_t PAUSE_JTAG : 1;            /*!< Pause the watchdog timer when JTAG is accessing the bus fabric            */
      __IOM uint32_t PAUSE_DBG0 : 1;            /*!< Pause the watchdog timer when processor 0 is in debug mode                */
      __IOM uint32_t PAUSE_DBG1 : 1;            /*!< Pause the watchdog timer when processor 1 is in debug mode                */
            uint32_t            : 3;
      __IOM uint32_t ENABLE     : 1;            /*!< When not enabled the watchdog timer is paused                             */
      __OM  uint32_t TRIGGER    : 1;            /*!< Trigger a watchdog reset                                                  */
    } bit;
  } CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Load the watchdog timer. The maximum setting is 0xffffff which
                                                     corresponds to 0xffffff / 2 ticks before triggering a watchdog
                                                     reset (see errata RP2040-E1).                                             */
    
    struct {
      __OM  uint32_t LOAD       : 24;           /*!< LOAD                                                                      */
            uint32_t            : 8;
    } bit;
  } LOAD;
  
  union {
    __IOM uint32_t reg;                         /*!< Logs the reason for the last reset. Both bits are zero for the
                                                     case of a hardware reset.                                                 */
    
    struct {
      __IM  uint32_t TIMER      : 1;            /*!< TIMER                                                                     */
      __IM  uint32_t FORCE      : 1;            /*!< FORCE                                                                     */
            uint32_t            : 30;
    } bit;
  } REASON;
  
  union {
    __IOM uint32_t reg;                         /*!< Scratch register. Information persists through soft reset of
                                                     the chip.                                                                 */
    
    struct {
      __IOM uint32_t SCRATCH0   : 32;           /*!< SCRATCH0                                                                  */
    } bit;
  } SCRATCH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Scratch register. Information persists through soft reset of
                                                     the chip.                                                                 */
    
    struct {
      __IOM uint32_t SCRATCH1   : 32;           /*!< SCRATCH1                                                                  */
    } bit;
  } SCRATCH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Scratch register. Information persists through soft reset of
                                                     the chip.                                                                 */
    
    struct {
      __IOM uint32_t SCRATCH2   : 32;           /*!< SCRATCH2                                                                  */
    } bit;
  } SCRATCH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Scratch register. Information persists through soft reset of
                                                     the chip.                                                                 */
    
    struct {
      __IOM uint32_t SCRATCH3   : 32;           /*!< SCRATCH3                                                                  */
    } bit;
  } SCRATCH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Scratch register. Information persists through soft reset of
                                                     the chip.                                                                 */
    
    struct {
      __IOM uint32_t SCRATCH4   : 32;           /*!< SCRATCH4                                                                  */
    } bit;
  } SCRATCH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Scratch register. Information persists through soft reset of
                                                     the chip.                                                                 */
    
    struct {
      __IOM uint32_t SCRATCH5   : 32;           /*!< SCRATCH5                                                                  */
    } bit;
  } SCRATCH5;
  
  union {
    __IOM uint32_t reg;                         /*!< Scratch register. Information persists through soft reset of
                                                     the chip.                                                                 */
    
    struct {
      __IOM uint32_t SCRATCH6   : 32;           /*!< SCRATCH6                                                                  */
    } bit;
  } SCRATCH6;
  
  union {
    __IOM uint32_t reg;                         /*!< Scratch register. Information persists through soft reset of
                                                     the chip.                                                                 */
    
    struct {
      __IOM uint32_t SCRATCH7   : 32;           /*!< SCRATCH7                                                                  */
    } bit;
  } SCRATCH7;
  
  union {
    __IOM uint32_t reg;                         /*!< Controls the tick generator                                               */
    
    struct {
      __IOM uint32_t CYCLES     : 9;            /*!< Total number of clk_tick cycles before the next tick.                     */
      __IOM uint32_t ENABLE     : 1;            /*!< start / stop tick generation                                              */
      __IM  uint32_t RUNNING    : 1;            /*!< Is the tick generator running?                                            */
      __IM  uint32_t COUNT      : 9;            /*!< Count down timer: the remaining number clk_tick cycles before
                                                     the next tick is generated.                                               */
            uint32_t            : 12;
    } bit;
  } TICK;
} WATCHDOG_Type;                                /*!< Size = 48 (0x30)                                                          */



/* =========================================================================================================================== */
/* ================                                            DMA                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief DMA with separate read and write masters (DMA)
  */

typedef struct {                                /*!< DMA Structure                                                             */
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 0 Read Address pointer                                        */
    
    struct {
      __IOM uint32_t CH0_READ_ADDR : 32;        /*!< This register updates automatically each time a read completes.
                                                     The current value is the next address to be read by this
                                                     channel.                                                                  */
    } bit;
  } CH0_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 0 Write Address pointer                                       */
    
    struct {
      __IOM uint32_t CH0_WRITE_ADDR : 32;       /*!< This register updates automatically each time a write completes.
                                                     The current value is the next address to be written by
                                                     this channel.                                                             */
    } bit;
  } CH0_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 0 Transfer Count                                              */
    
    struct {
      __IOM uint32_t CH0_TRANS_COUNT : 32;      /*!< Program the number of bus transfers a channel will perform before
                                                     halting. Note that, if transfers are larger than one byte
                                                     in size, this is not equal to the number of bytes transferred
                                                     (see CTRL_DATA_SIZE). When the channel is active, reading
                                                     this register shows the number of transfers remaining,
                                                     updating automatically each time a write transfer completes.
                                                     Writing this register sets the RELOAD value for the transfer
                                                     counter. Each time this channel is triggered, the RELOAD
                                                     value is copied into the live transfer counter. The channel
                                                     can be started multiple times, and will perform the same
                                                     number of transfers each time, as programmed by most recent
                                                     write. The RELOAD value can be observed at CHx_DBG_TCR.
                                                     If TRANS_COUNT is used as a trigger, the written value
                                                     is used immediately as the length of the new transfer sequence,
                                                     as well as being written to RELOAD.                                       */
    } bit;
  } CH0_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 0 Control and Status                                          */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< DMA Channel Enable. When 1, the channel will respond to triggering
                                                     events, which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< HIGH_PRIORITY gives a channel preferential treatment in issue
                                                     scheduling: in each scheduling round, all high priority
                                                     channels are considered first, and then only a single low
                                                     priority channel, before returning to the high priority
                                                     channels. This only affects the order in which the DMA
                                                     schedules channels. The DMA's bus priority is not changed.
                                                     If the DMA is not saturated then a low priority channel
                                                     will see no loss of throughput.                                           */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< Set the size of each bus transfer (byte/halfword/word). READ_ADDR
                                                     and WRITE_ADDR advance by this amount (1/2/4 bytes) with
                                                     each transfer.                                                            */
      __IOM uint32_t INCR_READ  : 1;            /*!< If 1, the read address increments with each transfer. If 0,
                                                     each read is directed to the same, initial address. Generally
                                                     this should be disabled for peripheral-to-memory transfers.               */
      __IOM uint32_t INCR_WRITE : 1;            /*!< If 1, the write address increments with each transfer. If 0,
                                                     each write is directed to the same, initial address. Generally
                                                     this should be disabled for memory-to-peripheral transfers.               */
      __IOM uint32_t RING_SIZE  : 4;            /*!< Size of address wrap region. If 0, don't wrap. For values n
                                                     > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers. Ring sizes between
                                                     2 and 32768 bytes are possible. This can apply to either
                                                     read or write addresses, based on value of RING_SEL.                      */
      __IOM uint32_t RING_SEL   : 1;            /*!< Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< When this channel completes, it will trigger the channel indicated
                                                     by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.              */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< Select a Transfer Request signal. The channel uses the transfer
                                                     request signal to pace its data transfer rate. Sources
                                                     for TREQ signals are internal (TIMERS) or external (DREQ,
                                                     a Data Request from the system). 0x0 to 0x3a -> select
                                                     DREQ n as TREQ                                                            */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< In QUIET mode, the channel does not generate IRQs at the end
                                                     of every transfer block. Instead, an IRQ is raised when
                                                     NULL is written to a trigger register, indicating the end
                                                     of a control block chain. This reduces the number of interrupts
                                                     to be serviced by the CPU when transferring a DMA chain
                                                     of many small control blocks.                                             */
      __IOM uint32_t BSWAP      : 1;            /*!< Apply byte-swap transformation to DMA data. For byte data, this
                                                     has no effect. For halfword data, the two bytes of each
                                                     halfword are swapped. For word data, the four bytes of
                                                     each word are swapped to reverse order.                                   */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< If 1, this channel's data transfers are visible to the sniff
                                                     hardware, and each transfer will advance the state of the
                                                     checksum. This only applies if the sniff hardware is enabled,
                                                     and has this channel selected. This allows checksum to
                                                     be enabled or disabled on a per-control- block basis.                     */
      __IM  uint32_t BUSY       : 1;            /*!< This flag goes high when the channel starts a new transfer sequence,
                                                     and low when the last transfer of that sequence completes.
                                                     Clearing EN while BUSY is high pauses the channel, and
                                                     BUSY will stay high while paused. To terminate a sequence
                                                     early (and clear the BUSY flag), see CHAN_ABORT.                          */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< If 1, the channel received a write bus error. Write one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not be earlier, or more than
                                                     5 transfers later)                                                        */
      __IOM uint32_t READ_ERROR : 1;            /*!< If 1, the channel received a read bus error. Write one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not be earlier, or more than 3 transfers
                                                     later)                                                                    */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel
                                                     halts when it encounters any bus error, and always raises
                                                     its channel IRQ flag.                                                     */
    } bit;
  } CH0_CTRL_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 0 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH0_AL1_CTRL : 32;         /*!< CH0_AL1_CTRL                                                              */
    } bit;
  } CH0_AL1_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 0 READ_ADDR register                                    */
    
    struct {
      __IOM uint32_t CH0_AL1_READ_ADDR : 32;    /*!< CH0_AL1_READ_ADDR                                                         */
    } bit;
  } CH0_AL1_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 0 WRITE_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH0_AL1_WRITE_ADDR : 32;   /*!< CH0_AL1_WRITE_ADDR                                                        */
    } bit;
  } CH0_AL1_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 0 TRANS_COUNT register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH0_AL1_TRANS_COUNT_TRIG : 32;/*!< CH0_AL1_TRANS_COUNT_TRIG                                               */
    } bit;
  } CH0_AL1_TRANS_COUNT_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 0 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH0_AL2_CTRL : 32;         /*!< CH0_AL2_CTRL                                                              */
    } bit;
  } CH0_AL2_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 0 TRANS_COUNT register                                  */
    
    struct {
      __IOM uint32_t CH0_AL2_TRANS_COUNT : 32;  /*!< CH0_AL2_TRANS_COUNT                                                       */
    } bit;
  } CH0_AL2_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 0 READ_ADDR register                                    */
    
    struct {
      __IOM uint32_t CH0_AL2_READ_ADDR : 32;    /*!< CH0_AL2_READ_ADDR                                                         */
    } bit;
  } CH0_AL2_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 0 WRITE_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH0_AL2_WRITE_ADDR_TRIG : 32;/*!< CH0_AL2_WRITE_ADDR_TRIG                                                 */
    } bit;
  } CH0_AL2_WRITE_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 0 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH0_AL3_CTRL : 32;         /*!< CH0_AL3_CTRL                                                              */
    } bit;
  } CH0_AL3_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 0 WRITE_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH0_AL3_WRITE_ADDR : 32;   /*!< CH0_AL3_WRITE_ADDR                                                        */
    } bit;
  } CH0_AL3_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 0 TRANS_COUNT register                                  */
    
    struct {
      __IOM uint32_t CH0_AL3_TRANS_COUNT : 32;  /*!< CH0_AL3_TRANS_COUNT                                                       */
    } bit;
  } CH0_AL3_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 0 READ_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH0_AL3_READ_ADDR_TRIG : 32;/*!< CH0_AL3_READ_ADDR_TRIG                                                   */
    } bit;
  } CH0_AL3_READ_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 1 Read Address pointer                                        */
    
    struct {
      __IOM uint32_t CH1_READ_ADDR : 32;        /*!< This register updates automatically each time a read completes.
                                                     The current value is the next address to be read by this
                                                     channel.                                                                  */
    } bit;
  } CH1_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 1 Write Address pointer                                       */
    
    struct {
      __IOM uint32_t CH1_WRITE_ADDR : 32;       /*!< This register updates automatically each time a write completes.
                                                     The current value is the next address to be written by
                                                     this channel.                                                             */
    } bit;
  } CH1_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 1 Transfer Count                                              */
    
    struct {
      __IOM uint32_t CH1_TRANS_COUNT : 32;      /*!< Program the number of bus transfers a channel will perform before
                                                     halting. Note that, if transfers are larger than one byte
                                                     in size, this is not equal to the number of bytes transferred
                                                     (see CTRL_DATA_SIZE). When the channel is active, reading
                                                     this register shows the number of transfers remaining,
                                                     updating automatically each time a write transfer completes.
                                                     Writing this register sets the RELOAD value for the transfer
                                                     counter. Each time this channel is triggered, the RELOAD
                                                     value is copied into the live transfer counter. The channel
                                                     can be started multiple times, and will perform the same
                                                     number of transfers each time, as programmed by most recent
                                                     write. The RELOAD value can be observed at CHx_DBG_TCR.
                                                     If TRANS_COUNT is used as a trigger, the written value
                                                     is used immediately as the length of the new transfer sequence,
                                                     as well as being written to RELOAD.                                       */
    } bit;
  } CH1_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 1 Control and Status                                          */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< DMA Channel Enable. When 1, the channel will respond to triggering
                                                     events, which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< HIGH_PRIORITY gives a channel preferential treatment in issue
                                                     scheduling: in each scheduling round, all high priority
                                                     channels are considered first, and then only a single low
                                                     priority channel, before returning to the high priority
                                                     channels. This only affects the order in which the DMA
                                                     schedules channels. The DMA's bus priority is not changed.
                                                     If the DMA is not saturated then a low priority channel
                                                     will see no loss of throughput.                                           */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< Set the size of each bus transfer (byte/halfword/word). READ_ADDR
                                                     and WRITE_ADDR advance by this amount (1/2/4 bytes) with
                                                     each transfer.                                                            */
      __IOM uint32_t INCR_READ  : 1;            /*!< If 1, the read address increments with each transfer. If 0,
                                                     each read is directed to the same, initial address. Generally
                                                     this should be disabled for peripheral-to-memory transfers.               */
      __IOM uint32_t INCR_WRITE : 1;            /*!< If 1, the write address increments with each transfer. If 0,
                                                     each write is directed to the same, initial address. Generally
                                                     this should be disabled for memory-to-peripheral transfers.               */
      __IOM uint32_t RING_SIZE  : 4;            /*!< Size of address wrap region. If 0, don't wrap. For values n
                                                     > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers. Ring sizes between
                                                     2 and 32768 bytes are possible. This can apply to either
                                                     read or write addresses, based on value of RING_SEL.                      */
      __IOM uint32_t RING_SEL   : 1;            /*!< Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< When this channel completes, it will trigger the channel indicated
                                                     by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.              */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< Select a Transfer Request signal. The channel uses the transfer
                                                     request signal to pace its data transfer rate. Sources
                                                     for TREQ signals are internal (TIMERS) or external (DREQ,
                                                     a Data Request from the system). 0x0 to 0x3a -> select
                                                     DREQ n as TREQ                                                            */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< In QUIET mode, the channel does not generate IRQs at the end
                                                     of every transfer block. Instead, an IRQ is raised when
                                                     NULL is written to a trigger register, indicating the end
                                                     of a control block chain. This reduces the number of interrupts
                                                     to be serviced by the CPU when transferring a DMA chain
                                                     of many small control blocks.                                             */
      __IOM uint32_t BSWAP      : 1;            /*!< Apply byte-swap transformation to DMA data. For byte data, this
                                                     has no effect. For halfword data, the two bytes of each
                                                     halfword are swapped. For word data, the four bytes of
                                                     each word are swapped to reverse order.                                   */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< If 1, this channel's data transfers are visible to the sniff
                                                     hardware, and each transfer will advance the state of the
                                                     checksum. This only applies if the sniff hardware is enabled,
                                                     and has this channel selected. This allows checksum to
                                                     be enabled or disabled on a per-control- block basis.                     */
      __IM  uint32_t BUSY       : 1;            /*!< This flag goes high when the channel starts a new transfer sequence,
                                                     and low when the last transfer of that sequence completes.
                                                     Clearing EN while BUSY is high pauses the channel, and
                                                     BUSY will stay high while paused. To terminate a sequence
                                                     early (and clear the BUSY flag), see CHAN_ABORT.                          */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< If 1, the channel received a write bus error. Write one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not be earlier, or more than
                                                     5 transfers later)                                                        */
      __IOM uint32_t READ_ERROR : 1;            /*!< If 1, the channel received a read bus error. Write one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not be earlier, or more than 3 transfers
                                                     later)                                                                    */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel
                                                     halts when it encounters any bus error, and always raises
                                                     its channel IRQ flag.                                                     */
    } bit;
  } CH1_CTRL_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 1 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH1_AL1_CTRL : 32;         /*!< CH1_AL1_CTRL                                                              */
    } bit;
  } CH1_AL1_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 1 READ_ADDR register                                    */
    
    struct {
      __IOM uint32_t CH1_AL1_READ_ADDR : 32;    /*!< CH1_AL1_READ_ADDR                                                         */
    } bit;
  } CH1_AL1_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 1 WRITE_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH1_AL1_WRITE_ADDR : 32;   /*!< CH1_AL1_WRITE_ADDR                                                        */
    } bit;
  } CH1_AL1_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 1 TRANS_COUNT register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH1_AL1_TRANS_COUNT_TRIG : 32;/*!< CH1_AL1_TRANS_COUNT_TRIG                                               */
    } bit;
  } CH1_AL1_TRANS_COUNT_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 1 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH1_AL2_CTRL : 32;         /*!< CH1_AL2_CTRL                                                              */
    } bit;
  } CH1_AL2_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 1 TRANS_COUNT register                                  */
    
    struct {
      __IOM uint32_t CH1_AL2_TRANS_COUNT : 32;  /*!< CH1_AL2_TRANS_COUNT                                                       */
    } bit;
  } CH1_AL2_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 1 READ_ADDR register                                    */
    
    struct {
      __IOM uint32_t CH1_AL2_READ_ADDR : 32;    /*!< CH1_AL2_READ_ADDR                                                         */
    } bit;
  } CH1_AL2_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 1 WRITE_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH1_AL2_WRITE_ADDR_TRIG : 32;/*!< CH1_AL2_WRITE_ADDR_TRIG                                                 */
    } bit;
  } CH1_AL2_WRITE_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 1 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH1_AL3_CTRL : 32;         /*!< CH1_AL3_CTRL                                                              */
    } bit;
  } CH1_AL3_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 1 WRITE_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH1_AL3_WRITE_ADDR : 32;   /*!< CH1_AL3_WRITE_ADDR                                                        */
    } bit;
  } CH1_AL3_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 1 TRANS_COUNT register                                  */
    
    struct {
      __IOM uint32_t CH1_AL3_TRANS_COUNT : 32;  /*!< CH1_AL3_TRANS_COUNT                                                       */
    } bit;
  } CH1_AL3_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 1 READ_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH1_AL3_READ_ADDR_TRIG : 32;/*!< CH1_AL3_READ_ADDR_TRIG                                                   */
    } bit;
  } CH1_AL3_READ_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 2 Read Address pointer                                        */
    
    struct {
      __IOM uint32_t CH2_READ_ADDR : 32;        /*!< This register updates automatically each time a read completes.
                                                     The current value is the next address to be read by this
                                                     channel.                                                                  */
    } bit;
  } CH2_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 2 Write Address pointer                                       */
    
    struct {
      __IOM uint32_t CH2_WRITE_ADDR : 32;       /*!< This register updates automatically each time a write completes.
                                                     The current value is the next address to be written by
                                                     this channel.                                                             */
    } bit;
  } CH2_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 2 Transfer Count                                              */
    
    struct {
      __IOM uint32_t CH2_TRANS_COUNT : 32;      /*!< Program the number of bus transfers a channel will perform before
                                                     halting. Note that, if transfers are larger than one byte
                                                     in size, this is not equal to the number of bytes transferred
                                                     (see CTRL_DATA_SIZE). When the channel is active, reading
                                                     this register shows the number of transfers remaining,
                                                     updating automatically each time a write transfer completes.
                                                     Writing this register sets the RELOAD value for the transfer
                                                     counter. Each time this channel is triggered, the RELOAD
                                                     value is copied into the live transfer counter. The channel
                                                     can be started multiple times, and will perform the same
                                                     number of transfers each time, as programmed by most recent
                                                     write. The RELOAD value can be observed at CHx_DBG_TCR.
                                                     If TRANS_COUNT is used as a trigger, the written value
                                                     is used immediately as the length of the new transfer sequence,
                                                     as well as being written to RELOAD.                                       */
    } bit;
  } CH2_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 2 Control and Status                                          */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< DMA Channel Enable. When 1, the channel will respond to triggering
                                                     events, which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< HIGH_PRIORITY gives a channel preferential treatment in issue
                                                     scheduling: in each scheduling round, all high priority
                                                     channels are considered first, and then only a single low
                                                     priority channel, before returning to the high priority
                                                     channels. This only affects the order in which the DMA
                                                     schedules channels. The DMA's bus priority is not changed.
                                                     If the DMA is not saturated then a low priority channel
                                                     will see no loss of throughput.                                           */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< Set the size of each bus transfer (byte/halfword/word). READ_ADDR
                                                     and WRITE_ADDR advance by this amount (1/2/4 bytes) with
                                                     each transfer.                                                            */
      __IOM uint32_t INCR_READ  : 1;            /*!< If 1, the read address increments with each transfer. If 0,
                                                     each read is directed to the same, initial address. Generally
                                                     this should be disabled for peripheral-to-memory transfers.               */
      __IOM uint32_t INCR_WRITE : 1;            /*!< If 1, the write address increments with each transfer. If 0,
                                                     each write is directed to the same, initial address. Generally
                                                     this should be disabled for memory-to-peripheral transfers.               */
      __IOM uint32_t RING_SIZE  : 4;            /*!< Size of address wrap region. If 0, don't wrap. For values n
                                                     > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers. Ring sizes between
                                                     2 and 32768 bytes are possible. This can apply to either
                                                     read or write addresses, based on value of RING_SEL.                      */
      __IOM uint32_t RING_SEL   : 1;            /*!< Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< When this channel completes, it will trigger the channel indicated
                                                     by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.              */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< Select a Transfer Request signal. The channel uses the transfer
                                                     request signal to pace its data transfer rate. Sources
                                                     for TREQ signals are internal (TIMERS) or external (DREQ,
                                                     a Data Request from the system). 0x0 to 0x3a -> select
                                                     DREQ n as TREQ                                                            */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< In QUIET mode, the channel does not generate IRQs at the end
                                                     of every transfer block. Instead, an IRQ is raised when
                                                     NULL is written to a trigger register, indicating the end
                                                     of a control block chain. This reduces the number of interrupts
                                                     to be serviced by the CPU when transferring a DMA chain
                                                     of many small control blocks.                                             */
      __IOM uint32_t BSWAP      : 1;            /*!< Apply byte-swap transformation to DMA data. For byte data, this
                                                     has no effect. For halfword data, the two bytes of each
                                                     halfword are swapped. For word data, the four bytes of
                                                     each word are swapped to reverse order.                                   */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< If 1, this channel's data transfers are visible to the sniff
                                                     hardware, and each transfer will advance the state of the
                                                     checksum. This only applies if the sniff hardware is enabled,
                                                     and has this channel selected. This allows checksum to
                                                     be enabled or disabled on a per-control- block basis.                     */
      __IM  uint32_t BUSY       : 1;            /*!< This flag goes high when the channel starts a new transfer sequence,
                                                     and low when the last transfer of that sequence completes.
                                                     Clearing EN while BUSY is high pauses the channel, and
                                                     BUSY will stay high while paused. To terminate a sequence
                                                     early (and clear the BUSY flag), see CHAN_ABORT.                          */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< If 1, the channel received a write bus error. Write one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not be earlier, or more than
                                                     5 transfers later)                                                        */
      __IOM uint32_t READ_ERROR : 1;            /*!< If 1, the channel received a read bus error. Write one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not be earlier, or more than 3 transfers
                                                     later)                                                                    */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel
                                                     halts when it encounters any bus error, and always raises
                                                     its channel IRQ flag.                                                     */
    } bit;
  } CH2_CTRL_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 2 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH2_AL1_CTRL : 32;         /*!< CH2_AL1_CTRL                                                              */
    } bit;
  } CH2_AL1_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 2 READ_ADDR register                                    */
    
    struct {
      __IOM uint32_t CH2_AL1_READ_ADDR : 32;    /*!< CH2_AL1_READ_ADDR                                                         */
    } bit;
  } CH2_AL1_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 2 WRITE_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH2_AL1_WRITE_ADDR : 32;   /*!< CH2_AL1_WRITE_ADDR                                                        */
    } bit;
  } CH2_AL1_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 2 TRANS_COUNT register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH2_AL1_TRANS_COUNT_TRIG : 32;/*!< CH2_AL1_TRANS_COUNT_TRIG                                               */
    } bit;
  } CH2_AL1_TRANS_COUNT_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 2 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH2_AL2_CTRL : 32;         /*!< CH2_AL2_CTRL                                                              */
    } bit;
  } CH2_AL2_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 2 TRANS_COUNT register                                  */
    
    struct {
      __IOM uint32_t CH2_AL2_TRANS_COUNT : 32;  /*!< CH2_AL2_TRANS_COUNT                                                       */
    } bit;
  } CH2_AL2_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 2 READ_ADDR register                                    */
    
    struct {
      __IOM uint32_t CH2_AL2_READ_ADDR : 32;    /*!< CH2_AL2_READ_ADDR                                                         */
    } bit;
  } CH2_AL2_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 2 WRITE_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH2_AL2_WRITE_ADDR_TRIG : 32;/*!< CH2_AL2_WRITE_ADDR_TRIG                                                 */
    } bit;
  } CH2_AL2_WRITE_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 2 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH2_AL3_CTRL : 32;         /*!< CH2_AL3_CTRL                                                              */
    } bit;
  } CH2_AL3_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 2 WRITE_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH2_AL3_WRITE_ADDR : 32;   /*!< CH2_AL3_WRITE_ADDR                                                        */
    } bit;
  } CH2_AL3_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 2 TRANS_COUNT register                                  */
    
    struct {
      __IOM uint32_t CH2_AL3_TRANS_COUNT : 32;  /*!< CH2_AL3_TRANS_COUNT                                                       */
    } bit;
  } CH2_AL3_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 2 READ_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH2_AL3_READ_ADDR_TRIG : 32;/*!< CH2_AL3_READ_ADDR_TRIG                                                   */
    } bit;
  } CH2_AL3_READ_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 3 Read Address pointer                                        */
    
    struct {
      __IOM uint32_t CH3_READ_ADDR : 32;        /*!< This register updates automatically each time a read completes.
                                                     The current value is the next address to be read by this
                                                     channel.                                                                  */
    } bit;
  } CH3_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 3 Write Address pointer                                       */
    
    struct {
      __IOM uint32_t CH3_WRITE_ADDR : 32;       /*!< This register updates automatically each time a write completes.
                                                     The current value is the next address to be written by
                                                     this channel.                                                             */
    } bit;
  } CH3_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 3 Transfer Count                                              */
    
    struct {
      __IOM uint32_t CH3_TRANS_COUNT : 32;      /*!< Program the number of bus transfers a channel will perform before
                                                     halting. Note that, if transfers are larger than one byte
                                                     in size, this is not equal to the number of bytes transferred
                                                     (see CTRL_DATA_SIZE). When the channel is active, reading
                                                     this register shows the number of transfers remaining,
                                                     updating automatically each time a write transfer completes.
                                                     Writing this register sets the RELOAD value for the transfer
                                                     counter. Each time this channel is triggered, the RELOAD
                                                     value is copied into the live transfer counter. The channel
                                                     can be started multiple times, and will perform the same
                                                     number of transfers each time, as programmed by most recent
                                                     write. The RELOAD value can be observed at CHx_DBG_TCR.
                                                     If TRANS_COUNT is used as a trigger, the written value
                                                     is used immediately as the length of the new transfer sequence,
                                                     as well as being written to RELOAD.                                       */
    } bit;
  } CH3_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 3 Control and Status                                          */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< DMA Channel Enable. When 1, the channel will respond to triggering
                                                     events, which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< HIGH_PRIORITY gives a channel preferential treatment in issue
                                                     scheduling: in each scheduling round, all high priority
                                                     channels are considered first, and then only a single low
                                                     priority channel, before returning to the high priority
                                                     channels. This only affects the order in which the DMA
                                                     schedules channels. The DMA's bus priority is not changed.
                                                     If the DMA is not saturated then a low priority channel
                                                     will see no loss of throughput.                                           */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< Set the size of each bus transfer (byte/halfword/word). READ_ADDR
                                                     and WRITE_ADDR advance by this amount (1/2/4 bytes) with
                                                     each transfer.                                                            */
      __IOM uint32_t INCR_READ  : 1;            /*!< If 1, the read address increments with each transfer. If 0,
                                                     each read is directed to the same, initial address. Generally
                                                     this should be disabled for peripheral-to-memory transfers.               */
      __IOM uint32_t INCR_WRITE : 1;            /*!< If 1, the write address increments with each transfer. If 0,
                                                     each write is directed to the same, initial address. Generally
                                                     this should be disabled for memory-to-peripheral transfers.               */
      __IOM uint32_t RING_SIZE  : 4;            /*!< Size of address wrap region. If 0, don't wrap. For values n
                                                     > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers. Ring sizes between
                                                     2 and 32768 bytes are possible. This can apply to either
                                                     read or write addresses, based on value of RING_SEL.                      */
      __IOM uint32_t RING_SEL   : 1;            /*!< Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< When this channel completes, it will trigger the channel indicated
                                                     by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.              */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< Select a Transfer Request signal. The channel uses the transfer
                                                     request signal to pace its data transfer rate. Sources
                                                     for TREQ signals are internal (TIMERS) or external (DREQ,
                                                     a Data Request from the system). 0x0 to 0x3a -> select
                                                     DREQ n as TREQ                                                            */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< In QUIET mode, the channel does not generate IRQs at the end
                                                     of every transfer block. Instead, an IRQ is raised when
                                                     NULL is written to a trigger register, indicating the end
                                                     of a control block chain. This reduces the number of interrupts
                                                     to be serviced by the CPU when transferring a DMA chain
                                                     of many small control blocks.                                             */
      __IOM uint32_t BSWAP      : 1;            /*!< Apply byte-swap transformation to DMA data. For byte data, this
                                                     has no effect. For halfword data, the two bytes of each
                                                     halfword are swapped. For word data, the four bytes of
                                                     each word are swapped to reverse order.                                   */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< If 1, this channel's data transfers are visible to the sniff
                                                     hardware, and each transfer will advance the state of the
                                                     checksum. This only applies if the sniff hardware is enabled,
                                                     and has this channel selected. This allows checksum to
                                                     be enabled or disabled on a per-control- block basis.                     */
      __IM  uint32_t BUSY       : 1;            /*!< This flag goes high when the channel starts a new transfer sequence,
                                                     and low when the last transfer of that sequence completes.
                                                     Clearing EN while BUSY is high pauses the channel, and
                                                     BUSY will stay high while paused. To terminate a sequence
                                                     early (and clear the BUSY flag), see CHAN_ABORT.                          */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< If 1, the channel received a write bus error. Write one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not be earlier, or more than
                                                     5 transfers later)                                                        */
      __IOM uint32_t READ_ERROR : 1;            /*!< If 1, the channel received a read bus error. Write one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not be earlier, or more than 3 transfers
                                                     later)                                                                    */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel
                                                     halts when it encounters any bus error, and always raises
                                                     its channel IRQ flag.                                                     */
    } bit;
  } CH3_CTRL_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 3 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH3_AL1_CTRL : 32;         /*!< CH3_AL1_CTRL                                                              */
    } bit;
  } CH3_AL1_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 3 READ_ADDR register                                    */
    
    struct {
      __IOM uint32_t CH3_AL1_READ_ADDR : 32;    /*!< CH3_AL1_READ_ADDR                                                         */
    } bit;
  } CH3_AL1_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 3 WRITE_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH3_AL1_WRITE_ADDR : 32;   /*!< CH3_AL1_WRITE_ADDR                                                        */
    } bit;
  } CH3_AL1_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 3 TRANS_COUNT register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH3_AL1_TRANS_COUNT_TRIG : 32;/*!< CH3_AL1_TRANS_COUNT_TRIG                                               */
    } bit;
  } CH3_AL1_TRANS_COUNT_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 3 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH3_AL2_CTRL : 32;         /*!< CH3_AL2_CTRL                                                              */
    } bit;
  } CH3_AL2_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 3 TRANS_COUNT register                                  */
    
    struct {
      __IOM uint32_t CH3_AL2_TRANS_COUNT : 32;  /*!< CH3_AL2_TRANS_COUNT                                                       */
    } bit;
  } CH3_AL2_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 3 READ_ADDR register                                    */
    
    struct {
      __IOM uint32_t CH3_AL2_READ_ADDR : 32;    /*!< CH3_AL2_READ_ADDR                                                         */
    } bit;
  } CH3_AL2_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 3 WRITE_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH3_AL2_WRITE_ADDR_TRIG : 32;/*!< CH3_AL2_WRITE_ADDR_TRIG                                                 */
    } bit;
  } CH3_AL2_WRITE_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 3 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH3_AL3_CTRL : 32;         /*!< CH3_AL3_CTRL                                                              */
    } bit;
  } CH3_AL3_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 3 WRITE_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH3_AL3_WRITE_ADDR : 32;   /*!< CH3_AL3_WRITE_ADDR                                                        */
    } bit;
  } CH3_AL3_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 3 TRANS_COUNT register                                  */
    
    struct {
      __IOM uint32_t CH3_AL3_TRANS_COUNT : 32;  /*!< CH3_AL3_TRANS_COUNT                                                       */
    } bit;
  } CH3_AL3_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 3 READ_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH3_AL3_READ_ADDR_TRIG : 32;/*!< CH3_AL3_READ_ADDR_TRIG                                                   */
    } bit;
  } CH3_AL3_READ_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 4 Read Address pointer                                        */
    
    struct {
      __IOM uint32_t CH4_READ_ADDR : 32;        /*!< This register updates automatically each time a read completes.
                                                     The current value is the next address to be read by this
                                                     channel.                                                                  */
    } bit;
  } CH4_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 4 Write Address pointer                                       */
    
    struct {
      __IOM uint32_t CH4_WRITE_ADDR : 32;       /*!< This register updates automatically each time a write completes.
                                                     The current value is the next address to be written by
                                                     this channel.                                                             */
    } bit;
  } CH4_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 4 Transfer Count                                              */
    
    struct {
      __IOM uint32_t CH4_TRANS_COUNT : 32;      /*!< Program the number of bus transfers a channel will perform before
                                                     halting. Note that, if transfers are larger than one byte
                                                     in size, this is not equal to the number of bytes transferred
                                                     (see CTRL_DATA_SIZE). When the channel is active, reading
                                                     this register shows the number of transfers remaining,
                                                     updating automatically each time a write transfer completes.
                                                     Writing this register sets the RELOAD value for the transfer
                                                     counter. Each time this channel is triggered, the RELOAD
                                                     value is copied into the live transfer counter. The channel
                                                     can be started multiple times, and will perform the same
                                                     number of transfers each time, as programmed by most recent
                                                     write. The RELOAD value can be observed at CHx_DBG_TCR.
                                                     If TRANS_COUNT is used as a trigger, the written value
                                                     is used immediately as the length of the new transfer sequence,
                                                     as well as being written to RELOAD.                                       */
    } bit;
  } CH4_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 4 Control and Status                                          */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< DMA Channel Enable. When 1, the channel will respond to triggering
                                                     events, which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< HIGH_PRIORITY gives a channel preferential treatment in issue
                                                     scheduling: in each scheduling round, all high priority
                                                     channels are considered first, and then only a single low
                                                     priority channel, before returning to the high priority
                                                     channels. This only affects the order in which the DMA
                                                     schedules channels. The DMA's bus priority is not changed.
                                                     If the DMA is not saturated then a low priority channel
                                                     will see no loss of throughput.                                           */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< Set the size of each bus transfer (byte/halfword/word). READ_ADDR
                                                     and WRITE_ADDR advance by this amount (1/2/4 bytes) with
                                                     each transfer.                                                            */
      __IOM uint32_t INCR_READ  : 1;            /*!< If 1, the read address increments with each transfer. If 0,
                                                     each read is directed to the same, initial address. Generally
                                                     this should be disabled for peripheral-to-memory transfers.               */
      __IOM uint32_t INCR_WRITE : 1;            /*!< If 1, the write address increments with each transfer. If 0,
                                                     each write is directed to the same, initial address. Generally
                                                     this should be disabled for memory-to-peripheral transfers.               */
      __IOM uint32_t RING_SIZE  : 4;            /*!< Size of address wrap region. If 0, don't wrap. For values n
                                                     > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers. Ring sizes between
                                                     2 and 32768 bytes are possible. This can apply to either
                                                     read or write addresses, based on value of RING_SEL.                      */
      __IOM uint32_t RING_SEL   : 1;            /*!< Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< When this channel completes, it will trigger the channel indicated
                                                     by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.              */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< Select a Transfer Request signal. The channel uses the transfer
                                                     request signal to pace its data transfer rate. Sources
                                                     for TREQ signals are internal (TIMERS) or external (DREQ,
                                                     a Data Request from the system). 0x0 to 0x3a -> select
                                                     DREQ n as TREQ                                                            */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< In QUIET mode, the channel does not generate IRQs at the end
                                                     of every transfer block. Instead, an IRQ is raised when
                                                     NULL is written to a trigger register, indicating the end
                                                     of a control block chain. This reduces the number of interrupts
                                                     to be serviced by the CPU when transferring a DMA chain
                                                     of many small control blocks.                                             */
      __IOM uint32_t BSWAP      : 1;            /*!< Apply byte-swap transformation to DMA data. For byte data, this
                                                     has no effect. For halfword data, the two bytes of each
                                                     halfword are swapped. For word data, the four bytes of
                                                     each word are swapped to reverse order.                                   */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< If 1, this channel's data transfers are visible to the sniff
                                                     hardware, and each transfer will advance the state of the
                                                     checksum. This only applies if the sniff hardware is enabled,
                                                     and has this channel selected. This allows checksum to
                                                     be enabled or disabled on a per-control- block basis.                     */
      __IM  uint32_t BUSY       : 1;            /*!< This flag goes high when the channel starts a new transfer sequence,
                                                     and low when the last transfer of that sequence completes.
                                                     Clearing EN while BUSY is high pauses the channel, and
                                                     BUSY will stay high while paused. To terminate a sequence
                                                     early (and clear the BUSY flag), see CHAN_ABORT.                          */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< If 1, the channel received a write bus error. Write one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not be earlier, or more than
                                                     5 transfers later)                                                        */
      __IOM uint32_t READ_ERROR : 1;            /*!< If 1, the channel received a read bus error. Write one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not be earlier, or more than 3 transfers
                                                     later)                                                                    */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel
                                                     halts when it encounters any bus error, and always raises
                                                     its channel IRQ flag.                                                     */
    } bit;
  } CH4_CTRL_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 4 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH4_AL1_CTRL : 32;         /*!< CH4_AL1_CTRL                                                              */
    } bit;
  } CH4_AL1_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 4 READ_ADDR register                                    */
    
    struct {
      __IOM uint32_t CH4_AL1_READ_ADDR : 32;    /*!< CH4_AL1_READ_ADDR                                                         */
    } bit;
  } CH4_AL1_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 4 WRITE_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH4_AL1_WRITE_ADDR : 32;   /*!< CH4_AL1_WRITE_ADDR                                                        */
    } bit;
  } CH4_AL1_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 4 TRANS_COUNT register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH4_AL1_TRANS_COUNT_TRIG : 32;/*!< CH4_AL1_TRANS_COUNT_TRIG                                               */
    } bit;
  } CH4_AL1_TRANS_COUNT_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 4 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH4_AL2_CTRL : 32;         /*!< CH4_AL2_CTRL                                                              */
    } bit;
  } CH4_AL2_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 4 TRANS_COUNT register                                  */
    
    struct {
      __IOM uint32_t CH4_AL2_TRANS_COUNT : 32;  /*!< CH4_AL2_TRANS_COUNT                                                       */
    } bit;
  } CH4_AL2_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 4 READ_ADDR register                                    */
    
    struct {
      __IOM uint32_t CH4_AL2_READ_ADDR : 32;    /*!< CH4_AL2_READ_ADDR                                                         */
    } bit;
  } CH4_AL2_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 4 WRITE_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH4_AL2_WRITE_ADDR_TRIG : 32;/*!< CH4_AL2_WRITE_ADDR_TRIG                                                 */
    } bit;
  } CH4_AL2_WRITE_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 4 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH4_AL3_CTRL : 32;         /*!< CH4_AL3_CTRL                                                              */
    } bit;
  } CH4_AL3_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 4 WRITE_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH4_AL3_WRITE_ADDR : 32;   /*!< CH4_AL3_WRITE_ADDR                                                        */
    } bit;
  } CH4_AL3_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 4 TRANS_COUNT register                                  */
    
    struct {
      __IOM uint32_t CH4_AL3_TRANS_COUNT : 32;  /*!< CH4_AL3_TRANS_COUNT                                                       */
    } bit;
  } CH4_AL3_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 4 READ_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH4_AL3_READ_ADDR_TRIG : 32;/*!< CH4_AL3_READ_ADDR_TRIG                                                   */
    } bit;
  } CH4_AL3_READ_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 5 Read Address pointer                                        */
    
    struct {
      __IOM uint32_t CH5_READ_ADDR : 32;        /*!< This register updates automatically each time a read completes.
                                                     The current value is the next address to be read by this
                                                     channel.                                                                  */
    } bit;
  } CH5_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 5 Write Address pointer                                       */
    
    struct {
      __IOM uint32_t CH5_WRITE_ADDR : 32;       /*!< This register updates automatically each time a write completes.
                                                     The current value is the next address to be written by
                                                     this channel.                                                             */
    } bit;
  } CH5_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 5 Transfer Count                                              */
    
    struct {
      __IOM uint32_t CH5_TRANS_COUNT : 32;      /*!< Program the number of bus transfers a channel will perform before
                                                     halting. Note that, if transfers are larger than one byte
                                                     in size, this is not equal to the number of bytes transferred
                                                     (see CTRL_DATA_SIZE). When the channel is active, reading
                                                     this register shows the number of transfers remaining,
                                                     updating automatically each time a write transfer completes.
                                                     Writing this register sets the RELOAD value for the transfer
                                                     counter. Each time this channel is triggered, the RELOAD
                                                     value is copied into the live transfer counter. The channel
                                                     can be started multiple times, and will perform the same
                                                     number of transfers each time, as programmed by most recent
                                                     write. The RELOAD value can be observed at CHx_DBG_TCR.
                                                     If TRANS_COUNT is used as a trigger, the written value
                                                     is used immediately as the length of the new transfer sequence,
                                                     as well as being written to RELOAD.                                       */
    } bit;
  } CH5_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 5 Control and Status                                          */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< DMA Channel Enable. When 1, the channel will respond to triggering
                                                     events, which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< HIGH_PRIORITY gives a channel preferential treatment in issue
                                                     scheduling: in each scheduling round, all high priority
                                                     channels are considered first, and then only a single low
                                                     priority channel, before returning to the high priority
                                                     channels. This only affects the order in which the DMA
                                                     schedules channels. The DMA's bus priority is not changed.
                                                     If the DMA is not saturated then a low priority channel
                                                     will see no loss of throughput.                                           */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< Set the size of each bus transfer (byte/halfword/word). READ_ADDR
                                                     and WRITE_ADDR advance by this amount (1/2/4 bytes) with
                                                     each transfer.                                                            */
      __IOM uint32_t INCR_READ  : 1;            /*!< If 1, the read address increments with each transfer. If 0,
                                                     each read is directed to the same, initial address. Generally
                                                     this should be disabled for peripheral-to-memory transfers.               */
      __IOM uint32_t INCR_WRITE : 1;            /*!< If 1, the write address increments with each transfer. If 0,
                                                     each write is directed to the same, initial address. Generally
                                                     this should be disabled for memory-to-peripheral transfers.               */
      __IOM uint32_t RING_SIZE  : 4;            /*!< Size of address wrap region. If 0, don't wrap. For values n
                                                     > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers. Ring sizes between
                                                     2 and 32768 bytes are possible. This can apply to either
                                                     read or write addresses, based on value of RING_SEL.                      */
      __IOM uint32_t RING_SEL   : 1;            /*!< Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< When this channel completes, it will trigger the channel indicated
                                                     by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.              */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< Select a Transfer Request signal. The channel uses the transfer
                                                     request signal to pace its data transfer rate. Sources
                                                     for TREQ signals are internal (TIMERS) or external (DREQ,
                                                     a Data Request from the system). 0x0 to 0x3a -> select
                                                     DREQ n as TREQ                                                            */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< In QUIET mode, the channel does not generate IRQs at the end
                                                     of every transfer block. Instead, an IRQ is raised when
                                                     NULL is written to a trigger register, indicating the end
                                                     of a control block chain. This reduces the number of interrupts
                                                     to be serviced by the CPU when transferring a DMA chain
                                                     of many small control blocks.                                             */
      __IOM uint32_t BSWAP      : 1;            /*!< Apply byte-swap transformation to DMA data. For byte data, this
                                                     has no effect. For halfword data, the two bytes of each
                                                     halfword are swapped. For word data, the four bytes of
                                                     each word are swapped to reverse order.                                   */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< If 1, this channel's data transfers are visible to the sniff
                                                     hardware, and each transfer will advance the state of the
                                                     checksum. This only applies if the sniff hardware is enabled,
                                                     and has this channel selected. This allows checksum to
                                                     be enabled or disabled on a per-control- block basis.                     */
      __IM  uint32_t BUSY       : 1;            /*!< This flag goes high when the channel starts a new transfer sequence,
                                                     and low when the last transfer of that sequence completes.
                                                     Clearing EN while BUSY is high pauses the channel, and
                                                     BUSY will stay high while paused. To terminate a sequence
                                                     early (and clear the BUSY flag), see CHAN_ABORT.                          */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< If 1, the channel received a write bus error. Write one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not be earlier, or more than
                                                     5 transfers later)                                                        */
      __IOM uint32_t READ_ERROR : 1;            /*!< If 1, the channel received a read bus error. Write one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not be earlier, or more than 3 transfers
                                                     later)                                                                    */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel
                                                     halts when it encounters any bus error, and always raises
                                                     its channel IRQ flag.                                                     */
    } bit;
  } CH5_CTRL_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 5 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH5_AL1_CTRL : 32;         /*!< CH5_AL1_CTRL                                                              */
    } bit;
  } CH5_AL1_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 5 READ_ADDR register                                    */
    
    struct {
      __IOM uint32_t CH5_AL1_READ_ADDR : 32;    /*!< CH5_AL1_READ_ADDR                                                         */
    } bit;
  } CH5_AL1_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 5 WRITE_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH5_AL1_WRITE_ADDR : 32;   /*!< CH5_AL1_WRITE_ADDR                                                        */
    } bit;
  } CH5_AL1_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 5 TRANS_COUNT register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH5_AL1_TRANS_COUNT_TRIG : 32;/*!< CH5_AL1_TRANS_COUNT_TRIG                                               */
    } bit;
  } CH5_AL1_TRANS_COUNT_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 5 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH5_AL2_CTRL : 32;         /*!< CH5_AL2_CTRL                                                              */
    } bit;
  } CH5_AL2_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 5 TRANS_COUNT register                                  */
    
    struct {
      __IOM uint32_t CH5_AL2_TRANS_COUNT : 32;  /*!< CH5_AL2_TRANS_COUNT                                                       */
    } bit;
  } CH5_AL2_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 5 READ_ADDR register                                    */
    
    struct {
      __IOM uint32_t CH5_AL2_READ_ADDR : 32;    /*!< CH5_AL2_READ_ADDR                                                         */
    } bit;
  } CH5_AL2_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 5 WRITE_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH5_AL2_WRITE_ADDR_TRIG : 32;/*!< CH5_AL2_WRITE_ADDR_TRIG                                                 */
    } bit;
  } CH5_AL2_WRITE_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 5 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH5_AL3_CTRL : 32;         /*!< CH5_AL3_CTRL                                                              */
    } bit;
  } CH5_AL3_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 5 WRITE_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH5_AL3_WRITE_ADDR : 32;   /*!< CH5_AL3_WRITE_ADDR                                                        */
    } bit;
  } CH5_AL3_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 5 TRANS_COUNT register                                  */
    
    struct {
      __IOM uint32_t CH5_AL3_TRANS_COUNT : 32;  /*!< CH5_AL3_TRANS_COUNT                                                       */
    } bit;
  } CH5_AL3_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 5 READ_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH5_AL3_READ_ADDR_TRIG : 32;/*!< CH5_AL3_READ_ADDR_TRIG                                                   */
    } bit;
  } CH5_AL3_READ_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 6 Read Address pointer                                        */
    
    struct {
      __IOM uint32_t CH6_READ_ADDR : 32;        /*!< This register updates automatically each time a read completes.
                                                     The current value is the next address to be read by this
                                                     channel.                                                                  */
    } bit;
  } CH6_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 6 Write Address pointer                                       */
    
    struct {
      __IOM uint32_t CH6_WRITE_ADDR : 32;       /*!< This register updates automatically each time a write completes.
                                                     The current value is the next address to be written by
                                                     this channel.                                                             */
    } bit;
  } CH6_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 6 Transfer Count                                              */
    
    struct {
      __IOM uint32_t CH6_TRANS_COUNT : 32;      /*!< Program the number of bus transfers a channel will perform before
                                                     halting. Note that, if transfers are larger than one byte
                                                     in size, this is not equal to the number of bytes transferred
                                                     (see CTRL_DATA_SIZE). When the channel is active, reading
                                                     this register shows the number of transfers remaining,
                                                     updating automatically each time a write transfer completes.
                                                     Writing this register sets the RELOAD value for the transfer
                                                     counter. Each time this channel is triggered, the RELOAD
                                                     value is copied into the live transfer counter. The channel
                                                     can be started multiple times, and will perform the same
                                                     number of transfers each time, as programmed by most recent
                                                     write. The RELOAD value can be observed at CHx_DBG_TCR.
                                                     If TRANS_COUNT is used as a trigger, the written value
                                                     is used immediately as the length of the new transfer sequence,
                                                     as well as being written to RELOAD.                                       */
    } bit;
  } CH6_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 6 Control and Status                                          */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< DMA Channel Enable. When 1, the channel will respond to triggering
                                                     events, which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< HIGH_PRIORITY gives a channel preferential treatment in issue
                                                     scheduling: in each scheduling round, all high priority
                                                     channels are considered first, and then only a single low
                                                     priority channel, before returning to the high priority
                                                     channels. This only affects the order in which the DMA
                                                     schedules channels. The DMA's bus priority is not changed.
                                                     If the DMA is not saturated then a low priority channel
                                                     will see no loss of throughput.                                           */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< Set the size of each bus transfer (byte/halfword/word). READ_ADDR
                                                     and WRITE_ADDR advance by this amount (1/2/4 bytes) with
                                                     each transfer.                                                            */
      __IOM uint32_t INCR_READ  : 1;            /*!< If 1, the read address increments with each transfer. If 0,
                                                     each read is directed to the same, initial address. Generally
                                                     this should be disabled for peripheral-to-memory transfers.               */
      __IOM uint32_t INCR_WRITE : 1;            /*!< If 1, the write address increments with each transfer. If 0,
                                                     each write is directed to the same, initial address. Generally
                                                     this should be disabled for memory-to-peripheral transfers.               */
      __IOM uint32_t RING_SIZE  : 4;            /*!< Size of address wrap region. If 0, don't wrap. For values n
                                                     > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers. Ring sizes between
                                                     2 and 32768 bytes are possible. This can apply to either
                                                     read or write addresses, based on value of RING_SEL.                      */
      __IOM uint32_t RING_SEL   : 1;            /*!< Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< When this channel completes, it will trigger the channel indicated
                                                     by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.              */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< Select a Transfer Request signal. The channel uses the transfer
                                                     request signal to pace its data transfer rate. Sources
                                                     for TREQ signals are internal (TIMERS) or external (DREQ,
                                                     a Data Request from the system). 0x0 to 0x3a -> select
                                                     DREQ n as TREQ                                                            */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< In QUIET mode, the channel does not generate IRQs at the end
                                                     of every transfer block. Instead, an IRQ is raised when
                                                     NULL is written to a trigger register, indicating the end
                                                     of a control block chain. This reduces the number of interrupts
                                                     to be serviced by the CPU when transferring a DMA chain
                                                     of many small control blocks.                                             */
      __IOM uint32_t BSWAP      : 1;            /*!< Apply byte-swap transformation to DMA data. For byte data, this
                                                     has no effect. For halfword data, the two bytes of each
                                                     halfword are swapped. For word data, the four bytes of
                                                     each word are swapped to reverse order.                                   */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< If 1, this channel's data transfers are visible to the sniff
                                                     hardware, and each transfer will advance the state of the
                                                     checksum. This only applies if the sniff hardware is enabled,
                                                     and has this channel selected. This allows checksum to
                                                     be enabled or disabled on a per-control- block basis.                     */
      __IM  uint32_t BUSY       : 1;            /*!< This flag goes high when the channel starts a new transfer sequence,
                                                     and low when the last transfer of that sequence completes.
                                                     Clearing EN while BUSY is high pauses the channel, and
                                                     BUSY will stay high while paused. To terminate a sequence
                                                     early (and clear the BUSY flag), see CHAN_ABORT.                          */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< If 1, the channel received a write bus error. Write one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not be earlier, or more than
                                                     5 transfers later)                                                        */
      __IOM uint32_t READ_ERROR : 1;            /*!< If 1, the channel received a read bus error. Write one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not be earlier, or more than 3 transfers
                                                     later)                                                                    */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel
                                                     halts when it encounters any bus error, and always raises
                                                     its channel IRQ flag.                                                     */
    } bit;
  } CH6_CTRL_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 6 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH6_AL1_CTRL : 32;         /*!< CH6_AL1_CTRL                                                              */
    } bit;
  } CH6_AL1_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 6 READ_ADDR register                                    */
    
    struct {
      __IOM uint32_t CH6_AL1_READ_ADDR : 32;    /*!< CH6_AL1_READ_ADDR                                                         */
    } bit;
  } CH6_AL1_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 6 WRITE_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH6_AL1_WRITE_ADDR : 32;   /*!< CH6_AL1_WRITE_ADDR                                                        */
    } bit;
  } CH6_AL1_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 6 TRANS_COUNT register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH6_AL1_TRANS_COUNT_TRIG : 32;/*!< CH6_AL1_TRANS_COUNT_TRIG                                               */
    } bit;
  } CH6_AL1_TRANS_COUNT_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 6 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH6_AL2_CTRL : 32;         /*!< CH6_AL2_CTRL                                                              */
    } bit;
  } CH6_AL2_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 6 TRANS_COUNT register                                  */
    
    struct {
      __IOM uint32_t CH6_AL2_TRANS_COUNT : 32;  /*!< CH6_AL2_TRANS_COUNT                                                       */
    } bit;
  } CH6_AL2_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 6 READ_ADDR register                                    */
    
    struct {
      __IOM uint32_t CH6_AL2_READ_ADDR : 32;    /*!< CH6_AL2_READ_ADDR                                                         */
    } bit;
  } CH6_AL2_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 6 WRITE_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH6_AL2_WRITE_ADDR_TRIG : 32;/*!< CH6_AL2_WRITE_ADDR_TRIG                                                 */
    } bit;
  } CH6_AL2_WRITE_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 6 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH6_AL3_CTRL : 32;         /*!< CH6_AL3_CTRL                                                              */
    } bit;
  } CH6_AL3_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 6 WRITE_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH6_AL3_WRITE_ADDR : 32;   /*!< CH6_AL3_WRITE_ADDR                                                        */
    } bit;
  } CH6_AL3_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 6 TRANS_COUNT register                                  */
    
    struct {
      __IOM uint32_t CH6_AL3_TRANS_COUNT : 32;  /*!< CH6_AL3_TRANS_COUNT                                                       */
    } bit;
  } CH6_AL3_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 6 READ_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH6_AL3_READ_ADDR_TRIG : 32;/*!< CH6_AL3_READ_ADDR_TRIG                                                   */
    } bit;
  } CH6_AL3_READ_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 7 Read Address pointer                                        */
    
    struct {
      __IOM uint32_t CH7_READ_ADDR : 32;        /*!< This register updates automatically each time a read completes.
                                                     The current value is the next address to be read by this
                                                     channel.                                                                  */
    } bit;
  } CH7_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 7 Write Address pointer                                       */
    
    struct {
      __IOM uint32_t CH7_WRITE_ADDR : 32;       /*!< This register updates automatically each time a write completes.
                                                     The current value is the next address to be written by
                                                     this channel.                                                             */
    } bit;
  } CH7_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 7 Transfer Count                                              */
    
    struct {
      __IOM uint32_t CH7_TRANS_COUNT : 32;      /*!< Program the number of bus transfers a channel will perform before
                                                     halting. Note that, if transfers are larger than one byte
                                                     in size, this is not equal to the number of bytes transferred
                                                     (see CTRL_DATA_SIZE). When the channel is active, reading
                                                     this register shows the number of transfers remaining,
                                                     updating automatically each time a write transfer completes.
                                                     Writing this register sets the RELOAD value for the transfer
                                                     counter. Each time this channel is triggered, the RELOAD
                                                     value is copied into the live transfer counter. The channel
                                                     can be started multiple times, and will perform the same
                                                     number of transfers each time, as programmed by most recent
                                                     write. The RELOAD value can be observed at CHx_DBG_TCR.
                                                     If TRANS_COUNT is used as a trigger, the written value
                                                     is used immediately as the length of the new transfer sequence,
                                                     as well as being written to RELOAD.                                       */
    } bit;
  } CH7_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 7 Control and Status                                          */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< DMA Channel Enable. When 1, the channel will respond to triggering
                                                     events, which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< HIGH_PRIORITY gives a channel preferential treatment in issue
                                                     scheduling: in each scheduling round, all high priority
                                                     channels are considered first, and then only a single low
                                                     priority channel, before returning to the high priority
                                                     channels. This only affects the order in which the DMA
                                                     schedules channels. The DMA's bus priority is not changed.
                                                     If the DMA is not saturated then a low priority channel
                                                     will see no loss of throughput.                                           */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< Set the size of each bus transfer (byte/halfword/word). READ_ADDR
                                                     and WRITE_ADDR advance by this amount (1/2/4 bytes) with
                                                     each transfer.                                                            */
      __IOM uint32_t INCR_READ  : 1;            /*!< If 1, the read address increments with each transfer. If 0,
                                                     each read is directed to the same, initial address. Generally
                                                     this should be disabled for peripheral-to-memory transfers.               */
      __IOM uint32_t INCR_WRITE : 1;            /*!< If 1, the write address increments with each transfer. If 0,
                                                     each write is directed to the same, initial address. Generally
                                                     this should be disabled for memory-to-peripheral transfers.               */
      __IOM uint32_t RING_SIZE  : 4;            /*!< Size of address wrap region. If 0, don't wrap. For values n
                                                     > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers. Ring sizes between
                                                     2 and 32768 bytes are possible. This can apply to either
                                                     read or write addresses, based on value of RING_SEL.                      */
      __IOM uint32_t RING_SEL   : 1;            /*!< Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< When this channel completes, it will trigger the channel indicated
                                                     by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.              */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< Select a Transfer Request signal. The channel uses the transfer
                                                     request signal to pace its data transfer rate. Sources
                                                     for TREQ signals are internal (TIMERS) or external (DREQ,
                                                     a Data Request from the system). 0x0 to 0x3a -> select
                                                     DREQ n as TREQ                                                            */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< In QUIET mode, the channel does not generate IRQs at the end
                                                     of every transfer block. Instead, an IRQ is raised when
                                                     NULL is written to a trigger register, indicating the end
                                                     of a control block chain. This reduces the number of interrupts
                                                     to be serviced by the CPU when transferring a DMA chain
                                                     of many small control blocks.                                             */
      __IOM uint32_t BSWAP      : 1;            /*!< Apply byte-swap transformation to DMA data. For byte data, this
                                                     has no effect. For halfword data, the two bytes of each
                                                     halfword are swapped. For word data, the four bytes of
                                                     each word are swapped to reverse order.                                   */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< If 1, this channel's data transfers are visible to the sniff
                                                     hardware, and each transfer will advance the state of the
                                                     checksum. This only applies if the sniff hardware is enabled,
                                                     and has this channel selected. This allows checksum to
                                                     be enabled or disabled on a per-control- block basis.                     */
      __IM  uint32_t BUSY       : 1;            /*!< This flag goes high when the channel starts a new transfer sequence,
                                                     and low when the last transfer of that sequence completes.
                                                     Clearing EN while BUSY is high pauses the channel, and
                                                     BUSY will stay high while paused. To terminate a sequence
                                                     early (and clear the BUSY flag), see CHAN_ABORT.                          */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< If 1, the channel received a write bus error. Write one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not be earlier, or more than
                                                     5 transfers later)                                                        */
      __IOM uint32_t READ_ERROR : 1;            /*!< If 1, the channel received a read bus error. Write one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not be earlier, or more than 3 transfers
                                                     later)                                                                    */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel
                                                     halts when it encounters any bus error, and always raises
                                                     its channel IRQ flag.                                                     */
    } bit;
  } CH7_CTRL_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 7 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH7_AL1_CTRL : 32;         /*!< CH7_AL1_CTRL                                                              */
    } bit;
  } CH7_AL1_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 7 READ_ADDR register                                    */
    
    struct {
      __IOM uint32_t CH7_AL1_READ_ADDR : 32;    /*!< CH7_AL1_READ_ADDR                                                         */
    } bit;
  } CH7_AL1_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 7 WRITE_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH7_AL1_WRITE_ADDR : 32;   /*!< CH7_AL1_WRITE_ADDR                                                        */
    } bit;
  } CH7_AL1_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 7 TRANS_COUNT register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH7_AL1_TRANS_COUNT_TRIG : 32;/*!< CH7_AL1_TRANS_COUNT_TRIG                                               */
    } bit;
  } CH7_AL1_TRANS_COUNT_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 7 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH7_AL2_CTRL : 32;         /*!< CH7_AL2_CTRL                                                              */
    } bit;
  } CH7_AL2_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 7 TRANS_COUNT register                                  */
    
    struct {
      __IOM uint32_t CH7_AL2_TRANS_COUNT : 32;  /*!< CH7_AL2_TRANS_COUNT                                                       */
    } bit;
  } CH7_AL2_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 7 READ_ADDR register                                    */
    
    struct {
      __IOM uint32_t CH7_AL2_READ_ADDR : 32;    /*!< CH7_AL2_READ_ADDR                                                         */
    } bit;
  } CH7_AL2_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 7 WRITE_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH7_AL2_WRITE_ADDR_TRIG : 32;/*!< CH7_AL2_WRITE_ADDR_TRIG                                                 */
    } bit;
  } CH7_AL2_WRITE_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 7 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH7_AL3_CTRL : 32;         /*!< CH7_AL3_CTRL                                                              */
    } bit;
  } CH7_AL3_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 7 WRITE_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH7_AL3_WRITE_ADDR : 32;   /*!< CH7_AL3_WRITE_ADDR                                                        */
    } bit;
  } CH7_AL3_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 7 TRANS_COUNT register                                  */
    
    struct {
      __IOM uint32_t CH7_AL3_TRANS_COUNT : 32;  /*!< CH7_AL3_TRANS_COUNT                                                       */
    } bit;
  } CH7_AL3_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 7 READ_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH7_AL3_READ_ADDR_TRIG : 32;/*!< CH7_AL3_READ_ADDR_TRIG                                                   */
    } bit;
  } CH7_AL3_READ_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 8 Read Address pointer                                        */
    
    struct {
      __IOM uint32_t CH8_READ_ADDR : 32;        /*!< This register updates automatically each time a read completes.
                                                     The current value is the next address to be read by this
                                                     channel.                                                                  */
    } bit;
  } CH8_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 8 Write Address pointer                                       */
    
    struct {
      __IOM uint32_t CH8_WRITE_ADDR : 32;       /*!< This register updates automatically each time a write completes.
                                                     The current value is the next address to be written by
                                                     this channel.                                                             */
    } bit;
  } CH8_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 8 Transfer Count                                              */
    
    struct {
      __IOM uint32_t CH8_TRANS_COUNT : 32;      /*!< Program the number of bus transfers a channel will perform before
                                                     halting. Note that, if transfers are larger than one byte
                                                     in size, this is not equal to the number of bytes transferred
                                                     (see CTRL_DATA_SIZE). When the channel is active, reading
                                                     this register shows the number of transfers remaining,
                                                     updating automatically each time a write transfer completes.
                                                     Writing this register sets the RELOAD value for the transfer
                                                     counter. Each time this channel is triggered, the RELOAD
                                                     value is copied into the live transfer counter. The channel
                                                     can be started multiple times, and will perform the same
                                                     number of transfers each time, as programmed by most recent
                                                     write. The RELOAD value can be observed at CHx_DBG_TCR.
                                                     If TRANS_COUNT is used as a trigger, the written value
                                                     is used immediately as the length of the new transfer sequence,
                                                     as well as being written to RELOAD.                                       */
    } bit;
  } CH8_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 8 Control and Status                                          */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< DMA Channel Enable. When 1, the channel will respond to triggering
                                                     events, which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< HIGH_PRIORITY gives a channel preferential treatment in issue
                                                     scheduling: in each scheduling round, all high priority
                                                     channels are considered first, and then only a single low
                                                     priority channel, before returning to the high priority
                                                     channels. This only affects the order in which the DMA
                                                     schedules channels. The DMA's bus priority is not changed.
                                                     If the DMA is not saturated then a low priority channel
                                                     will see no loss of throughput.                                           */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< Set the size of each bus transfer (byte/halfword/word). READ_ADDR
                                                     and WRITE_ADDR advance by this amount (1/2/4 bytes) with
                                                     each transfer.                                                            */
      __IOM uint32_t INCR_READ  : 1;            /*!< If 1, the read address increments with each transfer. If 0,
                                                     each read is directed to the same, initial address. Generally
                                                     this should be disabled for peripheral-to-memory transfers.               */
      __IOM uint32_t INCR_WRITE : 1;            /*!< If 1, the write address increments with each transfer. If 0,
                                                     each write is directed to the same, initial address. Generally
                                                     this should be disabled for memory-to-peripheral transfers.               */
      __IOM uint32_t RING_SIZE  : 4;            /*!< Size of address wrap region. If 0, don't wrap. For values n
                                                     > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers. Ring sizes between
                                                     2 and 32768 bytes are possible. This can apply to either
                                                     read or write addresses, based on value of RING_SEL.                      */
      __IOM uint32_t RING_SEL   : 1;            /*!< Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< When this channel completes, it will trigger the channel indicated
                                                     by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.              */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< Select a Transfer Request signal. The channel uses the transfer
                                                     request signal to pace its data transfer rate. Sources
                                                     for TREQ signals are internal (TIMERS) or external (DREQ,
                                                     a Data Request from the system). 0x0 to 0x3a -> select
                                                     DREQ n as TREQ                                                            */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< In QUIET mode, the channel does not generate IRQs at the end
                                                     of every transfer block. Instead, an IRQ is raised when
                                                     NULL is written to a trigger register, indicating the end
                                                     of a control block chain. This reduces the number of interrupts
                                                     to be serviced by the CPU when transferring a DMA chain
                                                     of many small control blocks.                                             */
      __IOM uint32_t BSWAP      : 1;            /*!< Apply byte-swap transformation to DMA data. For byte data, this
                                                     has no effect. For halfword data, the two bytes of each
                                                     halfword are swapped. For word data, the four bytes of
                                                     each word are swapped to reverse order.                                   */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< If 1, this channel's data transfers are visible to the sniff
                                                     hardware, and each transfer will advance the state of the
                                                     checksum. This only applies if the sniff hardware is enabled,
                                                     and has this channel selected. This allows checksum to
                                                     be enabled or disabled on a per-control- block basis.                     */
      __IM  uint32_t BUSY       : 1;            /*!< This flag goes high when the channel starts a new transfer sequence,
                                                     and low when the last transfer of that sequence completes.
                                                     Clearing EN while BUSY is high pauses the channel, and
                                                     BUSY will stay high while paused. To terminate a sequence
                                                     early (and clear the BUSY flag), see CHAN_ABORT.                          */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< If 1, the channel received a write bus error. Write one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not be earlier, or more than
                                                     5 transfers later)                                                        */
      __IOM uint32_t READ_ERROR : 1;            /*!< If 1, the channel received a read bus error. Write one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not be earlier, or more than 3 transfers
                                                     later)                                                                    */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel
                                                     halts when it encounters any bus error, and always raises
                                                     its channel IRQ flag.                                                     */
    } bit;
  } CH8_CTRL_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 8 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH8_AL1_CTRL : 32;         /*!< CH8_AL1_CTRL                                                              */
    } bit;
  } CH8_AL1_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 8 READ_ADDR register                                    */
    
    struct {
      __IOM uint32_t CH8_AL1_READ_ADDR : 32;    /*!< CH8_AL1_READ_ADDR                                                         */
    } bit;
  } CH8_AL1_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 8 WRITE_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH8_AL1_WRITE_ADDR : 32;   /*!< CH8_AL1_WRITE_ADDR                                                        */
    } bit;
  } CH8_AL1_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 8 TRANS_COUNT register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH8_AL1_TRANS_COUNT_TRIG : 32;/*!< CH8_AL1_TRANS_COUNT_TRIG                                               */
    } bit;
  } CH8_AL1_TRANS_COUNT_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 8 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH8_AL2_CTRL : 32;         /*!< CH8_AL2_CTRL                                                              */
    } bit;
  } CH8_AL2_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 8 TRANS_COUNT register                                  */
    
    struct {
      __IOM uint32_t CH8_AL2_TRANS_COUNT : 32;  /*!< CH8_AL2_TRANS_COUNT                                                       */
    } bit;
  } CH8_AL2_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 8 READ_ADDR register                                    */
    
    struct {
      __IOM uint32_t CH8_AL2_READ_ADDR : 32;    /*!< CH8_AL2_READ_ADDR                                                         */
    } bit;
  } CH8_AL2_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 8 WRITE_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH8_AL2_WRITE_ADDR_TRIG : 32;/*!< CH8_AL2_WRITE_ADDR_TRIG                                                 */
    } bit;
  } CH8_AL2_WRITE_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 8 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH8_AL3_CTRL : 32;         /*!< CH8_AL3_CTRL                                                              */
    } bit;
  } CH8_AL3_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 8 WRITE_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH8_AL3_WRITE_ADDR : 32;   /*!< CH8_AL3_WRITE_ADDR                                                        */
    } bit;
  } CH8_AL3_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 8 TRANS_COUNT register                                  */
    
    struct {
      __IOM uint32_t CH8_AL3_TRANS_COUNT : 32;  /*!< CH8_AL3_TRANS_COUNT                                                       */
    } bit;
  } CH8_AL3_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 8 READ_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH8_AL3_READ_ADDR_TRIG : 32;/*!< CH8_AL3_READ_ADDR_TRIG                                                   */
    } bit;
  } CH8_AL3_READ_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 9 Read Address pointer                                        */
    
    struct {
      __IOM uint32_t CH9_READ_ADDR : 32;        /*!< This register updates automatically each time a read completes.
                                                     The current value is the next address to be read by this
                                                     channel.                                                                  */
    } bit;
  } CH9_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 9 Write Address pointer                                       */
    
    struct {
      __IOM uint32_t CH9_WRITE_ADDR : 32;       /*!< This register updates automatically each time a write completes.
                                                     The current value is the next address to be written by
                                                     this channel.                                                             */
    } bit;
  } CH9_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 9 Transfer Count                                              */
    
    struct {
      __IOM uint32_t CH9_TRANS_COUNT : 32;      /*!< Program the number of bus transfers a channel will perform before
                                                     halting. Note that, if transfers are larger than one byte
                                                     in size, this is not equal to the number of bytes transferred
                                                     (see CTRL_DATA_SIZE). When the channel is active, reading
                                                     this register shows the number of transfers remaining,
                                                     updating automatically each time a write transfer completes.
                                                     Writing this register sets the RELOAD value for the transfer
                                                     counter. Each time this channel is triggered, the RELOAD
                                                     value is copied into the live transfer counter. The channel
                                                     can be started multiple times, and will perform the same
                                                     number of transfers each time, as programmed by most recent
                                                     write. The RELOAD value can be observed at CHx_DBG_TCR.
                                                     If TRANS_COUNT is used as a trigger, the written value
                                                     is used immediately as the length of the new transfer sequence,
                                                     as well as being written to RELOAD.                                       */
    } bit;
  } CH9_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 9 Control and Status                                          */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< DMA Channel Enable. When 1, the channel will respond to triggering
                                                     events, which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< HIGH_PRIORITY gives a channel preferential treatment in issue
                                                     scheduling: in each scheduling round, all high priority
                                                     channels are considered first, and then only a single low
                                                     priority channel, before returning to the high priority
                                                     channels. This only affects the order in which the DMA
                                                     schedules channels. The DMA's bus priority is not changed.
                                                     If the DMA is not saturated then a low priority channel
                                                     will see no loss of throughput.                                           */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< Set the size of each bus transfer (byte/halfword/word). READ_ADDR
                                                     and WRITE_ADDR advance by this amount (1/2/4 bytes) with
                                                     each transfer.                                                            */
      __IOM uint32_t INCR_READ  : 1;            /*!< If 1, the read address increments with each transfer. If 0,
                                                     each read is directed to the same, initial address. Generally
                                                     this should be disabled for peripheral-to-memory transfers.               */
      __IOM uint32_t INCR_WRITE : 1;            /*!< If 1, the write address increments with each transfer. If 0,
                                                     each write is directed to the same, initial address. Generally
                                                     this should be disabled for memory-to-peripheral transfers.               */
      __IOM uint32_t RING_SIZE  : 4;            /*!< Size of address wrap region. If 0, don't wrap. For values n
                                                     > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers. Ring sizes between
                                                     2 and 32768 bytes are possible. This can apply to either
                                                     read or write addresses, based on value of RING_SEL.                      */
      __IOM uint32_t RING_SEL   : 1;            /*!< Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< When this channel completes, it will trigger the channel indicated
                                                     by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.              */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< Select a Transfer Request signal. The channel uses the transfer
                                                     request signal to pace its data transfer rate. Sources
                                                     for TREQ signals are internal (TIMERS) or external (DREQ,
                                                     a Data Request from the system). 0x0 to 0x3a -> select
                                                     DREQ n as TREQ                                                            */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< In QUIET mode, the channel does not generate IRQs at the end
                                                     of every transfer block. Instead, an IRQ is raised when
                                                     NULL is written to a trigger register, indicating the end
                                                     of a control block chain. This reduces the number of interrupts
                                                     to be serviced by the CPU when transferring a DMA chain
                                                     of many small control blocks.                                             */
      __IOM uint32_t BSWAP      : 1;            /*!< Apply byte-swap transformation to DMA data. For byte data, this
                                                     has no effect. For halfword data, the two bytes of each
                                                     halfword are swapped. For word data, the four bytes of
                                                     each word are swapped to reverse order.                                   */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< If 1, this channel's data transfers are visible to the sniff
                                                     hardware, and each transfer will advance the state of the
                                                     checksum. This only applies if the sniff hardware is enabled,
                                                     and has this channel selected. This allows checksum to
                                                     be enabled or disabled on a per-control- block basis.                     */
      __IM  uint32_t BUSY       : 1;            /*!< This flag goes high when the channel starts a new transfer sequence,
                                                     and low when the last transfer of that sequence completes.
                                                     Clearing EN while BUSY is high pauses the channel, and
                                                     BUSY will stay high while paused. To terminate a sequence
                                                     early (and clear the BUSY flag), see CHAN_ABORT.                          */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< If 1, the channel received a write bus error. Write one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not be earlier, or more than
                                                     5 transfers later)                                                        */
      __IOM uint32_t READ_ERROR : 1;            /*!< If 1, the channel received a read bus error. Write one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not be earlier, or more than 3 transfers
                                                     later)                                                                    */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel
                                                     halts when it encounters any bus error, and always raises
                                                     its channel IRQ flag.                                                     */
    } bit;
  } CH9_CTRL_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 9 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH9_AL1_CTRL : 32;         /*!< CH9_AL1_CTRL                                                              */
    } bit;
  } CH9_AL1_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 9 READ_ADDR register                                    */
    
    struct {
      __IOM uint32_t CH9_AL1_READ_ADDR : 32;    /*!< CH9_AL1_READ_ADDR                                                         */
    } bit;
  } CH9_AL1_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 9 WRITE_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH9_AL1_WRITE_ADDR : 32;   /*!< CH9_AL1_WRITE_ADDR                                                        */
    } bit;
  } CH9_AL1_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 9 TRANS_COUNT register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH9_AL1_TRANS_COUNT_TRIG : 32;/*!< CH9_AL1_TRANS_COUNT_TRIG                                               */
    } bit;
  } CH9_AL1_TRANS_COUNT_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 9 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH9_AL2_CTRL : 32;         /*!< CH9_AL2_CTRL                                                              */
    } bit;
  } CH9_AL2_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 9 TRANS_COUNT register                                  */
    
    struct {
      __IOM uint32_t CH9_AL2_TRANS_COUNT : 32;  /*!< CH9_AL2_TRANS_COUNT                                                       */
    } bit;
  } CH9_AL2_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 9 READ_ADDR register                                    */
    
    struct {
      __IOM uint32_t CH9_AL2_READ_ADDR : 32;    /*!< CH9_AL2_READ_ADDR                                                         */
    } bit;
  } CH9_AL2_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 9 WRITE_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH9_AL2_WRITE_ADDR_TRIG : 32;/*!< CH9_AL2_WRITE_ADDR_TRIG                                                 */
    } bit;
  } CH9_AL2_WRITE_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 9 CTRL register                                         */
    
    struct {
      __IOM uint32_t CH9_AL3_CTRL : 32;         /*!< CH9_AL3_CTRL                                                              */
    } bit;
  } CH9_AL3_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 9 WRITE_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH9_AL3_WRITE_ADDR : 32;   /*!< CH9_AL3_WRITE_ADDR                                                        */
    } bit;
  } CH9_AL3_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 9 TRANS_COUNT register                                  */
    
    struct {
      __IOM uint32_t CH9_AL3_TRANS_COUNT : 32;  /*!< CH9_AL3_TRANS_COUNT                                                       */
    } bit;
  } CH9_AL3_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 9 READ_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH9_AL3_READ_ADDR_TRIG : 32;/*!< CH9_AL3_READ_ADDR_TRIG                                                   */
    } bit;
  } CH9_AL3_READ_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 10 Read Address pointer                                       */
    
    struct {
      __IOM uint32_t CH10_READ_ADDR : 32;       /*!< This register updates automatically each time a read completes.
                                                     The current value is the next address to be read by this
                                                     channel.                                                                  */
    } bit;
  } CH10_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 10 Write Address pointer                                      */
    
    struct {
      __IOM uint32_t CH10_WRITE_ADDR : 32;      /*!< This register updates automatically each time a write completes.
                                                     The current value is the next address to be written by
                                                     this channel.                                                             */
    } bit;
  } CH10_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 10 Transfer Count                                             */
    
    struct {
      __IOM uint32_t CH10_TRANS_COUNT : 32;     /*!< Program the number of bus transfers a channel will perform before
                                                     halting. Note that, if transfers are larger than one byte
                                                     in size, this is not equal to the number of bytes transferred
                                                     (see CTRL_DATA_SIZE). When the channel is active, reading
                                                     this register shows the number of transfers remaining,
                                                     updating automatically each time a write transfer completes.
                                                     Writing this register sets the RELOAD value for the transfer
                                                     counter. Each time this channel is triggered, the RELOAD
                                                     value is copied into the live transfer counter. The channel
                                                     can be started multiple times, and will perform the same
                                                     number of transfers each time, as programmed by most recent
                                                     write. The RELOAD value can be observed at CHx_DBG_TCR.
                                                     If TRANS_COUNT is used as a trigger, the written value
                                                     is used immediately as the length of the new transfer sequence,
                                                     as well as being written to RELOAD.                                       */
    } bit;
  } CH10_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 10 Control and Status                                         */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< DMA Channel Enable. When 1, the channel will respond to triggering
                                                     events, which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< HIGH_PRIORITY gives a channel preferential treatment in issue
                                                     scheduling: in each scheduling round, all high priority
                                                     channels are considered first, and then only a single low
                                                     priority channel, before returning to the high priority
                                                     channels. This only affects the order in which the DMA
                                                     schedules channels. The DMA's bus priority is not changed.
                                                     If the DMA is not saturated then a low priority channel
                                                     will see no loss of throughput.                                           */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< Set the size of each bus transfer (byte/halfword/word). READ_ADDR
                                                     and WRITE_ADDR advance by this amount (1/2/4 bytes) with
                                                     each transfer.                                                            */
      __IOM uint32_t INCR_READ  : 1;            /*!< If 1, the read address increments with each transfer. If 0,
                                                     each read is directed to the same, initial address. Generally
                                                     this should be disabled for peripheral-to-memory transfers.               */
      __IOM uint32_t INCR_WRITE : 1;            /*!< If 1, the write address increments with each transfer. If 0,
                                                     each write is directed to the same, initial address. Generally
                                                     this should be disabled for memory-to-peripheral transfers.               */
      __IOM uint32_t RING_SIZE  : 4;            /*!< Size of address wrap region. If 0, don't wrap. For values n
                                                     > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers. Ring sizes between
                                                     2 and 32768 bytes are possible. This can apply to either
                                                     read or write addresses, based on value of RING_SEL.                      */
      __IOM uint32_t RING_SEL   : 1;            /*!< Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< When this channel completes, it will trigger the channel indicated
                                                     by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.              */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< Select a Transfer Request signal. The channel uses the transfer
                                                     request signal to pace its data transfer rate. Sources
                                                     for TREQ signals are internal (TIMERS) or external (DREQ,
                                                     a Data Request from the system). 0x0 to 0x3a -> select
                                                     DREQ n as TREQ                                                            */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< In QUIET mode, the channel does not generate IRQs at the end
                                                     of every transfer block. Instead, an IRQ is raised when
                                                     NULL is written to a trigger register, indicating the end
                                                     of a control block chain. This reduces the number of interrupts
                                                     to be serviced by the CPU when transferring a DMA chain
                                                     of many small control blocks.                                             */
      __IOM uint32_t BSWAP      : 1;            /*!< Apply byte-swap transformation to DMA data. For byte data, this
                                                     has no effect. For halfword data, the two bytes of each
                                                     halfword are swapped. For word data, the four bytes of
                                                     each word are swapped to reverse order.                                   */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< If 1, this channel's data transfers are visible to the sniff
                                                     hardware, and each transfer will advance the state of the
                                                     checksum. This only applies if the sniff hardware is enabled,
                                                     and has this channel selected. This allows checksum to
                                                     be enabled or disabled on a per-control- block basis.                     */
      __IM  uint32_t BUSY       : 1;            /*!< This flag goes high when the channel starts a new transfer sequence,
                                                     and low when the last transfer of that sequence completes.
                                                     Clearing EN while BUSY is high pauses the channel, and
                                                     BUSY will stay high while paused. To terminate a sequence
                                                     early (and clear the BUSY flag), see CHAN_ABORT.                          */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< If 1, the channel received a write bus error. Write one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not be earlier, or more than
                                                     5 transfers later)                                                        */
      __IOM uint32_t READ_ERROR : 1;            /*!< If 1, the channel received a read bus error. Write one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not be earlier, or more than 3 transfers
                                                     later)                                                                    */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel
                                                     halts when it encounters any bus error, and always raises
                                                     its channel IRQ flag.                                                     */
    } bit;
  } CH10_CTRL_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 10 CTRL register                                        */
    
    struct {
      __IOM uint32_t CH10_AL1_CTRL : 32;        /*!< CH10_AL1_CTRL                                                             */
    } bit;
  } CH10_AL1_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 10 READ_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH10_AL1_READ_ADDR : 32;   /*!< CH10_AL1_READ_ADDR                                                        */
    } bit;
  } CH10_AL1_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 10 WRITE_ADDR register                                  */
    
    struct {
      __IOM uint32_t CH10_AL1_WRITE_ADDR : 32;  /*!< CH10_AL1_WRITE_ADDR                                                       */
    } bit;
  } CH10_AL1_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 10 TRANS_COUNT register This is a trigger
                                                     register (0xc). Writing a nonzero value will reload the
                                                     channel counter and start the channel.                                    */
    
    struct {
      __IOM uint32_t CH10_AL1_TRANS_COUNT_TRIG : 32;/*!< CH10_AL1_TRANS_COUNT_TRIG                                             */
    } bit;
  } CH10_AL1_TRANS_COUNT_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 10 CTRL register                                        */
    
    struct {
      __IOM uint32_t CH10_AL2_CTRL : 32;        /*!< CH10_AL2_CTRL                                                             */
    } bit;
  } CH10_AL2_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 10 TRANS_COUNT register                                 */
    
    struct {
      __IOM uint32_t CH10_AL2_TRANS_COUNT : 32; /*!< CH10_AL2_TRANS_COUNT                                                      */
    } bit;
  } CH10_AL2_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 10 READ_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH10_AL2_READ_ADDR : 32;   /*!< CH10_AL2_READ_ADDR                                                        */
    } bit;
  } CH10_AL2_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 10 WRITE_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH10_AL2_WRITE_ADDR_TRIG : 32;/*!< CH10_AL2_WRITE_ADDR_TRIG                                               */
    } bit;
  } CH10_AL2_WRITE_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 10 CTRL register                                        */
    
    struct {
      __IOM uint32_t CH10_AL3_CTRL : 32;        /*!< CH10_AL3_CTRL                                                             */
    } bit;
  } CH10_AL3_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 10 WRITE_ADDR register                                  */
    
    struct {
      __IOM uint32_t CH10_AL3_WRITE_ADDR : 32;  /*!< CH10_AL3_WRITE_ADDR                                                       */
    } bit;
  } CH10_AL3_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 10 TRANS_COUNT register                                 */
    
    struct {
      __IOM uint32_t CH10_AL3_TRANS_COUNT : 32; /*!< CH10_AL3_TRANS_COUNT                                                      */
    } bit;
  } CH10_AL3_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 10 READ_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH10_AL3_READ_ADDR_TRIG : 32;/*!< CH10_AL3_READ_ADDR_TRIG                                                 */
    } bit;
  } CH10_AL3_READ_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 11 Read Address pointer                                       */
    
    struct {
      __IOM uint32_t CH11_READ_ADDR : 32;       /*!< This register updates automatically each time a read completes.
                                                     The current value is the next address to be read by this
                                                     channel.                                                                  */
    } bit;
  } CH11_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 11 Write Address pointer                                      */
    
    struct {
      __IOM uint32_t CH11_WRITE_ADDR : 32;      /*!< This register updates automatically each time a write completes.
                                                     The current value is the next address to be written by
                                                     this channel.                                                             */
    } bit;
  } CH11_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 11 Transfer Count                                             */
    
    struct {
      __IOM uint32_t CH11_TRANS_COUNT : 32;     /*!< Program the number of bus transfers a channel will perform before
                                                     halting. Note that, if transfers are larger than one byte
                                                     in size, this is not equal to the number of bytes transferred
                                                     (see CTRL_DATA_SIZE). When the channel is active, reading
                                                     this register shows the number of transfers remaining,
                                                     updating automatically each time a write transfer completes.
                                                     Writing this register sets the RELOAD value for the transfer
                                                     counter. Each time this channel is triggered, the RELOAD
                                                     value is copied into the live transfer counter. The channel
                                                     can be started multiple times, and will perform the same
                                                     number of transfers each time, as programmed by most recent
                                                     write. The RELOAD value can be observed at CHx_DBG_TCR.
                                                     If TRANS_COUNT is used as a trigger, the written value
                                                     is used immediately as the length of the new transfer sequence,
                                                     as well as being written to RELOAD.                                       */
    } bit;
  } CH11_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Channel 11 Control and Status                                         */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< DMA Channel Enable. When 1, the channel will respond to triggering
                                                     events, which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< HIGH_PRIORITY gives a channel preferential treatment in issue
                                                     scheduling: in each scheduling round, all high priority
                                                     channels are considered first, and then only a single low
                                                     priority channel, before returning to the high priority
                                                     channels. This only affects the order in which the DMA
                                                     schedules channels. The DMA's bus priority is not changed.
                                                     If the DMA is not saturated then a low priority channel
                                                     will see no loss of throughput.                                           */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< Set the size of each bus transfer (byte/halfword/word). READ_ADDR
                                                     and WRITE_ADDR advance by this amount (1/2/4 bytes) with
                                                     each transfer.                                                            */
      __IOM uint32_t INCR_READ  : 1;            /*!< If 1, the read address increments with each transfer. If 0,
                                                     each read is directed to the same, initial address. Generally
                                                     this should be disabled for peripheral-to-memory transfers.               */
      __IOM uint32_t INCR_WRITE : 1;            /*!< If 1, the write address increments with each transfer. If 0,
                                                     each write is directed to the same, initial address. Generally
                                                     this should be disabled for memory-to-peripheral transfers.               */
      __IOM uint32_t RING_SIZE  : 4;            /*!< Size of address wrap region. If 0, don't wrap. For values n
                                                     > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers. Ring sizes between
                                                     2 and 32768 bytes are possible. This can apply to either
                                                     read or write addresses, based on value of RING_SEL.                      */
      __IOM uint32_t RING_SEL   : 1;            /*!< Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< When this channel completes, it will trigger the channel indicated
                                                     by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_.              */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< Select a Transfer Request signal. The channel uses the transfer
                                                     request signal to pace its data transfer rate. Sources
                                                     for TREQ signals are internal (TIMERS) or external (DREQ,
                                                     a Data Request from the system). 0x0 to 0x3a -> select
                                                     DREQ n as TREQ                                                            */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< In QUIET mode, the channel does not generate IRQs at the end
                                                     of every transfer block. Instead, an IRQ is raised when
                                                     NULL is written to a trigger register, indicating the end
                                                     of a control block chain. This reduces the number of interrupts
                                                     to be serviced by the CPU when transferring a DMA chain
                                                     of many small control blocks.                                             */
      __IOM uint32_t BSWAP      : 1;            /*!< Apply byte-swap transformation to DMA data. For byte data, this
                                                     has no effect. For halfword data, the two bytes of each
                                                     halfword are swapped. For word data, the four bytes of
                                                     each word are swapped to reverse order.                                   */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< If 1, this channel's data transfers are visible to the sniff
                                                     hardware, and each transfer will advance the state of the
                                                     checksum. This only applies if the sniff hardware is enabled,
                                                     and has this channel selected. This allows checksum to
                                                     be enabled or disabled on a per-control- block basis.                     */
      __IM  uint32_t BUSY       : 1;            /*!< This flag goes high when the channel starts a new transfer sequence,
                                                     and low when the last transfer of that sequence completes.
                                                     Clearing EN while BUSY is high pauses the channel, and
                                                     BUSY will stay high while paused. To terminate a sequence
                                                     early (and clear the BUSY flag), see CHAN_ABORT.                          */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< If 1, the channel received a write bus error. Write one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not be earlier, or more than
                                                     5 transfers later)                                                        */
      __IOM uint32_t READ_ERROR : 1;            /*!< If 1, the channel received a read bus error. Write one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not be earlier, or more than 3 transfers
                                                     later)                                                                    */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel
                                                     halts when it encounters any bus error, and always raises
                                                     its channel IRQ flag.                                                     */
    } bit;
  } CH11_CTRL_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 11 CTRL register                                        */
    
    struct {
      __IOM uint32_t CH11_AL1_CTRL : 32;        /*!< CH11_AL1_CTRL                                                             */
    } bit;
  } CH11_AL1_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 11 READ_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH11_AL1_READ_ADDR : 32;   /*!< CH11_AL1_READ_ADDR                                                        */
    } bit;
  } CH11_AL1_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 11 WRITE_ADDR register                                  */
    
    struct {
      __IOM uint32_t CH11_AL1_WRITE_ADDR : 32;  /*!< CH11_AL1_WRITE_ADDR                                                       */
    } bit;
  } CH11_AL1_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 11 TRANS_COUNT register This is a trigger
                                                     register (0xc). Writing a nonzero value will reload the
                                                     channel counter and start the channel.                                    */
    
    struct {
      __IOM uint32_t CH11_AL1_TRANS_COUNT_TRIG : 32;/*!< CH11_AL1_TRANS_COUNT_TRIG                                             */
    } bit;
  } CH11_AL1_TRANS_COUNT_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 11 CTRL register                                        */
    
    struct {
      __IOM uint32_t CH11_AL2_CTRL : 32;        /*!< CH11_AL2_CTRL                                                             */
    } bit;
  } CH11_AL2_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 11 TRANS_COUNT register                                 */
    
    struct {
      __IOM uint32_t CH11_AL2_TRANS_COUNT : 32; /*!< CH11_AL2_TRANS_COUNT                                                      */
    } bit;
  } CH11_AL2_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 11 READ_ADDR register                                   */
    
    struct {
      __IOM uint32_t CH11_AL2_READ_ADDR : 32;   /*!< CH11_AL2_READ_ADDR                                                        */
    } bit;
  } CH11_AL2_READ_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 11 WRITE_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH11_AL2_WRITE_ADDR_TRIG : 32;/*!< CH11_AL2_WRITE_ADDR_TRIG                                               */
    } bit;
  } CH11_AL2_WRITE_ADDR_TRIG;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 11 CTRL register                                        */
    
    struct {
      __IOM uint32_t CH11_AL3_CTRL : 32;        /*!< CH11_AL3_CTRL                                                             */
    } bit;
  } CH11_AL3_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 11 WRITE_ADDR register                                  */
    
    struct {
      __IOM uint32_t CH11_AL3_WRITE_ADDR : 32;  /*!< CH11_AL3_WRITE_ADDR                                                       */
    } bit;
  } CH11_AL3_WRITE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 11 TRANS_COUNT register                                 */
    
    struct {
      __IOM uint32_t CH11_AL3_TRANS_COUNT : 32; /*!< CH11_AL3_TRANS_COUNT                                                      */
    } bit;
  } CH11_AL3_TRANS_COUNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Alias for channel 11 READ_ADDR register This is a trigger register
                                                     (0xc). Writing a nonzero value will reload the channel
                                                     counter and start the channel.                                            */
    
    struct {
      __IOM uint32_t CH11_AL3_READ_ADDR_TRIG : 32;/*!< CH11_AL3_READ_ADDR_TRIG                                                 */
    } bit;
  } CH11_AL3_READ_ADDR_TRIG;
  __IM  uint32_t  RESERVED[64];
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Status (raw)                                                    */
    
    struct {
      __IOM uint32_t INTR       : 16;           /*!< Raw interrupt status for DMA Channels 0..15. Bit n corresponds
                                                     to channel n. Ignores any masking or forcing. Channel interrupts
                                                     can be cleared by writing a bit mask to INTR, INTS0 or
                                                     INTS1. Channel interrupts can be routed to either of two
                                                     system-level IRQs based on INTE0 and INTE1. This can be
                                                     used vector different channel interrupts to different ISRs:
                                                     this might be done to allow NVIC IRQ preemption for more
                                                     time-critical channels, or to spread IRQ load across different
                                                     cores. It is also valid to ignore this behaviour and just
                                                     use INTE0/INTS0/IRQ 0.                                                    */
            uint32_t            : 16;
    } bit;
  } INTR;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enables for IRQ 0                                               */
    
    struct {
      __IOM uint32_t INTE0      : 16;           /*!< Set bit n to pass interrupts from channel n to DMA IRQ 0.                 */
            uint32_t            : 16;
    } bit;
  } INTE0;
  
  union {
    __IOM uint32_t reg;                         /*!< Force Interrupts                                                          */
    
    struct {
      __IOM uint32_t INTF0      : 16;           /*!< Write 1s to force the corresponding bits in INTE0. The interrupt
                                                     remains asserted until INTF0 is cleared.                                  */
            uint32_t            : 16;
    } bit;
  } INTF0;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Status for IRQ 0                                                */
    
    struct {
      __IOM uint32_t INTS0      : 16;           /*!< Indicates active channel interrupt requests which are currently
                                                     causing IRQ 0 to be asserted. Channel interrupts can be
                                                     cleared by writing a bit mask here.                                       */
            uint32_t            : 16;
    } bit;
  } INTS0;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Status (raw)                                                    */
    
    struct {
      __IOM uint32_t INTR1      : 16;           /*!< Raw interrupt status for DMA Channels 0..15. Bit n corresponds
                                                     to channel n. Ignores any masking or forcing. Channel interrupts
                                                     can be cleared by writing a bit mask to INTR, INTS0 or
                                                     INTS1. Channel interrupts can be routed to either of two
                                                     system-level IRQs based on INTE0 and INTE1. This can be
                                                     used vector different channel interrupts to different ISRs:
                                                     this might be done to allow NVIC IRQ preemption for more
                                                     time-critical channels, or to spread IRQ load across different
                                                     cores. It is also valid to ignore this behaviour and just
                                                     use INTE0/INTS0/IRQ 0.                                                    */
            uint32_t            : 16;
    } bit;
  } INTR1;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enables for IRQ 1                                               */
    
    struct {
      __IOM uint32_t INTE1      : 16;           /*!< Set bit n to pass interrupts from channel n to DMA IRQ 1.                 */
            uint32_t            : 16;
    } bit;
  } INTE1;
  
  union {
    __IOM uint32_t reg;                         /*!< Force Interrupts for IRQ 1                                                */
    
    struct {
      __IOM uint32_t INTF1      : 16;           /*!< Write 1s to force the corresponding bits in INTE0. The interrupt
                                                     remains asserted until INTF0 is cleared.                                  */
            uint32_t            : 16;
    } bit;
  } INTF1;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Status (masked) for IRQ 1                                       */
    
    struct {
      __IOM uint32_t INTS1      : 16;           /*!< Indicates active channel interrupt requests which are currently
                                                     causing IRQ 1 to be asserted. Channel interrupts can be
                                                     cleared by writing a bit mask here.                                       */
            uint32_t            : 16;
    } bit;
  } INTS1;
  
  union {
    __IOM uint32_t reg;                         /*!< Pacing (X/Y) Fractional Timer The pacing timer produces TREQ
                                                     assertions at a rate set by ((X/Y) * sys_clk). This equation
                                                     is evaluated every sys_clk cycles and therefore can only
                                                     generate TREQs at a rate of 1 per sys_clk (i.e. permanent
                                                     TREQ) or less.                                                            */
    
    struct {
      __IOM uint32_t Y          : 16;           /*!< Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional
                                                     timer.                                                                    */
      __IOM uint32_t X          : 16;           /*!< Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional
                                                     timer.                                                                    */
    } bit;
  } TIMER0;
  
  union {
    __IOM uint32_t reg;                         /*!< Pacing (X/Y) Fractional Timer The pacing timer produces TREQ
                                                     assertions at a rate set by ((X/Y) * sys_clk). This equation
                                                     is evaluated every sys_clk cycles and therefore can only
                                                     generate TREQs at a rate of 1 per sys_clk (i.e. permanent
                                                     TREQ) or less.                                                            */
    
    struct {
      __IOM uint32_t Y          : 16;           /*!< Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional
                                                     timer.                                                                    */
      __IOM uint32_t X          : 16;           /*!< Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional
                                                     timer.                                                                    */
    } bit;
  } TIMER1;
  
  union {
    __IOM uint32_t reg;                         /*!< Pacing (X/Y) Fractional Timer The pacing timer produces TREQ
                                                     assertions at a rate set by ((X/Y) * sys_clk). This equation
                                                     is evaluated every sys_clk cycles and therefore can only
                                                     generate TREQs at a rate of 1 per sys_clk (i.e. permanent
                                                     TREQ) or less.                                                            */
    
    struct {
      __IOM uint32_t Y          : 16;           /*!< Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional
                                                     timer.                                                                    */
      __IOM uint32_t X          : 16;           /*!< Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional
                                                     timer.                                                                    */
    } bit;
  } TIMER2;
  
  union {
    __IOM uint32_t reg;                         /*!< Pacing (X/Y) Fractional Timer The pacing timer produces TREQ
                                                     assertions at a rate set by ((X/Y) * sys_clk). This equation
                                                     is evaluated every sys_clk cycles and therefore can only
                                                     generate TREQs at a rate of 1 per sys_clk (i.e. permanent
                                                     TREQ) or less.                                                            */
    
    struct {
      __IOM uint32_t Y          : 16;           /*!< Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional
                                                     timer.                                                                    */
      __IOM uint32_t X          : 16;           /*!< Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional
                                                     timer.                                                                    */
    } bit;
  } TIMER3;
  
  union {
    __IOM uint32_t reg;                         /*!< Trigger one or more channels simultaneously                               */
    
    struct {
      __OM  uint32_t MULTI_CHAN_TRIGGER : 16;   /*!< Each bit in this register corresponds to a DMA channel. Writing
                                                     a 1 to the relevant bit is the same as writing to that
                                                     channel's trigger register; the channel will start if it
                                                     is currently enabled and not already busy.                                */
            uint32_t            : 16;
    } bit;
  } MULTI_CHAN_TRIGGER;
  
  union {
    __IOM uint32_t reg;                         /*!< Sniffer Control                                                           */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< Enable sniffer                                                            */
      __IOM uint32_t DMACH      : 4;            /*!< DMA channel for Sniffer to observe                                        */
      __IOM uint32_t CALC       : 4;            /*!< CALC                                                                      */
      __IOM uint32_t BSWAP      : 1;            /*!< Locally perform a byte reverse on the sniffed data, before feeding
                                                     into checksum. Note that the sniff hardware is downstream
                                                     of the DMA channel byteswap performed in the read master:
                                                     if channel CTRL_BSWAP and SNIFF_CTRL_BSWAP are both enabled,
                                                     their effects cancel from the sniffer's point of view.                    */
      __IOM uint32_t OUT_REV    : 1;            /*!< If set, the result appears bit-reversed when read. This does
                                                     not affect the way the checksum is calculated; the result
                                                     is transformed on-the-fly between the result register and
                                                     the bus.                                                                  */
      __IOM uint32_t OUT_INV    : 1;            /*!< If set, the result appears inverted (bitwise complement) when
                                                     read. This does not affect the way the checksum is calculated;
                                                     the result is transformed on-the-fly between the result
                                                     register and the bus.                                                     */
            uint32_t            : 20;
    } bit;
  } SNIFF_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Data accumulator for sniff hardware                                       */
    
    struct {
      __IOM uint32_t SNIFF_DATA : 32;           /*!< Write an initial seed value here before starting a DMA transfer
                                                     on the channel indicated by SNIFF_CTRL_DMACH. The hardware
                                                     will update this register each time it observes a read
                                                     from the indicated channel. Once the channel completes,
                                                     the final result can be read from this register.                          */
    } bit;
  } SNIFF_DATA;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t reg;                         /*!< Debug RAF, WAF, TDF levels                                                */
    
    struct {
      __IM  uint32_t TDF_LVL    : 8;            /*!< Current Transfer-Data-FIFO fill level                                     */
      __IM  uint32_t WAF_LVL    : 8;            /*!< Current Write-Address-FIFO fill level                                     */
      __IM  uint32_t RAF_LVL    : 8;            /*!< Current Read-Address-FIFO fill level                                      */
            uint32_t            : 8;
    } bit;
  } FIFO_LEVELS;
  
  union {
    __IOM uint32_t reg;                         /*!< Abort an in-progress transfer sequence on one or more channels            */
    
    struct {
      __OM  uint32_t CHAN_ABORT : 16;           /*!< Each bit corresponds to a channel. Writing a 1 aborts whatever
                                                     transfer sequence is in progress on that channel. The bit
                                                     will remain high until any in-flight transfers have been
                                                     flushed through the address and data FIFOs. After writing,
                                                     this register must be polled until it returns all-zero.
                                                     Until this point, it is unsafe to restart the channel.                    */
            uint32_t            : 16;
    } bit;
  } CHAN_ABORT;
  
  union {
    __IOM uint32_t reg;                         /*!< The number of channels this DMA instance is equipped with. This
                                                     DMA supports up to 16 hardware channels, but can be configured
                                                     with as few as one, to minimise silicon area.                             */
    
    struct {
      __IM  uint32_t N_CHANNELS : 5;            /*!< N_CHANNELS                                                                */
            uint32_t            : 27;
    } bit;
  } N_CHANNELS;
  __IM  uint32_t  RESERVED2[237];
  
  union {
    __IOM uint32_t reg;                         /*!< Read: get channel DREQ counter (i.e. how many accesses the DMA
                                                     expects it can perform on the peripheral without overflow/underflow.
                                                     Write any value: clears the counter, and cause channel
                                                     to re-initiate DREQ handshake.                                            */
    
    struct {
      __IOM uint32_t CH0_DBG_CTDREQ : 6;        /*!< CH0_DBG_CTDREQ                                                            */
            uint32_t            : 26;
    } bit;
  } CH0_DBG_CTDREQ;
  
  union {
    __IOM uint32_t reg;                         /*!< Read to get channel TRANS_COUNT reload value, i.e. the length
                                                     of the next transfer                                                      */
    
    struct {
      __IM  uint32_t CH0_DBG_TCR : 32;          /*!< CH0_DBG_TCR                                                               */
    } bit;
  } CH0_DBG_TCR;
  __IM  uint32_t  RESERVED3[14];
  
  union {
    __IOM uint32_t reg;                         /*!< Read: get channel DREQ counter (i.e. how many accesses the DMA
                                                     expects it can perform on the peripheral without overflow/underflow.
                                                     Write any value: clears the counter, and cause channel
                                                     to re-initiate DREQ handshake.                                            */
    
    struct {
      __IOM uint32_t CH1_DBG_CTDREQ : 6;        /*!< CH1_DBG_CTDREQ                                                            */
            uint32_t            : 26;
    } bit;
  } CH1_DBG_CTDREQ;
  
  union {
    __IOM uint32_t reg;                         /*!< Read to get channel TRANS_COUNT reload value, i.e. the length
                                                     of the next transfer                                                      */
    
    struct {
      __IM  uint32_t CH1_DBG_TCR : 32;          /*!< CH1_DBG_TCR                                                               */
    } bit;
  } CH1_DBG_TCR;
  __IM  uint32_t  RESERVED4[14];
  
  union {
    __IOM uint32_t reg;                         /*!< Read: get channel DREQ counter (i.e. how many accesses the DMA
                                                     expects it can perform on the peripheral without overflow/underflow.
                                                     Write any value: clears the counter, and cause channel
                                                     to re-initiate DREQ handshake.                                            */
    
    struct {
      __IOM uint32_t CH2_DBG_CTDREQ : 6;        /*!< CH2_DBG_CTDREQ                                                            */
            uint32_t            : 26;
    } bit;
  } CH2_DBG_CTDREQ;
  
  union {
    __IOM uint32_t reg;                         /*!< Read to get channel TRANS_COUNT reload value, i.e. the length
                                                     of the next transfer                                                      */
    
    struct {
      __IM  uint32_t CH2_DBG_TCR : 32;          /*!< CH2_DBG_TCR                                                               */
    } bit;
  } CH2_DBG_TCR;
  __IM  uint32_t  RESERVED5[14];
  
  union {
    __IOM uint32_t reg;                         /*!< Read: get channel DREQ counter (i.e. how many accesses the DMA
                                                     expects it can perform on the peripheral without overflow/underflow.
                                                     Write any value: clears the counter, and cause channel
                                                     to re-initiate DREQ handshake.                                            */
    
    struct {
      __IOM uint32_t CH3_DBG_CTDREQ : 6;        /*!< CH3_DBG_CTDREQ                                                            */
            uint32_t            : 26;
    } bit;
  } CH3_DBG_CTDREQ;
  
  union {
    __IOM uint32_t reg;                         /*!< Read to get channel TRANS_COUNT reload value, i.e. the length
                                                     of the next transfer                                                      */
    
    struct {
      __IM  uint32_t CH3_DBG_TCR : 32;          /*!< CH3_DBG_TCR                                                               */
    } bit;
  } CH3_DBG_TCR;
  __IM  uint32_t  RESERVED6[14];
  
  union {
    __IOM uint32_t reg;                         /*!< Read: get channel DREQ counter (i.e. how many accesses the DMA
                                                     expects it can perform on the peripheral without overflow/underflow.
                                                     Write any value: clears the counter, and cause channel
                                                     to re-initiate DREQ handshake.                                            */
    
    struct {
      __IOM uint32_t CH4_DBG_CTDREQ : 6;        /*!< CH4_DBG_CTDREQ                                                            */
            uint32_t            : 26;
    } bit;
  } CH4_DBG_CTDREQ;
  
  union {
    __IOM uint32_t reg;                         /*!< Read to get channel TRANS_COUNT reload value, i.e. the length
                                                     of the next transfer                                                      */
    
    struct {
      __IM  uint32_t CH4_DBG_TCR : 32;          /*!< CH4_DBG_TCR                                                               */
    } bit;
  } CH4_DBG_TCR;
  __IM  uint32_t  RESERVED7[14];
  
  union {
    __IOM uint32_t reg;                         /*!< Read: get channel DREQ counter (i.e. how many accesses the DMA
                                                     expects it can perform on the peripheral without overflow/underflow.
                                                     Write any value: clears the counter, and cause channel
                                                     to re-initiate DREQ handshake.                                            */
    
    struct {
      __IOM uint32_t CH5_DBG_CTDREQ : 6;        /*!< CH5_DBG_CTDREQ                                                            */
            uint32_t            : 26;
    } bit;
  } CH5_DBG_CTDREQ;
  
  union {
    __IOM uint32_t reg;                         /*!< Read to get channel TRANS_COUNT reload value, i.e. the length
                                                     of the next transfer                                                      */
    
    struct {
      __IM  uint32_t CH5_DBG_TCR : 32;          /*!< CH5_DBG_TCR                                                               */
    } bit;
  } CH5_DBG_TCR;
  __IM  uint32_t  RESERVED8[14];
  
  union {
    __IOM uint32_t reg;                         /*!< Read: get channel DREQ counter (i.e. how many accesses the DMA
                                                     expects it can perform on the peripheral without overflow/underflow.
                                                     Write any value: clears the counter, and cause channel
                                                     to re-initiate DREQ handshake.                                            */
    
    struct {
      __IOM uint32_t CH6_DBG_CTDREQ : 6;        /*!< CH6_DBG_CTDREQ                                                            */
            uint32_t            : 26;
    } bit;
  } CH6_DBG_CTDREQ;
  
  union {
    __IOM uint32_t reg;                         /*!< Read to get channel TRANS_COUNT reload value, i.e. the length
                                                     of the next transfer                                                      */
    
    struct {
      __IM  uint32_t CH6_DBG_TCR : 32;          /*!< CH6_DBG_TCR                                                               */
    } bit;
  } CH6_DBG_TCR;
  __IM  uint32_t  RESERVED9[14];
  
  union {
    __IOM uint32_t reg;                         /*!< Read: get channel DREQ counter (i.e. how many accesses the DMA
                                                     expects it can perform on the peripheral without overflow/underflow.
                                                     Write any value: clears the counter, and cause channel
                                                     to re-initiate DREQ handshake.                                            */
    
    struct {
      __IOM uint32_t CH7_DBG_CTDREQ : 6;        /*!< CH7_DBG_CTDREQ                                                            */
            uint32_t            : 26;
    } bit;
  } CH7_DBG_CTDREQ;
  
  union {
    __IOM uint32_t reg;                         /*!< Read to get channel TRANS_COUNT reload value, i.e. the length
                                                     of the next transfer                                                      */
    
    struct {
      __IM  uint32_t CH7_DBG_TCR : 32;          /*!< CH7_DBG_TCR                                                               */
    } bit;
  } CH7_DBG_TCR;
  __IM  uint32_t  RESERVED10[14];
  
  union {
    __IOM uint32_t reg;                         /*!< Read: get channel DREQ counter (i.e. how many accesses the DMA
                                                     expects it can perform on the peripheral without overflow/underflow.
                                                     Write any value: clears the counter, and cause channel
                                                     to re-initiate DREQ handshake.                                            */
    
    struct {
      __IOM uint32_t CH8_DBG_CTDREQ : 6;        /*!< CH8_DBG_CTDREQ                                                            */
            uint32_t            : 26;
    } bit;
  } CH8_DBG_CTDREQ;
  
  union {
    __IOM uint32_t reg;                         /*!< Read to get channel TRANS_COUNT reload value, i.e. the length
                                                     of the next transfer                                                      */
    
    struct {
      __IM  uint32_t CH8_DBG_TCR : 32;          /*!< CH8_DBG_TCR                                                               */
    } bit;
  } CH8_DBG_TCR;
  __IM  uint32_t  RESERVED11[14];
  
  union {
    __IOM uint32_t reg;                         /*!< Read: get channel DREQ counter (i.e. how many accesses the DMA
                                                     expects it can perform on the peripheral without overflow/underflow.
                                                     Write any value: clears the counter, and cause channel
                                                     to re-initiate DREQ handshake.                                            */
    
    struct {
      __IOM uint32_t CH9_DBG_CTDREQ : 6;        /*!< CH9_DBG_CTDREQ                                                            */
            uint32_t            : 26;
    } bit;
  } CH9_DBG_CTDREQ;
  
  union {
    __IOM uint32_t reg;                         /*!< Read to get channel TRANS_COUNT reload value, i.e. the length
                                                     of the next transfer                                                      */
    
    struct {
      __IM  uint32_t CH9_DBG_TCR : 32;          /*!< CH9_DBG_TCR                                                               */
    } bit;
  } CH9_DBG_TCR;
  __IM  uint32_t  RESERVED12[14];
  
  union {
    __IOM uint32_t reg;                         /*!< Read: get channel DREQ counter (i.e. how many accesses the DMA
                                                     expects it can perform on the peripheral without overflow/underflow.
                                                     Write any value: clears the counter, and cause channel
                                                     to re-initiate DREQ handshake.                                            */
    
    struct {
      __IOM uint32_t CH10_DBG_CTDREQ : 6;       /*!< CH10_DBG_CTDREQ                                                           */
            uint32_t            : 26;
    } bit;
  } CH10_DBG_CTDREQ;
  
  union {
    __IOM uint32_t reg;                         /*!< Read to get channel TRANS_COUNT reload value, i.e. the length
                                                     of the next transfer                                                      */
    
    struct {
      __IM  uint32_t CH10_DBG_TCR : 32;         /*!< CH10_DBG_TCR                                                              */
    } bit;
  } CH10_DBG_TCR;
  __IM  uint32_t  RESERVED13[14];
  
  union {
    __IOM uint32_t reg;                         /*!< Read: get channel DREQ counter (i.e. how many accesses the DMA
                                                     expects it can perform on the peripheral without overflow/underflow.
                                                     Write any value: clears the counter, and cause channel
                                                     to re-initiate DREQ handshake.                                            */
    
    struct {
      __IOM uint32_t CH11_DBG_CTDREQ : 6;       /*!< CH11_DBG_CTDREQ                                                           */
            uint32_t            : 26;
    } bit;
  } CH11_DBG_CTDREQ;
  
  union {
    __IOM uint32_t reg;                         /*!< Read to get channel TRANS_COUNT reload value, i.e. the length
                                                     of the next transfer                                                      */
    
    struct {
      __IM  uint32_t CH11_DBG_TCR : 32;         /*!< CH11_DBG_TCR                                                              */
    } bit;
  } CH11_DBG_TCR;
} DMA_Type;                                     /*!< Size = 2760 (0xac8)                                                       */



/* =========================================================================================================================== */
/* ================                                           TIMER                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Controls time and alarms 
            time is a 64 bit value indicating the time in usec since power-on 
            timeh is the top 32 bits of time & timel is the bottom 32 bits 
            to change time write to timelw before timehw 
            to read time read from timelr before timehr 
            An alarm is set by setting alarm_enable and writing to the corresponding alarm register 
            When an alarm is pending, the corresponding alarm_running signal will be high 
            An alarm can be cancelled before it has finished by clearing the alarm_enable 
            When an alarm fires, the corresponding alarm_irq is set and alarm_running is cleared 
            To clear the interrupt write a 1 to the corresponding alarm_irq (TIMER)
  */

typedef struct {                                /*!< TIMER Structure                                                           */
  
  union {
    __IOM uint32_t reg;                         /*!< Write to bits 63:32 of time always write timelw before timehw             */
    
    struct {
      __OM  uint32_t TIMEHW     : 32;           /*!< TIMEHW                                                                    */
    } bit;
  } TIMEHW;
  
  union {
    __IOM uint32_t reg;                         /*!< Write to bits 31:0 of time writes do not get copied to time
                                                     until timehw is written                                                   */
    
    struct {
      __OM  uint32_t TIMELW     : 32;           /*!< TIMELW                                                                    */
    } bit;
  } TIMELW;
  
  union {
    __IOM uint32_t reg;                         /*!< Read from bits 63:32 of time always read timelr before timehr             */
    
    struct {
      __IM  uint32_t TIMEHR     : 32;           /*!< TIMEHR                                                                    */
    } bit;
  } TIMEHR;
  
  union {
    __IOM uint32_t reg;                         /*!< Read from bits 31:0 of time                                               */
    
    struct {
      __IM  uint32_t TIMELR     : 32;           /*!< TIMELR                                                                    */
    } bit;
  } TIMELR;
  
  union {
    __IOM uint32_t reg;                         /*!< Arm alarm 0, and configure the time it will fire. Once armed,
                                                     the alarm fires when TIMER_ALARM0 == TIMELR. The alarm
                                                     will disarm itself once it fires, and can be disarmed early
                                                     using the ARMED status register.                                          */
    
    struct {
      __IOM uint32_t ALARM0     : 32;           /*!< ALARM0                                                                    */
    } bit;
  } ALARM0;
  
  union {
    __IOM uint32_t reg;                         /*!< Arm alarm 1, and configure the time it will fire. Once armed,
                                                     the alarm fires when TIMER_ALARM1 == TIMELR. The alarm
                                                     will disarm itself once it fires, and can be disarmed early
                                                     using the ARMED status register.                                          */
    
    struct {
      __IOM uint32_t ALARM1     : 32;           /*!< ALARM1                                                                    */
    } bit;
  } ALARM1;
  
  union {
    __IOM uint32_t reg;                         /*!< Arm alarm 2, and configure the time it will fire. Once armed,
                                                     the alarm fires when TIMER_ALARM2 == TIMELR. The alarm
                                                     will disarm itself once it fires, and can be disarmed early
                                                     using the ARMED status register.                                          */
    
    struct {
      __IOM uint32_t ALARM2     : 32;           /*!< ALARM2                                                                    */
    } bit;
  } ALARM2;
  
  union {
    __IOM uint32_t reg;                         /*!< Arm alarm 3, and configure the time it will fire. Once armed,
                                                     the alarm fires when TIMER_ALARM3 == TIMELR. The alarm
                                                     will disarm itself once it fires, and can be disarmed early
                                                     using the ARMED status register.                                          */
    
    struct {
      __IOM uint32_t ALARM3     : 32;           /*!< ALARM3                                                                    */
    } bit;
  } ALARM3;
  
  union {
    __IOM uint32_t reg;                         /*!< Indicates the armed/disarmed status of each alarm. A write to
                                                     the corresponding ALARMx register arms the alarm. Alarms
                                                     automatically disarm upon firing, but writing ones here
                                                     will disarm immediately without waiting to fire.                          */
    
    struct {
      __IOM uint32_t ARMED      : 4;            /*!< ARMED                                                                     */
            uint32_t            : 28;
    } bit;
  } ARMED;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw read from bits 63:32 of time (no side effects)                        */
    
    struct {
      __IM  uint32_t TIMERAWH   : 32;           /*!< TIMERAWH                                                                  */
    } bit;
  } TIMERAWH;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw read from bits 31:0 of time (no side effects)                         */
    
    struct {
      __IM  uint32_t TIMERAWL   : 32;           /*!< TIMERAWL                                                                  */
    } bit;
  } TIMERAWL;
  
  union {
    __IOM uint32_t reg;                         /*!< Set bits high to enable pause when the corresponding debug ports
                                                     are active                                                                */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t DBG0       : 1;            /*!< Pause when processor 0 is in debug mode                                   */
      __IOM uint32_t DBG1       : 1;            /*!< Pause when processor 1 is in debug mode                                   */
            uint32_t            : 29;
    } bit;
  } DBGPAUSE;
  
  union {
    __IOM uint32_t reg;                         /*!< Set high to pause the timer                                               */
    
    struct {
      __IOM uint32_t PAUSE      : 1;            /*!< PAUSE                                                                     */
            uint32_t            : 31;
    } bit;
  } PAUSE;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw Interrupts                                                            */
    
    struct {
      __IOM uint32_t ALARM_0    : 1;            /*!< ALARM_0                                                                   */
      __IOM uint32_t ALARM_1    : 1;            /*!< ALARM_1                                                                   */
      __IOM uint32_t ALARM_2    : 1;            /*!< ALARM_2                                                                   */
      __IOM uint32_t ALARM_3    : 1;            /*!< ALARM_3                                                                   */
            uint32_t            : 28;
    } bit;
  } INTR;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable                                                          */
    
    struct {
      __IOM uint32_t ALARM_0    : 1;            /*!< ALARM_0                                                                   */
      __IOM uint32_t ALARM_1    : 1;            /*!< ALARM_1                                                                   */
      __IOM uint32_t ALARM_2    : 1;            /*!< ALARM_2                                                                   */
      __IOM uint32_t ALARM_3    : 1;            /*!< ALARM_3                                                                   */
            uint32_t            : 28;
    } bit;
  } INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force                                                           */
    
    struct {
      __IOM uint32_t ALARM_0    : 1;            /*!< ALARM_0                                                                   */
      __IOM uint32_t ALARM_1    : 1;            /*!< ALARM_1                                                                   */
      __IOM uint32_t ALARM_2    : 1;            /*!< ALARM_2                                                                   */
      __IOM uint32_t ALARM_3    : 1;            /*!< ALARM_3                                                                   */
            uint32_t            : 28;
    } bit;
  } INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing                                  */
    
    struct {
      __IM  uint32_t ALARM_0    : 1;            /*!< ALARM_0                                                                   */
      __IM  uint32_t ALARM_1    : 1;            /*!< ALARM_1                                                                   */
      __IM  uint32_t ALARM_2    : 1;            /*!< ALARM_2                                                                   */
      __IM  uint32_t ALARM_3    : 1;            /*!< ALARM_3                                                                   */
            uint32_t            : 28;
    } bit;
  } INTS;
} TIMER_Type;                                   /*!< Size = 68 (0x44)                                                          */



/* =========================================================================================================================== */
/* ================                                            PWM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Simple PWM (PWM)
  */

typedef struct {                                /*!< PWM Structure                                                             */
  
  union {
    __IOM uint32_t reg;                         /*!< Control and status register                                               */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< Enable the PWM channel.                                                   */
      __IOM uint32_t PH_CORRECT : 1;            /*!< 1: Enable phase-correct modulation. 0: Trailing-edge                      */
      __IOM uint32_t A_INV      : 1;            /*!< Invert output A                                                           */
      __IOM uint32_t B_INV      : 1;            /*!< Invert output B                                                           */
      __IOM uint32_t DIVMODE    : 2;            /*!< DIVMODE                                                                   */
      __OM  uint32_t PH_RET     : 1;            /*!< Retard the phase of the counter by 1 count, while it is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running.                                                               */
      __OM  uint32_t PH_ADV     : 1;            /*!< Advance the phase of the counter by 1 count, while it is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running at less than full speed (div_int + div_frac
                                                     / 16 > 1)                                                                 */
            uint32_t            : 24;
    } bit;
  } CH0_CSR;
  
  union {
    __IOM uint32_t reg;                         /*!< INT and FRAC form a fixed-point fractional number. Counting
                                                     rate is system clock frequency divided by this number.
                                                     Fractional division uses simple 1st-order sigma-delta.                    */
    
    struct {
      __IOM uint32_t FRAC       : 4;            /*!< FRAC                                                                      */
      __IOM uint32_t INT        : 8;            /*!< INT                                                                       */
            uint32_t            : 20;
    } bit;
  } CH0_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Direct access to the PWM counter                                          */
    
    struct {
      __IOM uint32_t CH0_CTR    : 16;           /*!< CH0_CTR                                                                   */
            uint32_t            : 16;
    } bit;
  } CH0_CTR;
  
  union {
    __IOM uint32_t reg;                         /*!< Counter compare values                                                    */
    
    struct {
      __IOM uint32_t A          : 16;           /*!< A                                                                         */
      __IOM uint32_t B          : 16;           /*!< B                                                                         */
    } bit;
  } CH0_CC;
  
  union {
    __IOM uint32_t reg;                         /*!< Counter wrap value                                                        */
    
    struct {
      __IOM uint32_t CH0_TOP    : 16;           /*!< CH0_TOP                                                                   */
            uint32_t            : 16;
    } bit;
  } CH0_TOP;
  
  union {
    __IOM uint32_t reg;                         /*!< Control and status register                                               */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< Enable the PWM channel.                                                   */
      __IOM uint32_t PH_CORRECT : 1;            /*!< 1: Enable phase-correct modulation. 0: Trailing-edge                      */
      __IOM uint32_t A_INV      : 1;            /*!< Invert output A                                                           */
      __IOM uint32_t B_INV      : 1;            /*!< Invert output B                                                           */
      __IOM uint32_t DIVMODE    : 2;            /*!< DIVMODE                                                                   */
      __OM  uint32_t PH_RET     : 1;            /*!< Retard the phase of the counter by 1 count, while it is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running.                                                               */
      __OM  uint32_t PH_ADV     : 1;            /*!< Advance the phase of the counter by 1 count, while it is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running at less than full speed (div_int + div_frac
                                                     / 16 > 1)                                                                 */
            uint32_t            : 24;
    } bit;
  } CH1_CSR;
  
  union {
    __IOM uint32_t reg;                         /*!< INT and FRAC form a fixed-point fractional number. Counting
                                                     rate is system clock frequency divided by this number.
                                                     Fractional division uses simple 1st-order sigma-delta.                    */
    
    struct {
      __IOM uint32_t FRAC       : 4;            /*!< FRAC                                                                      */
      __IOM uint32_t INT        : 8;            /*!< INT                                                                       */
            uint32_t            : 20;
    } bit;
  } CH1_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Direct access to the PWM counter                                          */
    
    struct {
      __IOM uint32_t CH1_CTR    : 16;           /*!< CH1_CTR                                                                   */
            uint32_t            : 16;
    } bit;
  } CH1_CTR;
  
  union {
    __IOM uint32_t reg;                         /*!< Counter compare values                                                    */
    
    struct {
      __IOM uint32_t A          : 16;           /*!< A                                                                         */
      __IOM uint32_t B          : 16;           /*!< B                                                                         */
    } bit;
  } CH1_CC;
  
  union {
    __IOM uint32_t reg;                         /*!< Counter wrap value                                                        */
    
    struct {
      __IOM uint32_t CH1_TOP    : 16;           /*!< CH1_TOP                                                                   */
            uint32_t            : 16;
    } bit;
  } CH1_TOP;
  
  union {
    __IOM uint32_t reg;                         /*!< Control and status register                                               */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< Enable the PWM channel.                                                   */
      __IOM uint32_t PH_CORRECT : 1;            /*!< 1: Enable phase-correct modulation. 0: Trailing-edge                      */
      __IOM uint32_t A_INV      : 1;            /*!< Invert output A                                                           */
      __IOM uint32_t B_INV      : 1;            /*!< Invert output B                                                           */
      __IOM uint32_t DIVMODE    : 2;            /*!< DIVMODE                                                                   */
      __OM  uint32_t PH_RET     : 1;            /*!< Retard the phase of the counter by 1 count, while it is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running.                                                               */
      __OM  uint32_t PH_ADV     : 1;            /*!< Advance the phase of the counter by 1 count, while it is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running at less than full speed (div_int + div_frac
                                                     / 16 > 1)                                                                 */
            uint32_t            : 24;
    } bit;
  } CH2_CSR;
  
  union {
    __IOM uint32_t reg;                         /*!< INT and FRAC form a fixed-point fractional number. Counting
                                                     rate is system clock frequency divided by this number.
                                                     Fractional division uses simple 1st-order sigma-delta.                    */
    
    struct {
      __IOM uint32_t FRAC       : 4;            /*!< FRAC                                                                      */
      __IOM uint32_t INT        : 8;            /*!< INT                                                                       */
            uint32_t            : 20;
    } bit;
  } CH2_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Direct access to the PWM counter                                          */
    
    struct {
      __IOM uint32_t CH2_CTR    : 16;           /*!< CH2_CTR                                                                   */
            uint32_t            : 16;
    } bit;
  } CH2_CTR;
  
  union {
    __IOM uint32_t reg;                         /*!< Counter compare values                                                    */
    
    struct {
      __IOM uint32_t A          : 16;           /*!< A                                                                         */
      __IOM uint32_t B          : 16;           /*!< B                                                                         */
    } bit;
  } CH2_CC;
  
  union {
    __IOM uint32_t reg;                         /*!< Counter wrap value                                                        */
    
    struct {
      __IOM uint32_t CH2_TOP    : 16;           /*!< CH2_TOP                                                                   */
            uint32_t            : 16;
    } bit;
  } CH2_TOP;
  
  union {
    __IOM uint32_t reg;                         /*!< Control and status register                                               */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< Enable the PWM channel.                                                   */
      __IOM uint32_t PH_CORRECT : 1;            /*!< 1: Enable phase-correct modulation. 0: Trailing-edge                      */
      __IOM uint32_t A_INV      : 1;            /*!< Invert output A                                                           */
      __IOM uint32_t B_INV      : 1;            /*!< Invert output B                                                           */
      __IOM uint32_t DIVMODE    : 2;            /*!< DIVMODE                                                                   */
      __OM  uint32_t PH_RET     : 1;            /*!< Retard the phase of the counter by 1 count, while it is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running.                                                               */
      __OM  uint32_t PH_ADV     : 1;            /*!< Advance the phase of the counter by 1 count, while it is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running at less than full speed (div_int + div_frac
                                                     / 16 > 1)                                                                 */
            uint32_t            : 24;
    } bit;
  } CH3_CSR;
  
  union {
    __IOM uint32_t reg;                         /*!< INT and FRAC form a fixed-point fractional number. Counting
                                                     rate is system clock frequency divided by this number.
                                                     Fractional division uses simple 1st-order sigma-delta.                    */
    
    struct {
      __IOM uint32_t FRAC       : 4;            /*!< FRAC                                                                      */
      __IOM uint32_t INT        : 8;            /*!< INT                                                                       */
            uint32_t            : 20;
    } bit;
  } CH3_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Direct access to the PWM counter                                          */
    
    struct {
      __IOM uint32_t CH3_CTR    : 16;           /*!< CH3_CTR                                                                   */
            uint32_t            : 16;
    } bit;
  } CH3_CTR;
  
  union {
    __IOM uint32_t reg;                         /*!< Counter compare values                                                    */
    
    struct {
      __IOM uint32_t A          : 16;           /*!< A                                                                         */
      __IOM uint32_t B          : 16;           /*!< B                                                                         */
    } bit;
  } CH3_CC;
  
  union {
    __IOM uint32_t reg;                         /*!< Counter wrap value                                                        */
    
    struct {
      __IOM uint32_t CH3_TOP    : 16;           /*!< CH3_TOP                                                                   */
            uint32_t            : 16;
    } bit;
  } CH3_TOP;
  
  union {
    __IOM uint32_t reg;                         /*!< Control and status register                                               */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< Enable the PWM channel.                                                   */
      __IOM uint32_t PH_CORRECT : 1;            /*!< 1: Enable phase-correct modulation. 0: Trailing-edge                      */
      __IOM uint32_t A_INV      : 1;            /*!< Invert output A                                                           */
      __IOM uint32_t B_INV      : 1;            /*!< Invert output B                                                           */
      __IOM uint32_t DIVMODE    : 2;            /*!< DIVMODE                                                                   */
      __OM  uint32_t PH_RET     : 1;            /*!< Retard the phase of the counter by 1 count, while it is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running.                                                               */
      __OM  uint32_t PH_ADV     : 1;            /*!< Advance the phase of the counter by 1 count, while it is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running at less than full speed (div_int + div_frac
                                                     / 16 > 1)                                                                 */
            uint32_t            : 24;
    } bit;
  } CH4_CSR;
  
  union {
    __IOM uint32_t reg;                         /*!< INT and FRAC form a fixed-point fractional number. Counting
                                                     rate is system clock frequency divided by this number.
                                                     Fractional division uses simple 1st-order sigma-delta.                    */
    
    struct {
      __IOM uint32_t FRAC       : 4;            /*!< FRAC                                                                      */
      __IOM uint32_t INT        : 8;            /*!< INT                                                                       */
            uint32_t            : 20;
    } bit;
  } CH4_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Direct access to the PWM counter                                          */
    
    struct {
      __IOM uint32_t CH4_CTR    : 16;           /*!< CH4_CTR                                                                   */
            uint32_t            : 16;
    } bit;
  } CH4_CTR;
  
  union {
    __IOM uint32_t reg;                         /*!< Counter compare values                                                    */
    
    struct {
      __IOM uint32_t A          : 16;           /*!< A                                                                         */
      __IOM uint32_t B          : 16;           /*!< B                                                                         */
    } bit;
  } CH4_CC;
  
  union {
    __IOM uint32_t reg;                         /*!< Counter wrap value                                                        */
    
    struct {
      __IOM uint32_t CH4_TOP    : 16;           /*!< CH4_TOP                                                                   */
            uint32_t            : 16;
    } bit;
  } CH4_TOP;
  
  union {
    __IOM uint32_t reg;                         /*!< Control and status register                                               */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< Enable the PWM channel.                                                   */
      __IOM uint32_t PH_CORRECT : 1;            /*!< 1: Enable phase-correct modulation. 0: Trailing-edge                      */
      __IOM uint32_t A_INV      : 1;            /*!< Invert output A                                                           */
      __IOM uint32_t B_INV      : 1;            /*!< Invert output B                                                           */
      __IOM uint32_t DIVMODE    : 2;            /*!< DIVMODE                                                                   */
      __OM  uint32_t PH_RET     : 1;            /*!< Retard the phase of the counter by 1 count, while it is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running.                                                               */
      __OM  uint32_t PH_ADV     : 1;            /*!< Advance the phase of the counter by 1 count, while it is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running at less than full speed (div_int + div_frac
                                                     / 16 > 1)                                                                 */
            uint32_t            : 24;
    } bit;
  } CH5_CSR;
  
  union {
    __IOM uint32_t reg;                         /*!< INT and FRAC form a fixed-point fractional number. Counting
                                                     rate is system clock frequency divided by this number.
                                                     Fractional division uses simple 1st-order sigma-delta.                    */
    
    struct {
      __IOM uint32_t FRAC       : 4;            /*!< FRAC                                                                      */
      __IOM uint32_t INT        : 8;            /*!< INT                                                                       */
            uint32_t            : 20;
    } bit;
  } CH5_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Direct access to the PWM counter                                          */
    
    struct {
      __IOM uint32_t CH5_CTR    : 16;           /*!< CH5_CTR                                                                   */
            uint32_t            : 16;
    } bit;
  } CH5_CTR;
  
  union {
    __IOM uint32_t reg;                         /*!< Counter compare values                                                    */
    
    struct {
      __IOM uint32_t A          : 16;           /*!< A                                                                         */
      __IOM uint32_t B          : 16;           /*!< B                                                                         */
    } bit;
  } CH5_CC;
  
  union {
    __IOM uint32_t reg;                         /*!< Counter wrap value                                                        */
    
    struct {
      __IOM uint32_t CH5_TOP    : 16;           /*!< CH5_TOP                                                                   */
            uint32_t            : 16;
    } bit;
  } CH5_TOP;
  
  union {
    __IOM uint32_t reg;                         /*!< Control and status register                                               */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< Enable the PWM channel.                                                   */
      __IOM uint32_t PH_CORRECT : 1;            /*!< 1: Enable phase-correct modulation. 0: Trailing-edge                      */
      __IOM uint32_t A_INV      : 1;            /*!< Invert output A                                                           */
      __IOM uint32_t B_INV      : 1;            /*!< Invert output B                                                           */
      __IOM uint32_t DIVMODE    : 2;            /*!< DIVMODE                                                                   */
      __OM  uint32_t PH_RET     : 1;            /*!< Retard the phase of the counter by 1 count, while it is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running.                                                               */
      __OM  uint32_t PH_ADV     : 1;            /*!< Advance the phase of the counter by 1 count, while it is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running at less than full speed (div_int + div_frac
                                                     / 16 > 1)                                                                 */
            uint32_t            : 24;
    } bit;
  } CH6_CSR;
  
  union {
    __IOM uint32_t reg;                         /*!< INT and FRAC form a fixed-point fractional number. Counting
                                                     rate is system clock frequency divided by this number.
                                                     Fractional division uses simple 1st-order sigma-delta.                    */
    
    struct {
      __IOM uint32_t FRAC       : 4;            /*!< FRAC                                                                      */
      __IOM uint32_t INT        : 8;            /*!< INT                                                                       */
            uint32_t            : 20;
    } bit;
  } CH6_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Direct access to the PWM counter                                          */
    
    struct {
      __IOM uint32_t CH6_CTR    : 16;           /*!< CH6_CTR                                                                   */
            uint32_t            : 16;
    } bit;
  } CH6_CTR;
  
  union {
    __IOM uint32_t reg;                         /*!< Counter compare values                                                    */
    
    struct {
      __IOM uint32_t A          : 16;           /*!< A                                                                         */
      __IOM uint32_t B          : 16;           /*!< B                                                                         */
    } bit;
  } CH6_CC;
  
  union {
    __IOM uint32_t reg;                         /*!< Counter wrap value                                                        */
    
    struct {
      __IOM uint32_t CH6_TOP    : 16;           /*!< CH6_TOP                                                                   */
            uint32_t            : 16;
    } bit;
  } CH6_TOP;
  
  union {
    __IOM uint32_t reg;                         /*!< Control and status register                                               */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< Enable the PWM channel.                                                   */
      __IOM uint32_t PH_CORRECT : 1;            /*!< 1: Enable phase-correct modulation. 0: Trailing-edge                      */
      __IOM uint32_t A_INV      : 1;            /*!< Invert output A                                                           */
      __IOM uint32_t B_INV      : 1;            /*!< Invert output B                                                           */
      __IOM uint32_t DIVMODE    : 2;            /*!< DIVMODE                                                                   */
      __OM  uint32_t PH_RET     : 1;            /*!< Retard the phase of the counter by 1 count, while it is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running.                                                               */
      __OM  uint32_t PH_ADV     : 1;            /*!< Advance the phase of the counter by 1 count, while it is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running at less than full speed (div_int + div_frac
                                                     / 16 > 1)                                                                 */
            uint32_t            : 24;
    } bit;
  } CH7_CSR;
  
  union {
    __IOM uint32_t reg;                         /*!< INT and FRAC form a fixed-point fractional number. Counting
                                                     rate is system clock frequency divided by this number.
                                                     Fractional division uses simple 1st-order sigma-delta.                    */
    
    struct {
      __IOM uint32_t FRAC       : 4;            /*!< FRAC                                                                      */
      __IOM uint32_t INT        : 8;            /*!< INT                                                                       */
            uint32_t            : 20;
    } bit;
  } CH7_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Direct access to the PWM counter                                          */
    
    struct {
      __IOM uint32_t CH7_CTR    : 16;           /*!< CH7_CTR                                                                   */
            uint32_t            : 16;
    } bit;
  } CH7_CTR;
  
  union {
    __IOM uint32_t reg;                         /*!< Counter compare values                                                    */
    
    struct {
      __IOM uint32_t A          : 16;           /*!< A                                                                         */
      __IOM uint32_t B          : 16;           /*!< B                                                                         */
    } bit;
  } CH7_CC;
  
  union {
    __IOM uint32_t reg;                         /*!< Counter wrap value                                                        */
    
    struct {
      __IOM uint32_t CH7_TOP    : 16;           /*!< CH7_TOP                                                                   */
            uint32_t            : 16;
    } bit;
  } CH7_TOP;
  
  union {
    __IOM uint32_t reg;                         /*!< This register aliases the CSR_EN bits for all channels. Writing
                                                     to this register allows multiple channels to be enabled
                                                     or disabled simultaneously, so they can run in perfect
                                                     sync. For each channel, there is only one physical EN register
                                                     bit, which can be accessed through here or CHx_CSR.                       */
    
    struct {
      __IOM uint32_t CH0        : 1;            /*!< CH0                                                                       */
      __IOM uint32_t CH1        : 1;            /*!< CH1                                                                       */
      __IOM uint32_t CH2        : 1;            /*!< CH2                                                                       */
      __IOM uint32_t CH3        : 1;            /*!< CH3                                                                       */
      __IOM uint32_t CH4        : 1;            /*!< CH4                                                                       */
      __IOM uint32_t CH5        : 1;            /*!< CH5                                                                       */
      __IOM uint32_t CH6        : 1;            /*!< CH6                                                                       */
      __IOM uint32_t CH7        : 1;            /*!< CH7                                                                       */
            uint32_t            : 24;
    } bit;
  } EN;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw Interrupts                                                            */
    
    struct {
      __IOM uint32_t CH0        : 1;            /*!< CH0                                                                       */
      __IOM uint32_t CH1        : 1;            /*!< CH1                                                                       */
      __IOM uint32_t CH2        : 1;            /*!< CH2                                                                       */
      __IOM uint32_t CH3        : 1;            /*!< CH3                                                                       */
      __IOM uint32_t CH4        : 1;            /*!< CH4                                                                       */
      __IOM uint32_t CH5        : 1;            /*!< CH5                                                                       */
      __IOM uint32_t CH6        : 1;            /*!< CH6                                                                       */
      __IOM uint32_t CH7        : 1;            /*!< CH7                                                                       */
            uint32_t            : 24;
    } bit;
  } INTR;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable                                                          */
    
    struct {
      __IOM uint32_t CH0        : 1;            /*!< CH0                                                                       */
      __IOM uint32_t CH1        : 1;            /*!< CH1                                                                       */
      __IOM uint32_t CH2        : 1;            /*!< CH2                                                                       */
      __IOM uint32_t CH3        : 1;            /*!< CH3                                                                       */
      __IOM uint32_t CH4        : 1;            /*!< CH4                                                                       */
      __IOM uint32_t CH5        : 1;            /*!< CH5                                                                       */
      __IOM uint32_t CH6        : 1;            /*!< CH6                                                                       */
      __IOM uint32_t CH7        : 1;            /*!< CH7                                                                       */
            uint32_t            : 24;
    } bit;
  } INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force                                                           */
    
    struct {
      __IOM uint32_t CH0        : 1;            /*!< CH0                                                                       */
      __IOM uint32_t CH1        : 1;            /*!< CH1                                                                       */
      __IOM uint32_t CH2        : 1;            /*!< CH2                                                                       */
      __IOM uint32_t CH3        : 1;            /*!< CH3                                                                       */
      __IOM uint32_t CH4        : 1;            /*!< CH4                                                                       */
      __IOM uint32_t CH5        : 1;            /*!< CH5                                                                       */
      __IOM uint32_t CH6        : 1;            /*!< CH6                                                                       */
      __IOM uint32_t CH7        : 1;            /*!< CH7                                                                       */
            uint32_t            : 24;
    } bit;
  } INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing                                  */
    
    struct {
      __IM  uint32_t CH0        : 1;            /*!< CH0                                                                       */
      __IM  uint32_t CH1        : 1;            /*!< CH1                                                                       */
      __IM  uint32_t CH2        : 1;            /*!< CH2                                                                       */
      __IM  uint32_t CH3        : 1;            /*!< CH3                                                                       */
      __IM  uint32_t CH4        : 1;            /*!< CH4                                                                       */
      __IM  uint32_t CH5        : 1;            /*!< CH5                                                                       */
      __IM  uint32_t CH6        : 1;            /*!< CH6                                                                       */
      __IM  uint32_t CH7        : 1;            /*!< CH7                                                                       */
            uint32_t            : 24;
    } bit;
  } INTS;
} PWM_Type;                                     /*!< Size = 180 (0xb4)                                                         */



/* =========================================================================================================================== */
/* ================                                            ADC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Control and data interface to SAR ADC (ADC)
  */

typedef struct {                                /*!< ADC Structure                                                             */
  
  union {
    __IOM uint32_t reg;                         /*!< ADC Control and Status                                                    */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< Power on ADC and enable its clock. 1 - enabled. 0 - disabled.             */
      __IOM uint32_t TS_EN      : 1;            /*!< Power on temperature sensor. 1 - enabled. 0 - disabled.                   */
      __OM  uint32_t START_ONCE : 1;            /*!< Start a single conversion. Self-clearing. Ignored if start_many
                                                     is asserted.                                                              */
      __IOM uint32_t START_MANY : 1;            /*!< Continuously perform conversions whilst this bit is 1. A new
                                                     conversion will start immediately after the previous finishes.            */
            uint32_t            : 4;
      __IM  uint32_t READY      : 1;            /*!< 1 if the ADC is ready to start a new conversion. Implies any
                                                     previous conversion has completed. 0 whilst conversion
                                                     in progress.                                                              */
      __IM  uint32_t ERR        : 1;            /*!< The most recent ADC conversion encountered an error; result
                                                     is undefined or noisy.                                                    */
      __IOM uint32_t ERR_STICKY : 1;            /*!< Some past ADC conversion encountered an error. Write 1 to clear.          */
            uint32_t            : 1;
      __IOM uint32_t AINSEL     : 3;            /*!< Select analog mux input. Updated automatically in round-robin
                                                     mode.                                                                     */
            uint32_t            : 1;
      __IOM uint32_t RROBIN     : 5;            /*!< Round-robin sampling. 1 bit per channel. Set all bits to 0 to
                                                     disable. Otherwise, the ADC will cycle through each enabled
                                                     channel in a round-robin fashion. The first channel to
                                                     be sampled will be the one currently indicated by AINSEL.
                                                     AINSEL will be updated after each conversion with the newly-selected
                                                     channel.                                                                  */
            uint32_t            : 11;
    } bit;
  } CS;
  
  union {
    __IOM uint32_t reg;                         /*!< Result of most recent ADC conversion                                      */
    
    struct {
      __IM  uint32_t RESULT     : 12;           /*!< RESULT                                                                    */
            uint32_t            : 20;
    } bit;
  } RESULT;
  
  union {
    __IOM uint32_t reg;                         /*!< FIFO control and status                                                   */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< If 1: write result to the FIFO after each conversion.                     */
      __IOM uint32_t SHIFT      : 1;            /*!< If 1: FIFO results are right-shifted to be one byte in size.
                                                     Enables DMA to byte buffers.                                              */
      __IOM uint32_t ERR        : 1;            /*!< If 1: conversion error bit appears in the FIFO alongside the
                                                     result                                                                    */
      __IOM uint32_t DREQ_EN    : 1;            /*!< If 1: assert DMA requests when FIFO contains data                         */
            uint32_t            : 4;
      __IM  uint32_t EMPTY      : 1;            /*!< EMPTY                                                                     */
      __IM  uint32_t FULL       : 1;            /*!< FULL                                                                      */
      __IOM uint32_t UNDER      : 1;            /*!< 1 if the FIFO has been underflowed. Write 1 to clear.                     */
      __IOM uint32_t OVER       : 1;            /*!< 1 if the FIFO has been overflowed. Write 1 to clear.                      */
            uint32_t            : 4;
      __IM  uint32_t LEVEL      : 4;            /*!< The number of conversion results currently waiting in the FIFO            */
            uint32_t            : 4;
      __IOM uint32_t THRESH     : 4;            /*!< DREQ/IRQ asserted when level >= threshold                                 */
            uint32_t            : 4;
    } bit;
  } FCS;
  
  union {
    __IOM uint32_t reg;                         /*!< Conversion result FIFO                                                    */
    
    struct {
      __IM  uint32_t VAL        : 12;           /*!< VAL                                                                       */
            uint32_t            : 3;
      __IM  uint32_t ERR        : 1;            /*!< 1 if this particular sample experienced a conversion error.
                                                     Remains in the same location if the sample is shifted.                    */
            uint32_t            : 16;
    } bit;
  } FIFO;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock divider. If non-zero, CS_START_MANY will start conversions
                                                     at regular intervals rather than back-to-back. The divider
                                                     is reset when either of these fields are written. Total
                                                     period is 1 + INT + FRAC / 256                                            */
    
    struct {
      __IOM uint32_t FRAC       : 8;            /*!< Fractional part of clock divisor. First-order delta-sigma.                */
      __IOM uint32_t INT        : 16;           /*!< Integer part of clock divisor.                                            */
            uint32_t            : 8;
    } bit;
  } DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw Interrupts                                                            */
    
    struct {
      __IM  uint32_t FIFO       : 1;            /*!< Triggered when the sample FIFO reaches a certain level. This
                                                     level can be programmed via the FCS_THRESH field.                         */
            uint32_t            : 31;
    } bit;
  } INTR;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable                                                          */
    
    struct {
      __IOM uint32_t FIFO       : 1;            /*!< Triggered when the sample FIFO reaches a certain level. This
                                                     level can be programmed via the FCS_THRESH field.                         */
            uint32_t            : 31;
    } bit;
  } INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force                                                           */
    
    struct {
      __IOM uint32_t FIFO       : 1;            /*!< Triggered when the sample FIFO reaches a certain level. This
                                                     level can be programmed via the FCS_THRESH field.                         */
            uint32_t            : 31;
    } bit;
  } INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing                                  */
    
    struct {
      __IM  uint32_t FIFO       : 1;            /*!< Triggered when the sample FIFO reaches a certain level. This
                                                     level can be programmed via the FCS_THRESH field.                         */
            uint32_t            : 31;
    } bit;
  } INTS;
} ADC_Type;                                     /*!< Size = 36 (0x24)                                                          */



/* =========================================================================================================================== */
/* ================                                           I2C0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief DW_apb_i2c address block

            List of configuration constants for the Synopsys I2C hardware (you may see references to these in I2C register header; these are *fixed* values, set at hardware design time):

            IC_ULTRA_FAST_MODE ................ 0x0 
            IC_UFM_TBUF_CNT_DEFAULT ........... 0x8 
            IC_UFM_SCL_LOW_COUNT .............. 0x0008 
            IC_UFM_SCL_HIGH_COUNT ............. 0x0006 
            IC_TX_TL .......................... 0x0 
            IC_TX_CMD_BLOCK ................... 0x1 
            IC_HAS_DMA ........................ 0x1 
            IC_HAS_ASYNC_FIFO ................. 0x0 
            IC_SMBUS_ARP ...................... 0x0 
            IC_FIRST_DATA_BYTE_STATUS ......... 0x1 
            IC_INTR_IO ........................ 0x1 
            IC_MASTER_MODE .................... 0x1 
            IC_DEFAULT_ACK_GENERAL_CALL ....... 0x1 
            IC_INTR_POL ....................... 0x1 
            IC_OPTIONAL_SAR ................... 0x0 
            IC_DEFAULT_TAR_SLAVE_ADDR ......... 0x055 
            IC_DEFAULT_SLAVE_ADDR ............. 0x055 
            IC_DEFAULT_HS_SPKLEN .............. 0x1 
            IC_FS_SCL_HIGH_COUNT .............. 0x0006 
            IC_HS_SCL_LOW_COUNT ............... 0x0008 
            IC_DEVICE_ID_VALUE ................ 0x0 
            IC_10BITADDR_MASTER ............... 0x0 
            IC_CLK_FREQ_OPTIMIZATION .......... 0x0 
            IC_DEFAULT_FS_SPKLEN .............. 0x7 
            IC_ADD_ENCODED_PARAMS ............. 0x0 
            IC_DEFAULT_SDA_HOLD ............... 0x000001 
            IC_DEFAULT_SDA_SETUP .............. 0x64 
            IC_AVOID_RX_FIFO_FLUSH_ON_TX_ABRT . 0x0 
            IC_CLOCK_PERIOD ................... 100 
            IC_EMPTYFIFO_HOLD_MASTER_EN ....... 1 
            IC_RESTART_EN ..................... 0x1 
            IC_TX_CMD_BLOCK_DEFAULT ........... 0x0 
            IC_BUS_CLEAR_FEATURE .............. 0x0 
            IC_CAP_LOADING .................... 100 
            IC_FS_SCL_LOW_COUNT ............... 0x000d 
            APB_DATA_WIDTH .................... 32 
            IC_SDA_STUCK_TIMEOUT_DEFAULT ...... 0xffffffff 
            IC_SLV_DATA_NACK_ONLY ............. 0x1 
            IC_10BITADDR_SLAVE ................ 0x0 
            IC_CLK_TYPE ....................... 0x0 
            IC_SMBUS_UDID_MSB ................. 0x0 
            IC_SMBUS_SUSPEND_ALERT ............ 0x0 
            IC_HS_SCL_HIGH_COUNT .............. 0x0006 
            IC_SLV_RESTART_DET_EN ............. 0x1 
            IC_SMBUS .......................... 0x0 
            IC_OPTIONAL_SAR_DEFAULT ........... 0x0 
            IC_PERSISTANT_SLV_ADDR_DEFAULT .... 0x0 
            IC_USE_COUNTS ..................... 0x0 
            IC_RX_BUFFER_DEPTH ................ 16 
            IC_SCL_STUCK_TIMEOUT_DEFAULT ...... 0xffffffff 
            IC_RX_FULL_HLD_BUS_EN ............. 0x1 
            IC_SLAVE_DISABLE .................. 0x1 
            IC_RX_TL .......................... 0x0 
            IC_DEVICE_ID ...................... 0x0 
            IC_HC_COUNT_VALUES ................ 0x0 
            I2C_DYNAMIC_TAR_UPDATE ............ 0 
            IC_SMBUS_CLK_LOW_MEXT_DEFAULT ..... 0xffffffff 
            IC_SMBUS_CLK_LOW_SEXT_DEFAULT ..... 0xffffffff 
            IC_HS_MASTER_CODE ................. 0x1 
            IC_SMBUS_RST_IDLE_CNT_DEFAULT ..... 0xffff 
            IC_SMBUS_UDID_LSB_DEFAULT ......... 0xffffffff 
            IC_SS_SCL_HIGH_COUNT .............. 0x0028 
            IC_SS_SCL_LOW_COUNT ............... 0x002f 
            IC_MAX_SPEED_MODE ................. 0x2 
            IC_STAT_FOR_CLK_STRETCH ........... 0x0 
            IC_STOP_DET_IF_MASTER_ACTIVE ...... 0x0 
            IC_DEFAULT_UFM_SPKLEN ............. 0x1 
            IC_TX_BUFFER_DEPTH ................ 16 (I2C0)
  */

typedef struct {                                /*!< I2C0 Structure                                                            */
  
  union {
    __IOM uint32_t reg;                         /*!< I2C Control Register. This register can be written only when
                                                     the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0]
                                                     register being set to 0. Writes at other times have no
                                                     effect. Read/Write Access: - bit 10 is read only. - bit
                                                     11 is read only - bit 16 is read only - bit 17 is read
                                                     only - bits 18 and 19 are read only.                                      */
    
    struct {
      __IOM uint32_t MASTER_MODE : 1;           /*!< This bit controls whether the DW_apb_i2c master is enabled.
                                                     NOTE: Software should ensure that if this bit is written
                                                     with '1' then bit 6 should also be written with a '1'.                    */
      __IOM uint32_t SPEED      : 2;            /*!< These bits control at which speed the DW_apb_i2c operates; its
                                                     setting is relevant only if one is operating the DW_apb_i2c
                                                     in master mode. Hardware protects against illegal values
                                                     being programmed by software. These bits must be programmed
                                                     appropriately for slave mode also, as it is used to capture
                                                     correct value of spike filter as per the speed mode. This
                                                     register should be programmed only with a value in the
                                                     range of 1 to IC_MAX_SPEED_MODE; otherwise, hardware updates
                                                     this register with the value of IC_MAX_SPEED_MODE. 1: standard
                                                     mode (100 kbit/s) 2: fast mode (<=400 kbit/s) or fast mode
                                                     plus (<=1000Kbit/s) 3: high speed mode (3.4 Mbit/s) Note:
                                                     This field is not applicable when IC_ULTRA_FAST_MODE=1                    */
      __IOM uint32_t IC_10BITADDR_SLAVE : 1;    /*!< When acting as a slave, this bit controls whether the DW_apb_i2c
                                                     responds to 7- or 10-bit addresses. - 0: 7-bit addressing.
                                                     The DW_apb_i2c ignores transactions that involve 10-bit
                                                     addressing; for 7-bit addressing, only the lower 7 bits
                                                     of the IC_SAR register are compared. - 1: 10-bit addressing.
                                                     The DW_apb_i2c responds to only 10-bit addressing transfers
                                                     that match the full 10 bits of the IC_SAR register.                       */
      __IOM uint32_t IC_10BITADDR_MASTER : 1;   /*!< Controls whether the DW_apb_i2c starts its transfers in 7- or
                                                     10-bit addressing mode when acting as a master. - 0: 7-bit
                                                     addressing - 1: 10-bit addressing                                         */
      __IOM uint32_t IC_RESTART_EN : 1;         /*!< Determines whether RESTART conditions may be sent when acting
                                                     as a master. Some older slaves do not support handling
                                                     RESTART conditions; however, RESTART conditions are used
                                                     in several DW_apb_i2c operations. When RESTART is disabled,
                                                     the master is prohibited from performing the following
                                                     functions: - Sending a START BYTE - Performing any high-speed
                                                     mode operation - High-speed mode operation - Performing
                                                     direction changes in combined format mode - Performing
                                                     a read operation with a 10-bit address By replacing RESTART
                                                     condition followed by a STOP and a subsequent START condition,
                                                     split operations are broken down into multiple DW_apb_i2c
                                                     transfers. If the above operations are performed, it will
                                                     result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT
                                                     register. Reset value: ENABLED                                            */
      __IOM uint32_t IC_SLAVE_DISABLE : 1;      /*!< This bit controls whether I2C has its slave disabled, which
                                                     means once the presetn signal is applied, then this bit
                                                     is set and the slave is disabled. If this bit is set (slave
                                                     is disabled), DW_apb_i2c functions only as a master and
                                                     does not perform any action that requires a slave. NOTE:
                                                     Software should ensure that if this bit is written with
                                                     0, then bit 0 should also be written with a 0.                            */
      __IOM uint32_t STOP_DET_IFADDRESSED : 1;  /*!< In slave mode: - 1'b1: issues the STOP_DET interrupt only when
                                                     it is addressed. - 1'b0: issues the STOP_DET irrespective
                                                     of whether it's addressed or not. Reset value: 0x0 NOTE:
                                                     During a general call address, this slave does not issue
                                                     the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1'b1,
                                                     even if the slave responds to the general call address
                                                     by generating ACK. The STOP_DET interrupt is generated
                                                     only when the transmitted address matches the slave address
                                                     (SAR).                                                                    */
      __IOM uint32_t TX_EMPTY_CTRL : 1;         /*!< This bit controls the generation of the TX_EMPTY interrupt,
                                                     as described in the IC_RAW_INTR_STAT register. Reset value:
                                                     0x0.                                                                      */
      __IOM uint32_t RX_FIFO_FULL_HLD_CTRL : 1; /*!< This bit controls whether DW_apb_i2c should hold the bus when
                                                     the Rx FIFO is physically full to its RX_BUFFER_DEPTH,
                                                     as described in the IC_RX_FULL_HLD_BUS_EN parameter. Reset
                                                     value: 0x0.                                                               */
      __IM  uint32_t STOP_DET_IF_MASTER_ACTIVE : 1;/*!< Master issues the STOP_DET interrupt irrespective of whether
                                                     master is active or not                                                   */
            uint32_t            : 21;
    } bit;
  } IC_CON;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C Target Address Register This register is 12 bits wide, and
                                                     bits 31:12 are reserved. This register can be written to
                                                     only when IC_ENABLE[0] is set to 0. Note: If the software
                                                     or application is aware that the DW_apb_i2c is not using
                                                     the TAR address for the pending commands in the Tx FIFO,
                                                     then it is possible to update the TAR address even while
                                                     the Tx FIFO has entries (IC_STATUS[2]= 0). - It is not
                                                     necessary to perform any write to this register if DW_apb_i2c
                                                     is enabled as an I2C slave only.                                          */
    
    struct {
      __IOM uint32_t IC_TAR     : 10;           /*!< This is the target address for any master transaction. When
                                                     transmitting a General Call, these bits are ignored. To
                                                     generate a START BYTE, the CPU needs to write only once
                                                     into these bits. If the IC_TAR and IC_SAR are the same,
                                                     loopback exists but the FIFOs are shared between master
                                                     and slave, so full loopback is not feasible. Only one direction
                                                     loopback mode is supported (simplex), not duplex. A master
                                                     cannot transmit to itself; it can transmit to only a slave.               */
      __IOM uint32_t GC_OR_START : 1;           /*!< If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set
                                                     to 0, then this bit indicates whether a General Call or
                                                     START byte command is to be performed by the DW_apb_i2c.
                                                     - 0: General Call Address - after issuing a General Call,
                                                     only writes may be performed. Attempting to issue a read
                                                     command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT
                                                     register. The DW_apb_i2c remains in General Call mode until
                                                     the SPECIAL bit value (bit 11) is cleared. - 1: START BYTE
                                                     Reset value: 0x0                                                          */
      __IOM uint32_t SPECIAL    : 1;            /*!< This bit indicates whether software performs a Device-ID or
                                                     General Call or START BYTE command. - 0: ignore bit 10
                                                     GC_OR_START and use IC_TAR normally - 1: perform special
                                                     I2C command as specified in Device_ID or GC_OR_START bit
                                                     Reset value: 0x0                                                          */
            uint32_t            : 20;
    } bit;
  } IC_TAR;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C Slave Address Register                                                */
    
    struct {
      __IOM uint32_t IC_SAR     : 10;           /*!< The IC_SAR holds the slave address when the I2C is operating
                                                     as a slave. For 7-bit addressing, only IC_SAR[6:0] is used.
                                                     This register can be written only when the I2C interface
                                                     is disabled, which corresponds to the IC_ENABLE[0] register
                                                     being set to 0. Writes at other times have no effect. Note:
                                                     The default values cannot be any of the reserved address
                                                     locations: that is, 0x00 to 0x07, or 0x78 to 0x7f. The
                                                     correct operation of the device is not guaranteed if you
                                                     program the IC_SAR or IC_TAR to a reserved value. Refer
                                                     to <<table_I2C_firstbyte_bit_defs>> for a complete list
                                                     of these reserved values.                                                 */
            uint32_t            : 22;
    } bit;
  } IC_SAR;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C Rx/Tx Data Buffer and Command Register; this is the register
                                                     the CPU writes to when filling the TX FIFO and the CPU
                                                     reads from when retrieving bytes from RX FIFO. The size
                                                     of the register changes as follows: Write: - 11 bits when
                                                     IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0
                                                     Read: - 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1 - 8
                                                     bits when IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order
                                                     for the DW_apb_i2c to continue acknowledging reads, a read
                                                     command should be written for every byte that is to be
                                                     received; otherwise the DW_apb_i2c will stop acknowledging.               */
    
    struct {
      __IOM uint32_t DAT        : 8;            /*!< This register contains the data to be transmitted or received
                                                     on the I2C bus. If you are writing to this register and
                                                     want to perform a read, bits 7:0 (DAT) are ignored by the
                                                     DW_apb_i2c. However, when you read this register, these
                                                     bits return the value of data received on the DW_apb_i2c
                                                     interface. Reset value: 0x0                                               */
      __OM  uint32_t CMD        : 1;            /*!< This bit controls whether a read or a write is performed. This
                                                     bit does not control the direction when the DW_apb_i2con
                                                     acts as a slave. It controls only the direction when it
                                                     acts as a master. When a command is entered in the TX FIFO,
                                                     this bit distinguishes the write and read commands. In
                                                     slave-receiver mode, this bit is a 'don't care' because
                                                     writes to this register are not required. In slave-transmitter
                                                     mode, a '0' indicates that the data in IC_DATA_CMD is to
                                                     be transmitted. When programming this bit, you should remember
                                                     the following: attempting to perform a read operation after
                                                     a General Call command has been sent results in a TX_ABRT
                                                     interrupt (bit 6 of the IC_RAW_INTR_STAT register), unless
                                                     bit 11 (SPECIAL) in the IC_TAR register has been cleared.
                                                     If a '1' is written to this bit after receiving a RD_REQ
                                                     interrupt, then a TX_ABRT interrupt occurs. Reset value:
                                                     0x0                                                                       */
      __OM  uint32_t STOP       : 1;            /*!< This bit controls whether a STOP is issued after the byte is
                                                     sent or received. - 1 - STOP is issued after this byte,
                                                     regardless of whether or not the Tx FIFO is empty. If the
                                                     Tx FIFO is not empty, the master immediately tries to start
                                                     a new transfer by issuing a START and arbitrating for the
                                                     bus. - 0 - STOP is not issued after this byte, regardless
                                                     of whether or not the Tx FIFO is empty. If the Tx FIFO
                                                     is not empty, the master continues the current transfer
                                                     by sending/receiving data bytes according to the value
                                                     of the CMD bit. If the Tx FIFO is empty, the master holds
                                                     the SCL line low and stalls the bus until a new command
                                                     is available in the Tx FIFO. Reset value: 0x0                             */
      __OM  uint32_t RESTART    : 1;            /*!< This bit controls whether a RESTART is issued before the byte
                                                     is sent or received. 1 - If IC_RESTART_EN is 1, a RESTART
                                                     is issued before the data is sent/received (according to
                                                     the value of CMD), regardless of whether or not the transfer
                                                     direction is changing from the previous command; if IC_RESTART_EN
                                                     is 0, a STOP followed by a START is issued instead. 0 -
                                                     If IC_RESTART_EN is 1, a RESTART is issued only if the
                                                     transfer direction is changing from the previous command;
                                                     if IC_RESTART_EN is 0, a STOP followed by a START is issued
                                                     instead. Reset value: 0x0                                                 */
      __IM  uint32_t FIRST_DATA_BYTE : 1;       /*!< Indicates the first data byte received after the address phase
                                                     for receive transfer in Master receiver or Slave receiver
                                                     mode. Reset value : 0x0 NOTE: In case of APB_DATA_WIDTH=8,
                                                     1. The user has to perform two APB Reads to IC_DATA_CMD
                                                     in order to get status on 11 bit. 2. In order to read the
                                                     11 bit, the user has to perform the first data byte read
                                                     [7:0] (offset 0x10) and then perform the second read [15:8]
                                                     (offset 0x11) in order to know the status of 11 bit (whether
                                                     the data received in previous read is a first data byte
                                                     or not). 3. The 11th bit is an optional read field, user
                                                     can ignore 2nd byte read [15:8] (offset 0x11) if not interested
                                                     in FIRST_DATA_BYTE status.                                                */
            uint32_t            : 20;
    } bit;
  } IC_DATA_CMD;
  
  union {
    __IOM uint32_t reg;                         /*!< Standard Speed I2C Clock SCL High Count Register                          */
    
    struct {
      __IOM uint32_t IC_SS_SCL_HCNT : 16;       /*!< This register must be set before any I2C bus transaction can
                                                     take place to ensure proper I/O timing. This register sets
                                                     the SCL clock high-period count for standard speed. For
                                                     more information, refer to 'IC_CLK Frequency Configuration'.
                                                     This register can be written only when the I2C interface
                                                     is disabled which corresponds to the IC_ENABLE[0] register
                                                     being set to 0. Writes at other times have no effect. The
                                                     minimum valid value is 6; hardware prevents values less
                                                     than this being written, and if attempted results in 6
                                                     being set. For designs with APB_DATA_WIDTH = 8, the order
                                                     of programming is important to ensure the correct operation
                                                     of the DW_apb_i2c. The lower byte must be programmed first.
                                                     Then the upper byte is programmed. NOTE: This register
                                                     must not be programmed to a value higher than 65525, because
                                                     DW_apb_i2c uses a 16-bit counter to flag an I2C bus idle
                                                     condition when this counter reaches a value of IC_SS_SCL_HCNT
                                                     + 10.                                                                     */
            uint32_t            : 16;
    } bit;
  } IC_SS_SCL_HCNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Standard Speed I2C Clock SCL Low Count Register                           */
    
    struct {
      __IOM uint32_t IC_SS_SCL_LCNT : 16;       /*!< This register must be set before any I2C bus transaction can
                                                     take place to ensure proper I/O timing. This register sets
                                                     the SCL clock low period count for standard speed. For
                                                     more information, refer to 'IC_CLK Frequency Configuration'
                                                     This register can be written only when the I2C interface
                                                     is disabled which corresponds to the IC_ENABLE[0] register
                                                     being set to 0. Writes at other times have no effect. The
                                                     minimum valid value is 8; hardware prevents values less
                                                     than this being written, and if attempted, results in 8
                                                     being set. For designs with APB_DATA_WIDTH = 8, the order
                                                     of programming is important to ensure the correct operation
                                                     of DW_apb_i2c. The lower byte must be programmed first,
                                                     and then the upper byte is programmed.                                    */
            uint32_t            : 16;
    } bit;
  } IC_SS_SCL_LCNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register             */
    
    struct {
      __IOM uint32_t IC_FS_SCL_HCNT : 16;       /*!< This register must be set before any I2C bus transaction can
                                                     take place to ensure proper I/O timing. This register sets
                                                     the SCL clock high-period count for fast mode or fast mode
                                                     plus. It is used in high-speed mode to send the Master
                                                     Code and START BYTE or General CALL. For more information,
                                                     refer to 'IC_CLK Frequency Configuration'. This register
                                                     goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE
                                                     = standard. This register can be written only when the
                                                     I2C interface is disabled, which corresponds to the IC_ENABLE[0]
                                                     register being set to 0. Writes at other times have no
                                                     effect. The minimum valid value is 6; hardware prevents
                                                     values less than this being written, and if attempted results
                                                     in 6 being set. For designs with APB_DATA_WIDTH == 8 the
                                                     order of programming is important to ensure the correct
                                                     operation of the DW_apb_i2c. The lower byte must be programmed
                                                     first. Then the upper byte is programmed.                                 */
            uint32_t            : 16;
    } bit;
  } IC_FS_SCL_HCNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register              */
    
    struct {
      __IOM uint32_t IC_FS_SCL_LCNT : 16;       /*!< This register must be set before any I2C bus transaction can
                                                     take place to ensure proper I/O timing. This register sets
                                                     the SCL clock low period count for fast speed. It is used
                                                     in high-speed mode to send the Master Code and START BYTE
                                                     or General CALL. For more information, refer to 'IC_CLK
                                                     Frequency Configuration'. This register goes away and becomes
                                                     read-only returning 0s if IC_MAX_SPEED_MODE = standard.
                                                     This register can be written only when the I2C interface
                                                     is disabled, which corresponds to the IC_ENABLE[0] register
                                                     being set to 0. Writes at other times have no effect. The
                                                     minimum valid value is 8; hardware prevents values less
                                                     than this being written, and if attempted results in 8
                                                     being set. For designs with APB_DATA_WIDTH = 8 the order
                                                     of programming is important to ensure the correct operation
                                                     of the DW_apb_i2c. The lower byte must be programmed first.
                                                     Then the upper byte is programmed. If the value is less
                                                     than 8 then the count value gets changed to 8.                            */
            uint32_t            : 16;
    } bit;
  } IC_FS_SCL_LCNT;
  __IM  uint32_t  RESERVED1[2];
  
  union {
    __IOM uint32_t reg;                         /*!< I2C Interrupt Status Register Each bit in this register has
                                                     a corresponding mask bit in the IC_INTR_MASK register.
                                                     These bits are cleared by reading the matching interrupt
                                                     clear register. The unmasked raw versions of these bits
                                                     are available in the IC_RAW_INTR_STAT register.                           */
    
    struct {
      __IM  uint32_t R_RX_UNDER : 1;            /*!< See IC_RAW_INTR_STAT for a detailed description of R_RX_UNDER
                                                     bit. Reset value: 0x0                                                     */
      __IM  uint32_t R_RX_OVER  : 1;            /*!< See IC_RAW_INTR_STAT for a detailed description of R_RX_OVER
                                                     bit. Reset value: 0x0                                                     */
      __IM  uint32_t R_RX_FULL  : 1;            /*!< See IC_RAW_INTR_STAT for a detailed description of R_RX_FULL
                                                     bit. Reset value: 0x0                                                     */
      __IM  uint32_t R_TX_OVER  : 1;            /*!< See IC_RAW_INTR_STAT for a detailed description of R_TX_OVER
                                                     bit. Reset value: 0x0                                                     */
      __IM  uint32_t R_TX_EMPTY : 1;            /*!< See IC_RAW_INTR_STAT for a detailed description of R_TX_EMPTY
                                                     bit. Reset value: 0x0                                                     */
      __IM  uint32_t R_RD_REQ   : 1;            /*!< See IC_RAW_INTR_STAT for a detailed description of R_RD_REQ
                                                     bit. Reset value: 0x0                                                     */
      __IM  uint32_t R_TX_ABRT  : 1;            /*!< See IC_RAW_INTR_STAT for a detailed description of R_TX_ABRT
                                                     bit. Reset value: 0x0                                                     */
      __IM  uint32_t R_RX_DONE  : 1;            /*!< See IC_RAW_INTR_STAT for a detailed description of R_RX_DONE
                                                     bit. Reset value: 0x0                                                     */
      __IM  uint32_t R_ACTIVITY : 1;            /*!< See IC_RAW_INTR_STAT for a detailed description of R_ACTIVITY
                                                     bit. Reset value: 0x0                                                     */
      __IM  uint32_t R_STOP_DET : 1;            /*!< See IC_RAW_INTR_STAT for a detailed description of R_STOP_DET
                                                     bit. Reset value: 0x0                                                     */
      __IM  uint32_t R_START_DET : 1;           /*!< See IC_RAW_INTR_STAT for a detailed description of R_START_DET
                                                     bit. Reset value: 0x0                                                     */
      __IM  uint32_t R_GEN_CALL : 1;            /*!< See IC_RAW_INTR_STAT for a detailed description of R_GEN_CALL
                                                     bit. Reset value: 0x0                                                     */
      __IM  uint32_t R_RESTART_DET : 1;         /*!< See IC_RAW_INTR_STAT for a detailed description of R_RESTART_DET
                                                     bit. Reset value: 0x0                                                     */
            uint32_t            : 19;
    } bit;
  } IC_INTR_STAT;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C Interrupt Mask Register. These bits mask their corresponding
                                                     interrupt status bits. This register is active low; a value
                                                     of 0 masks the interrupt, whereas a value of 1 unmasks
                                                     the interrupt.                                                            */
    
    struct {
      __IOM uint32_t M_RX_UNDER : 1;            /*!< This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.
                                                     Reset value: 0x1                                                          */
      __IOM uint32_t M_RX_OVER  : 1;            /*!< This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.
                                                     Reset value: 0x1                                                          */
      __IOM uint32_t M_RX_FULL  : 1;            /*!< This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.
                                                     Reset value: 0x1                                                          */
      __IOM uint32_t M_TX_OVER  : 1;            /*!< This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.
                                                     Reset value: 0x1                                                          */
      __IOM uint32_t M_TX_EMPTY : 1;            /*!< This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.
                                                     Reset value: 0x1                                                          */
      __IOM uint32_t M_RD_REQ   : 1;            /*!< This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.
                                                     Reset value: 0x1                                                          */
      __IOM uint32_t M_TX_ABRT  : 1;            /*!< This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.
                                                     Reset value: 0x1                                                          */
      __IOM uint32_t M_RX_DONE  : 1;            /*!< This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.
                                                     Reset value: 0x1                                                          */
      __IOM uint32_t M_ACTIVITY : 1;            /*!< This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.
                                                     Reset value: 0x0                                                          */
      __IOM uint32_t M_STOP_DET : 1;            /*!< This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.
                                                     Reset value: 0x0                                                          */
      __IOM uint32_t M_START_DET : 1;           /*!< This bit masks the R_START_DET interrupt in IC_INTR_STAT register.
                                                     Reset value: 0x0                                                          */
      __IOM uint32_t M_GEN_CALL : 1;            /*!< This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.
                                                     Reset value: 0x1                                                          */
      __IOM uint32_t M_RESTART_DET : 1;         /*!< This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.
                                                     Reset value: 0x0                                                          */
            uint32_t            : 19;
    } bit;
  } IC_INTR_MASK;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C Raw Interrupt Status Register Unlike the IC_INTR_STAT register,
                                                     these bits are not masked so they always show the true
                                                     status of the DW_apb_i2c.                                                 */
    
    struct {
      __IM  uint32_t RX_UNDER   : 1;            /*!< Set if the processor attempts to read the receive buffer when
                                                     it is empty by reading from the IC_DATA_CMD register. If
                                                     the module is disabled (IC_ENABLE[0]=0), this bit keeps
                                                     its level until the master or slave state machines go into
                                                     idle, and when ic_en goes to 0, this interrupt is cleared.
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t RX_OVER    : 1;            /*!< Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH
                                                     and an additional byte is received from an external I2C
                                                     device. The DW_apb_i2c acknowledges this, but any data
                                                     bytes received after the FIFO is full are lost. If the
                                                     module is disabled (IC_ENABLE[0]=0), this bit keeps its
                                                     level until the master or slave state machines go into
                                                     idle, and when ic_en goes to 0, this interrupt is cleared.
                                                     Note: If bit 9 of the IC_CON register (RX_FIFO_FULL_HLD_CTRL)
                                                     is programmed to HIGH, then the RX_OVER interrupt never
                                                     occurs, because the Rx FIFO never overflows. Reset value:
                                                     0x0                                                                       */
      __IM  uint32_t RX_FULL    : 1;            /*!< Set when the receive buffer reaches or goes above the RX_TL
                                                     threshold in the IC_RX_TL register. It is automatically
                                                     cleared by hardware when buffer level goes below the threshold.
                                                     If the module is disabled (IC_ENABLE[0]=0), the RX FIFO
                                                     is flushed and held in reset; therefore the RX FIFO is
                                                     not full. So this bit is cleared once the IC_ENABLE bit
                                                     0 is programmed with a 0, regardless of the activity that
                                                     continues. Reset value: 0x0                                               */
      __IM  uint32_t TX_OVER    : 1;            /*!< Set during transmit if the transmit buffer is filled to IC_TX_BUFFER_DEPTH
                                                     and the processor attempts to issue another I2C command
                                                     by writing to the IC_DATA_CMD register. When the module
                                                     is disabled, this bit keeps its level until the master
                                                     or slave state machines go into idle, and when ic_en goes
                                                     to 0, this interrupt is cleared. Reset value: 0x0                         */
      __IM  uint32_t TX_EMPTY   : 1;            /*!< The behavior of the TX_EMPTY interrupt status differs based
                                                     on the TX_EMPTY_CTRL selection in the IC_CON register.
                                                     - When TX_EMPTY_CTRL = 0: This bit is set to 1 when the
                                                     transmit buffer is at or below the threshold value set
                                                     in the IC_TX_TL register. - When TX_EMPTY_CTRL = 1: This
                                                     bit is set to 1 when the transmit buffer is at or below
                                                     the threshold value set in the IC_TX_TL register and the
                                                     transmission of the address/data from the internal shift
                                                     register for the most recently popped command is completed.
                                                     It is automatically cleared by hardware when the buffer
                                                     level goes above the threshold. When IC_ENABLE[0] is set
                                                     to 0, the TX FIFO is flushed and held in reset. There the
                                                     TX FIFO looks like it has no data within it, so this bit
                                                     is set to 1, provided there is activity in the master or
                                                     slave state machines. When there is no longer any activity,
                                                     then with ic_en=0, this bit is set to 0. Reset value: 0x0.                */
      __IM  uint32_t RD_REQ     : 1;            /*!< This bit is set to 1 when DW_apb_i2c is acting as a slave and
                                                     another I2C master is attempting to read data from DW_apb_i2c.
                                                     The DW_apb_i2c holds the I2C bus in a wait state (SCL=0)
                                                     until this interrupt is serviced, which means that the
                                                     slave has been addressed by a remote master that is asking
                                                     for data to be transferred. The processor must respond
                                                     to this interrupt and then write the requested data to
                                                     the IC_DATA_CMD register. This bit is set to 0 just after
                                                     the processor reads the IC_CLR_RD_REQ register. Reset value:
                                                     0x0                                                                       */
      __IM  uint32_t TX_ABRT    : 1;            /*!< This bit indicates if DW_apb_i2c, as an I2C transmitter, is
                                                     unable to complete the intended actions on the contents
                                                     of the transmit FIFO. This situation can occur both as
                                                     an I2C master or an I2C slave, and is referred to as a
                                                     'transmit abort'. When this bit is set to 1, the IC_TX_ABRT_SOURCE
                                                     register indicates the reason why the transmit abort takes
                                                     places. Note: The DW_apb_i2c flushes/resets/empties the
                                                     TX_FIFO and RX_FIFO whenever there is a transmit abort
                                                     caused by any of the events tracked by the IC_TX_ABRT_SOURCE
                                                     register. The FIFOs remains in this flushed state until
                                                     the register IC_CLR_TX_ABRT is read. Once this read is
                                                     performed, the Tx FIFO is then ready to accept more data
                                                     bytes from the APB interface. Reset value: 0x0                            */
      __IM  uint32_t RX_DONE    : 1;            /*!< When the DW_apb_i2c is acting as a slave-transmitter, this bit
                                                     is set to 1 if the master does not acknowledge a transmitted
                                                     byte. This occurs on the last byte of the transmission,
                                                     indicating that the transmission is done. Reset value:
                                                     0x0                                                                       */
      __IM  uint32_t ACTIVITY   : 1;            /*!< This bit captures DW_apb_i2c activity and stays set until it
                                                     is cleared. There are four ways to clear it: - Disabling
                                                     the DW_apb_i2c - Reading the IC_CLR_ACTIVITY register -
                                                     Reading the IC_CLR_INTR register - System reset Once this
                                                     bit is set, it stays set unless one of the four methods
                                                     is used to clear it. Even if the DW_apb_i2c module is idle,
                                                     this bit remains set until cleared, indicating that there
                                                     was activity on the bus. Reset value: 0x0                                 */
      __IM  uint32_t STOP_DET   : 1;            /*!< Indicates whether a STOP condition has occurred on the I2C interface
                                                     regardless of whether DW_apb_i2c is operating in slave
                                                     or master mode. In Slave Mode: - If IC_CON[7]=1'b1 (STOP_DET_IFADDRESSED)
                                                     the STOP_DET interrupt will be issued only if slave is
                                                     addressed. Note: During a general call address, this slave
                                                     does not issue a STOP_DET interrupt if STOP_DET_IF_ADDRESSED=1'b1,
                                                     even if the slave responds to the general call address
                                                     by generating ACK. The STOP_DET interrupt is generated
                                                     only when the transmitted address matches the slave address
                                                     (SAR). - If IC_CON[7]=1'b0 (STOP_DET_IFADDRESSED), the
                                                     STOP_DET interrupt is issued irrespective of whether it
                                                     is being addressed. In Master Mode: - If IC_CON[10]=1'b1
                                                     (STOP_DET_IF_MASTER_ACTIVE),the STOP_DET interrupt will
                                                     be issued only if Master is active. - If IC_CON[10]=1'b0
                                                     (STOP_DET_IFADDRESSED),the STOP_DET interrupt will be issued
                                                     irrespective of whether master is active or not. Reset
                                                     value: 0x0                                                                */
      __IM  uint32_t START_DET  : 1;            /*!< Indicates whether a START or RESTART condition has occurred
                                                     on the I2C interface regardless of whether DW_apb_i2c is
                                                     operating in slave or master mode. Reset value: 0x0                       */
      __IM  uint32_t GEN_CALL   : 1;            /*!< Set only when a General Call address is received and it is acknowledged.
                                                     It stays set until it is cleared either by disabling DW_apb_i2c
                                                     or when the CPU reads bit 0 of the IC_CLR_GEN_CALL register.
                                                     DW_apb_i2c stores the received data in the Rx buffer. Reset
                                                     value: 0x0                                                                */
      __IM  uint32_t RESTART_DET : 1;           /*!< Indicates whether a RESTART condition has occurred on the I2C
                                                     interface when DW_apb_i2c is operating in Slave mode and
                                                     the slave is being addressed. Enabled only when IC_SLV_RESTART_DET_EN=1.
                                                     Note: However, in high-speed mode or during a START BYTE
                                                     transfer, the RESTART comes before the address field as
                                                     per the I2C protocol. In this case, the slave is not the
                                                     addressed slave when the RESTART is issued, therefore DW_apb_i2c
                                                     does not generate the RESTART_DET interrupt. Reset value:
                                                     0x0                                                                       */
            uint32_t            : 19;
    } bit;
  } IC_RAW_INTR_STAT;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C Receive FIFO Threshold Register                                       */
    
    struct {
      __IOM uint32_t RX_TL      : 8;            /*!< Receive FIFO Threshold Level. Controls the level of entries
                                                     (or above) that triggers the RX_FULL interrupt (bit 2 in
                                                     IC_RAW_INTR_STAT register). The valid range is 0-255, with
                                                     the additional restriction that hardware does not allow
                                                     this value to be set to a value larger than the depth of
                                                     the buffer. If an attempt is made to do that, the actual
                                                     value set will be the maximum depth of the buffer. A value
                                                     of 0 sets the threshold for 1 entry, and a value of 255
                                                     sets the threshold for 256 entries.                                       */
            uint32_t            : 24;
    } bit;
  } IC_RX_TL;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C Transmit FIFO Threshold Register                                      */
    
    struct {
      __IOM uint32_t TX_TL      : 8;            /*!< Transmit FIFO Threshold Level. Controls the level of entries
                                                     (or below) that trigger the TX_EMPTY interrupt (bit 4 in
                                                     IC_RAW_INTR_STAT register). The valid range is 0-255, with
                                                     the additional restriction that it may not be set to value
                                                     larger than the depth of the buffer. If an attempt is made
                                                     to do that, the actual value set will be the maximum depth
                                                     of the buffer. A value of 0 sets the threshold for 0 entries,
                                                     and a value of 255 sets the threshold for 255 entries.                    */
            uint32_t            : 24;
    } bit;
  } IC_TX_TL;
  
  union {
    __IOM uint32_t reg;                         /*!< Clear Combined and Individual Interrupt Register                          */
    
    struct {
      __IM  uint32_t CLR_INTR   : 1;            /*!< Read this register to clear the combined interrupt, all individual
                                                     interrupts, and the IC_TX_ABRT_SOURCE register. This bit
                                                     does not clear hardware clearable interrupts but software
                                                     clearable interrupts. Refer to Bit 9 of the IC_TX_ABRT_SOURCE
                                                     register for an exception to clearing IC_TX_ABRT_SOURCE.
                                                     Reset value: 0x0                                                          */
            uint32_t            : 31;
    } bit;
  } IC_CLR_INTR;
  
  union {
    __IOM uint32_t reg;                         /*!< Clear RX_UNDER Interrupt Register                                         */
    
    struct {
      __IM  uint32_t CLR_RX_UNDER : 1;          /*!< Read this register to clear the RX_UNDER interrupt (bit 0) of
                                                     the IC_RAW_INTR_STAT register. Reset value: 0x0                           */
            uint32_t            : 31;
    } bit;
  } IC_CLR_RX_UNDER;
  
  union {
    __IOM uint32_t reg;                         /*!< Clear RX_OVER Interrupt Register                                          */
    
    struct {
      __IM  uint32_t CLR_RX_OVER : 1;           /*!< Read this register to clear the RX_OVER interrupt (bit 1) of
                                                     the IC_RAW_INTR_STAT register. Reset value: 0x0                           */
            uint32_t            : 31;
    } bit;
  } IC_CLR_RX_OVER;
  
  union {
    __IOM uint32_t reg;                         /*!< Clear TX_OVER Interrupt Register                                          */
    
    struct {
      __IM  uint32_t CLR_TX_OVER : 1;           /*!< Read this register to clear the TX_OVER interrupt (bit 3) of
                                                     the IC_RAW_INTR_STAT register. Reset value: 0x0                           */
            uint32_t            : 31;
    } bit;
  } IC_CLR_TX_OVER;
  
  union {
    __IOM uint32_t reg;                         /*!< Clear RD_REQ Interrupt Register                                           */
    
    struct {
      __IM  uint32_t CLR_RD_REQ : 1;            /*!< Read this register to clear the RD_REQ interrupt (bit 5) of
                                                     the IC_RAW_INTR_STAT register. Reset value: 0x0                           */
            uint32_t            : 31;
    } bit;
  } IC_CLR_RD_REQ;
  
  union {
    __IOM uint32_t reg;                         /*!< Clear TX_ABRT Interrupt Register                                          */
    
    struct {
      __IM  uint32_t CLR_TX_ABRT : 1;           /*!< Read this register to clear the TX_ABRT interrupt (bit 6) of
                                                     the IC_RAW_INTR_STAT register, and the IC_TX_ABRT_SOURCE
                                                     register. This also releases the TX FIFO from the flushed/reset
                                                     state, allowing more writes to the TX FIFO. Refer to Bit
                                                     9 of the IC_TX_ABRT_SOURCE register for an exception to
                                                     clearing IC_TX_ABRT_SOURCE. Reset value: 0x0                              */
            uint32_t            : 31;
    } bit;
  } IC_CLR_TX_ABRT;
  
  union {
    __IOM uint32_t reg;                         /*!< Clear RX_DONE Interrupt Register                                          */
    
    struct {
      __IM  uint32_t CLR_RX_DONE : 1;           /*!< Read this register to clear the RX_DONE interrupt (bit 7) of
                                                     the IC_RAW_INTR_STAT register. Reset value: 0x0                           */
            uint32_t            : 31;
    } bit;
  } IC_CLR_RX_DONE;
  
  union {
    __IOM uint32_t reg;                         /*!< Clear ACTIVITY Interrupt Register                                         */
    
    struct {
      __IM  uint32_t CLR_ACTIVITY : 1;          /*!< Reading this register clears the ACTIVITY interrupt if the I2C
                                                     is not active anymore. If the I2C module is still active
                                                     on the bus, the ACTIVITY interrupt bit continues to be
                                                     set. It is automatically cleared by hardware if the module
                                                     is disabled and if there is no further activity on the
                                                     bus. The value read from this register to get status of
                                                     the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT
                                                     register. Reset value: 0x0                                                */
            uint32_t            : 31;
    } bit;
  } IC_CLR_ACTIVITY;
  
  union {
    __IOM uint32_t reg;                         /*!< Clear STOP_DET Interrupt Register                                         */
    
    struct {
      __IM  uint32_t CLR_STOP_DET : 1;          /*!< Read this register to clear the STOP_DET interrupt (bit 9) of
                                                     the IC_RAW_INTR_STAT register. Reset value: 0x0                           */
            uint32_t            : 31;
    } bit;
  } IC_CLR_STOP_DET;
  
  union {
    __IOM uint32_t reg;                         /*!< Clear START_DET Interrupt Register                                        */
    
    struct {
      __IM  uint32_t CLR_START_DET : 1;         /*!< Read this register to clear the START_DET interrupt (bit 10)
                                                     of the IC_RAW_INTR_STAT register. Reset value: 0x0                        */
            uint32_t            : 31;
    } bit;
  } IC_CLR_START_DET;
  
  union {
    __IOM uint32_t reg;                         /*!< Clear GEN_CALL Interrupt Register                                         */
    
    struct {
      __IM  uint32_t CLR_GEN_CALL : 1;          /*!< Read this register to clear the GEN_CALL interrupt (bit 11)
                                                     of IC_RAW_INTR_STAT register. Reset value: 0x0                            */
            uint32_t            : 31;
    } bit;
  } IC_CLR_GEN_CALL;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C Enable Register                                                       */
    
    struct {
      __IOM uint32_t ENABLE     : 1;            /*!< Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c
                                                     (TX and RX FIFOs are held in an erased state) - 1: Enables
                                                     DW_apb_i2c Software can disable DW_apb_i2c while it is
                                                     active. However, it is important that care be taken to
                                                     ensure that DW_apb_i2c is disabled properly. A recommended
                                                     procedure is described in 'Disabling DW_apb_i2c'. When
                                                     DW_apb_i2c is disabled, the following occurs: - The TX
                                                     FIFO and RX FIFO get flushed. - Status bits in the IC_INTR_STAT
                                                     register are still active until DW_apb_i2c goes into IDLE
                                                     state. If the module is transmitting, it stops as well
                                                     as deletes the contents of the transmit buffer after the
                                                     current transfer is complete. If the module is receiving,
                                                     the DW_apb_i2c stops the current transfer at the end of
                                                     the current byte and does not acknowledge the transfer.
                                                     In systems with asynchronous pclk and ic_clk when IC_CLK_TYPE
                                                     parameter set to asynchronous (1), there is a two ic_clk
                                                     delay when enabling or disabling the DW_apb_i2c. For a
                                                     detailed description on how to disable DW_apb_i2c, refer
                                                     to 'Disabling DW_apb_i2c' Reset value: 0x0                                */
      __IOM uint32_t ABORT      : 1;            /*!< When set, the controller initiates the transfer abort. - 0:
                                                     ABORT not initiated or ABORT done - 1: ABORT operation
                                                     in progress The software can abort the I2C transfer in
                                                     master mode by setting this bit. The software can set this
                                                     bit only when ENABLE is already set; otherwise, the controller
                                                     ignores any write to ABORT bit. The software cannot clear
                                                     the ABORT bit once set. In response to an ABORT, the controller
                                                     issues a STOP and flushes the Tx FIFO after completing
                                                     the current transfer, then sets the TX_ABORT interrupt
                                                     after the abort operation. The ABORT bit is cleared automatically
                                                     after the abort operation. For a detailed description on
                                                     how to abort I2C transfers, refer to 'Aborting I2C Transfers'.
                                                     Reset value: 0x0                                                          */
      __IOM uint32_t TX_CMD_BLOCK : 1;          /*!< In Master mode: - 1'b1: Blocks the transmission of data on I2C
                                                     bus even if Tx FIFO has data to transmit. - 1'b0: The transmission
                                                     of data starts on I2C bus automatically, as soon as the
                                                     first data is available in the Tx FIFO. Note: To block
                                                     the execution of Master commands, set the TX_CMD_BLOCK
                                                     bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master
                                                     is in Idle state (IC_STATUS[5] == 0). Any further commands
                                                     put in the Tx FIFO are not executed until TX_CMD_BLOCK
                                                     bit is unset. Reset value: IC_TX_CMD_BLOCK_DEFAULT                        */
            uint32_t            : 29;
    } bit;
  } IC_ENABLE;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C Status Register This is a read-only register used to indicate
                                                     the current transfer status and FIFO status. The status
                                                     register may be read at any time. None of the bits in this
                                                     register request an interrupt. When the I2C is disabled
                                                     by writing 0 in bit 0 of the IC_ENABLE register: - Bits
                                                     1 and 2 are set to 1 - Bits 3 and 10 are set to 0 When
                                                     the master or slave state machines goes to idle and ic_en=0:
                                                     - Bits 5 and 6 are set to 0                                               */
    
    struct {
      __IM  uint32_t ACTIVITY   : 1;            /*!< I2C Activity Status. Reset value: 0x0                                     */
      __IM  uint32_t TFNF       : 1;            /*!< Transmit FIFO Not Full. Set when the transmit FIFO contains
                                                     one or more empty locations, and is cleared when the FIFO
                                                     is full. - 0: Transmit FIFO is full - 1: Transmit FIFO
                                                     is not full Reset value: 0x1                                              */
      __IM  uint32_t TFE        : 1;            /*!< Transmit FIFO Completely Empty. When the transmit FIFO is completely
                                                     empty, this bit is set. When it contains one or more valid
                                                     entries, this bit is cleared. This bit field does not request
                                                     an interrupt. - 0: Transmit FIFO is not empty - 1: Transmit
                                                     FIFO is empty Reset value: 0x1                                            */
      __IM  uint32_t RFNE       : 1;            /*!< Receive FIFO Not Empty. This bit is set when the receive FIFO
                                                     contains one or more entries; it is cleared when the receive
                                                     FIFO is empty. - 0: Receive FIFO is empty - 1: Receive
                                                     FIFO is not empty Reset value: 0x0                                        */
      __IM  uint32_t RFF        : 1;            /*!< Receive FIFO Completely Full. When the receive FIFO is completely
                                                     full, this bit is set. When the receive FIFO contains one
                                                     or more empty location, this bit is cleared. - 0: Receive
                                                     FIFO is not full - 1: Receive FIFO is full Reset value:
                                                     0x0                                                                       */
      __IM  uint32_t MST_ACTIVITY : 1;          /*!< Master FSM Activity Status. When the Master Finite State Machine
                                                     (FSM) is not in the IDLE state, this bit is set. - 0: Master
                                                     FSM is in IDLE state so the Master part of DW_apb_i2c is
                                                     not Active - 1: Master FSM is not in IDLE state so the
                                                     Master part of DW_apb_i2c is Active Note: IC_STATUS[0]-that
                                                     is, ACTIVITY bit-is the OR of SLV_ACTIVITY and MST_ACTIVITY
                                                     bits. Reset value: 0x0                                                    */
      __IM  uint32_t SLV_ACTIVITY : 1;          /*!< Slave FSM Activity Status. When the Slave Finite State Machine
                                                     (FSM) is not in the IDLE state, this bit is set. - 0: Slave
                                                     FSM is in IDLE state so the Slave part of DW_apb_i2c is
                                                     not Active - 1: Slave FSM is not in IDLE state so the Slave
                                                     part of DW_apb_i2c is Active Reset value: 0x0                             */
            uint32_t            : 25;
    } bit;
  } IC_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C Transmit FIFO Level Register This register contains the
                                                     number of valid data entries in the transmit FIFO buffer.
                                                     It is cleared whenever: - The I2C is disabled - There is
                                                     a transmit abort - that is, TX_ABRT bit is set in the IC_RAW_INTR_STAT
                                                     register - The slave bulk transmit mode is aborted The
                                                     register increments whenever data is placed into the transmit
                                                     FIFO and decrements when data is taken from the transmit
                                                     FIFO.                                                                     */
    
    struct {
      __IM  uint32_t TXFLR      : 5;            /*!< Transmit FIFO Level. Contains the number of valid data entries
                                                     in the transmit FIFO. Reset value: 0x0                                    */
            uint32_t            : 27;
    } bit;
  } IC_TXFLR;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C Receive FIFO Level Register This register contains the number
                                                     of valid data entries in the receive FIFO buffer. It is
                                                     cleared whenever: - The I2C is disabled - Whenever there
                                                     is a transmit abort caused by any of the events tracked
                                                     in IC_TX_ABRT_SOURCE The register increments whenever data
                                                     is placed into the receive FIFO and decrements when data
                                                     is taken from the receive FIFO.                                           */
    
    struct {
      __IM  uint32_t RXFLR      : 5;            /*!< Receive FIFO Level. Contains the number of valid data entries
                                                     in the receive FIFO. Reset value: 0x0                                     */
            uint32_t            : 27;
    } bit;
  } IC_RXFLR;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C SDA Hold Time Length Register The bits [15:0] of this register
                                                     are used to control the hold time of SDA during transmit
                                                     in both slave and master mode (after SCL goes from HIGH
                                                     to LOW). The bits [23:16] of this register are used to
                                                     extend the SDA transition (if any) whenever SCL is HIGH
                                                     in the receiver in either master or slave mode. Writes
                                                     to this register succeed only when IC_ENABLE[0]=0. The
                                                     values in this register are in units of ic_clk period.
                                                     The value programmed in IC_SDA_TX_HOLD must be greater
                                                     than the minimum hold time in each mode (one cycle in master
                                                     mode, seven cycles in slave mode) for the value to be implemented.
                                                     The programmed SDA hold time during transmit (IC_SDA_TX_HOLD)
                                                     cannot exceed at any time the duration of the low part
                                                     of scl. Therefore the programmed value cannot be larger
                                                     than N_SCL_LOW-2, where N_SCL_LOW is the duration of the
                                                     low part of the scl period measured in ic_clk cycles.                     */
    
    struct {
      __IOM uint32_t IC_SDA_TX_HOLD : 16;       /*!< Sets the required SDA hold time in units of ic_clk period, when
                                                     DW_apb_i2c acts as a transmitter. Reset value: IC_DEFAULT_SDA_HOLD[15:0]. */
      __IOM uint32_t IC_SDA_RX_HOLD : 8;        /*!< Sets the required SDA hold time in units of ic_clk period, when
                                                     DW_apb_i2c acts as a receiver. Reset value: IC_DEFAULT_SDA_HOLD[23:16].   */
            uint32_t            : 8;
    } bit;
  } IC_SDA_HOLD;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C Transmit Abort Source Register This register has 32 bits
                                                     that indicate the source of the TX_ABRT bit. Except for
                                                     Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT
                                                     register or the IC_CLR_INTR register is read. To clear
                                                     Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed
                                                     first; RESTART must be enabled (IC_CON[5]=1), the SPECIAL
                                                     bit must be cleared (IC_TAR[11]), or the GC_OR_START bit
                                                     must be cleared (IC_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT
                                                     is fixed, then this bit can be cleared in the same manner
                                                     as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT
                                                     is not fixed before attempting to clear this bit, Bit 9
                                                     clears for one cycle and is then re-asserted.                             */
    
    struct {
      __IM  uint32_t ABRT_7B_ADDR_NOACK : 1;    /*!< This field indicates that the Master is in 7-bit addressing
                                                     mode and the address sent was not acknowledged by any slave.
                                                     Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter
                                                     or Master-Receiver                                                        */
      __IM  uint32_t ABRT_10ADDR1_NOACK : 1;    /*!< This field indicates that the Master is in 10-bit address mode
                                                     and the first 10-bit address byte was not acknowledged
                                                     by any slave. Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter
                                                     or Master-Receiver                                                        */
      __IM  uint32_t ABRT_10ADDR2_NOACK : 1;    /*!< This field indicates that the Master is in 10-bit address mode
                                                     and that the second address byte of the 10-bit address
                                                     was not acknowledged by any slave. Reset value: 0x0 Role
                                                     of DW_apb_i2c: Master-Transmitter or Master-Receiver                      */
      __IM  uint32_t ABRT_TXDATA_NOACK : 1;     /*!< This field indicates the master-mode only bit. When the master
                                                     receives an acknowledgement for the address, but when it
                                                     sends data byte(s) following the address, it did not receive
                                                     an acknowledge from the remote slave(s). Reset value: 0x0
                                                     Role of DW_apb_i2c: Master-Transmitter                                    */
      __IM  uint32_t ABRT_GCALL_NOACK : 1;      /*!< This field indicates that DW_apb_i2c in master mode has sent
                                                     a General Call and no slave on the bus acknowledged the
                                                     General Call. Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter     */
      __IM  uint32_t ABRT_GCALL_READ : 1;       /*!< This field indicates that DW_apb_i2c in the master mode has
                                                     sent a General Call but the user programmed the byte following
                                                     the General Call to be a read from the bus (IC_DATA_CMD[9]
                                                     is set to 1). Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter     */
      __IM  uint32_t ABRT_HS_ACKDET : 1;        /*!< This field indicates that the Master is in High Speed mode and
                                                     the High Speed Master code was acknowledged (wrong behavior).
                                                     Reset value: 0x0 Role of DW_apb_i2c: Master                               */
      __IM  uint32_t ABRT_SBYTE_ACKDET : 1;     /*!< This field indicates that the Master has sent a START Byte and
                                                     the START Byte was acknowledged (wrong behavior). Reset
                                                     value: 0x0 Role of DW_apb_i2c: Master                                     */
      __IM  uint32_t ABRT_HS_NORSTRT : 1;       /*!< This field indicates that the restart is disabled (IC_RESTART_EN
                                                     bit (IC_CON[5]) =0) and the user is trying to use the master
                                                     to transfer data in High Speed mode. Reset value: 0x0 Role
                                                     of DW_apb_i2c: Master-Transmitter or Master-Receiver                      */
      __IM  uint32_t ABRT_SBYTE_NORSTRT : 1;    /*!< To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be
                                                     fixed first; restart must be enabled (IC_CON[5]=1), the
                                                     SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START
                                                     bit must be cleared (IC_TAR[10]). Once the source of the
                                                     ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared
                                                     in the same manner as other bits in this register. If the
                                                     source of the ABRT_SBYTE_NORSTRT is not fixed before attempting
                                                     to clear this bit, bit 9 clears for one cycle and then
                                                     gets reasserted. When this field is set to 1, the restart
                                                     is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the
                                                     user is trying to send a START Byte. Reset value: 0x0 Role
                                                     of DW_apb_i2c: Master                                                     */
      __IM  uint32_t ABRT_10B_RD_NORSTRT : 1;   /*!< This field indicates that the restart is disabled (IC_RESTART_EN
                                                     bit (IC_CON[5]) =0) and the master sends a read command
                                                     in 10-bit addressing mode. Reset value: 0x0 Role of DW_apb_i2c:
                                                     Master-Receiver                                                           */
      __IM  uint32_t ABRT_MASTER_DIS : 1;       /*!< This field indicates that the User tries to initiate a Master
                                                     operation with the Master mode disabled. Reset value: 0x0
                                                     Role of DW_apb_i2c: Master-Transmitter or Master-Receiver                 */
      __IM  uint32_t ARB_LOST   : 1;            /*!< This field specifies that the Master has lost arbitration, or
                                                     if IC_TX_ABRT_SOURCE[14] is also set, then the slave transmitter
                                                     has lost arbitration. Reset value: 0x0 Role of DW_apb_i2c:
                                                     Master-Transmitter or Slave-Transmitter                                   */
      __IM  uint32_t ABRT_SLVFLUSH_TXFIFO : 1;  /*!< This field specifies that the Slave has received a read command
                                                     and some data exists in the TX FIFO, so the slave issues
                                                     a TX_ABRT interrupt to flush old data in TX FIFO. Reset
                                                     value: 0x0 Role of DW_apb_i2c: Slave-Transmitter                          */
      __IM  uint32_t ABRT_SLV_ARBLOST : 1;      /*!< This field indicates that a Slave has lost the bus while transmitting
                                                     data to a remote master. IC_TX_ABRT_SOURCE[12] is set at
                                                     the same time. Note: Even though the slave never 'owns'
                                                     the bus, something could go wrong on the bus. This is a
                                                     fail safe check. For instance, during a data transmission
                                                     at the low-to-high transition of SCL, if what is on the
                                                     data bus is not what is supposed to be transmitted, then
                                                     DW_apb_i2c no longer own the bus. Reset value: 0x0 Role
                                                     of DW_apb_i2c: Slave-Transmitter                                          */
      __IM  uint32_t ABRT_SLVRD_INTX : 1;       /*!< 1: When the processor side responds to a slave mode request
                                                     for data to be transmitted to a remote master and user
                                                     writes a 1 in CMD (bit 8) of IC_DATA_CMD register. Reset
                                                     value: 0x0 Role of DW_apb_i2c: Slave-Transmitter                          */
      __IM  uint32_t ABRT_USER_ABRT : 1;        /*!< This is a master-mode-only bit. Master has detected the transfer
                                                     abort (IC_ENABLE[1]) Reset value: 0x0 Role of DW_apb_i2c:
                                                     Master-Transmitter                                                        */
            uint32_t            : 6;
      __IM  uint32_t TX_FLUSH_CNT : 9;          /*!< This field indicates the number of Tx FIFO Data Commands which
                                                     are flushed due to TX_ABRT interrupt. It is cleared whenever
                                                     I2C is disabled. Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter
                                                     or Slave-Transmitter                                                      */
    } bit;
  } IC_TX_ABRT_SOURCE;
  
  union {
    __IOM uint32_t reg;                         /*!< Generate Slave Data NACK Register The register is used to generate
                                                     a NACK for the data part of a transfer when DW_apb_i2c
                                                     is acting as a slave-receiver. This register only exists
                                                     when the IC_SLV_DATA_NACK_ONLY parameter is set to 1. When
                                                     this parameter disabled, this register does not exist and
                                                     writing to the register's address has no effect. A write
                                                     can occur on this register if both of the following conditions
                                                     are met: - DW_apb_i2c is disabled (IC_ENABLE[0] = 0) -
                                                     Slave part is inactive (IC_STATUS[6] = 0) Note: The IC_STATUS[6]
                                                     is a register read-back location for the internal slv_activity
                                                     signal; the user should poll this before writing the ic_slv_data_nack_onl
                                                     bit.                                                                      */
    
    struct {
      __IOM uint32_t NACK       : 1;            /*!< Generate NACK. This NACK generation only occurs when DW_apb_i2c
                                                     is a slave-receiver. If this register is set to a value
                                                     of 1, it can only generate a NACK after a data byte is
                                                     received; hence, the data transfer is aborted and the data
                                                     received is not pushed to the receive buffer. When the
                                                     register is set to a value of 0, it generates NACK/ACK,
                                                     depending on normal criteria. - 1: generate NACK after
                                                     data byte received - 0: generate NACK/ACK normally Reset
                                                     value: 0x0                                                                */
            uint32_t            : 31;
    } bit;
  } IC_SLV_DATA_NACK_ONLY;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Control Register The register is used to enable the DMA
                                                     Controller interface operation. There is a separate bit
                                                     for transmit and receive. This can be programmed regardless
                                                     of the state of IC_ENABLE.                                                */
    
    struct {
      __IOM uint32_t RDMAE      : 1;            /*!< Receive DMA Enable. This bit enables/disables the receive FIFO
                                                     DMA channel. Reset value: 0x0                                             */
      __IOM uint32_t TDMAE      : 1;            /*!< Transmit DMA Enable. This bit enables/disables the transmit
                                                     FIFO DMA channel. Reset value: 0x0                                        */
            uint32_t            : 30;
    } bit;
  } IC_DMA_CR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA Transmit Data Level Register                                          */
    
    struct {
      __IOM uint32_t DMATDL     : 4;            /*!< Transmit Data Level. This bit field controls the level at which
                                                     a DMA request is made by the transmit logic. It is equal
                                                     to the watermark level; that is, the dma_tx_req signal
                                                     is generated when the number of valid data entries in the
                                                     transmit FIFO is equal to or below this field value, and
                                                     TDMAE = 1. Reset value: 0x0                                               */
            uint32_t            : 28;
    } bit;
  } IC_DMA_TDLR;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C Receive Data Level Register                                           */
    
    struct {
      __IOM uint32_t DMARDL     : 4;            /*!< Receive Data Level. This bit field controls the level at which
                                                     a DMA request is made by the receive logic. The watermark
                                                     level = DMARDL+1; that is, dma_rx_req is generated when
                                                     the number of valid data entries in the receive FIFO is
                                                     equal to or more than this field value + 1, and RDMAE =1.
                                                     For instance, when DMARDL is 0, then dma_rx_req is asserted
                                                     when 1 or more data entries are present in the receive
                                                     FIFO. Reset value: 0x0                                                    */
            uint32_t            : 28;
    } bit;
  } IC_DMA_RDLR;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C SDA Setup Register This register controls the amount of
                                                     time delay (in terms of number of ic_clk clock periods)
                                                     introduced in the rising edge of SCL - relative to SDA
                                                     changing - when DW_apb_i2c services a read request in a
                                                     slave-transmitter operation. The relevant I2C requirement
                                                     is tSU:DAT (note 4) as detailed in the I2C Bus Specification.
                                                     This register must be programmed with a value equal to
                                                     or greater than 2. Writes to this register succeed only
                                                     when IC_ENABLE[0] = 0. Note: The length of setup time is
                                                     calculated using [(IC_SDA_SETUP - 1) * (ic_clk_period)],
                                                     so if the user requires 10 ic_clk periods of setup time,
                                                     they should program a value of 11. The IC_SDA_SETUP register
                                                     is only used by the DW_apb_i2c when operating as a slave
                                                     transmitter.                                                              */
    
    struct {
      __IOM uint32_t SDA_SETUP  : 8;            /*!< SDA Setup. It is recommended that if the required delay is 1000ns,
                                                     then for an ic_clk frequency of 10 MHz, IC_SDA_SETUP should
                                                     be programmed to a value of 11. IC_SDA_SETUP must be programmed
                                                     with a minimum value of 2.                                                */
            uint32_t            : 24;
    } bit;
  } IC_SDA_SETUP;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C ACK General Call Register The register controls whether
                                                     DW_apb_i2c responds with a ACK or NACK when it receives
                                                     an I2C General Call address. This register is applicable
                                                     only when the DW_apb_i2c is in slave mode.                                */
    
    struct {
      __IOM uint32_t ACK_GEN_CALL : 1;          /*!< ACK General Call. When set to 1, DW_apb_i2c responds with a
                                                     ACK (by asserting ic_data_oe) when it receives a General
                                                     Call. Otherwise, DW_apb_i2c responds with a NACK (by negating
                                                     ic_data_oe).                                                              */
            uint32_t            : 31;
    } bit;
  } IC_ACK_GENERAL_CALL;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C Enable Status Register The register is used to report the
                                                     DW_apb_i2c hardware status when the IC_ENABLE[0] register
                                                     is set from 1 to 0; that is, when DW_apb_i2c is disabled.
                                                     If IC_ENABLE[0] has been set to 1, bits 2:1 are forced
                                                     to 0, and bit 0 is forced to 1. If IC_ENABLE[0] has been
                                                     set to 0, bits 2:1 is only be valid as soon as bit 0 is
                                                     read as '0'. Note: When IC_ENABLE[0] has been set to 0,
                                                     a delay occurs for bit 0 to be read as 0 because disabling
                                                     the DW_apb_i2c depends on I2C bus activities.                             */
    
    struct {
      __IM  uint32_t IC_EN      : 1;            /*!< ic_en Status. This bit always reflects the value driven on the
                                                     output port ic_en. - When read as 1, DW_apb_i2c is deemed
                                                     to be in an enabled state. - When read as 0, DW_apb_i2c
                                                     is deemed completely inactive. Note: The CPU can safely
                                                     read this bit anytime. When this bit is read as 0, the
                                                     CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY
                                                     (bit 1). Reset value: 0x0                                                 */
      __IM  uint32_t SLV_DISABLED_WHILE_BUSY : 1;/*!< Slave Disabled While Busy (Transmit, Receive). This bit indicates
                                                     if a potential or active Slave operation has been aborted
                                                     due to the setting bit 0 of the IC_ENABLE register from
                                                     1 to 0. This bit is set when the CPU writes a 0 to the
                                                     IC_ENABLE register while: (a) DW_apb_i2c is receiving the
                                                     address byte of the Slave-Transmitter operation from a
                                                     remote master; OR, (b) address and data bytes of the Slave-Receiver
                                                     operation from a remote master. When read as 1, DW_apb_i2c
                                                     is deemed to have forced a NACK during any part of an I2C
                                                     transfer, irrespective of whether the I2C address matches
                                                     the slave address set in DW_apb_i2c (IC_SAR register) OR
                                                     if the transfer is completed before IC_ENABLE is set to
                                                     0 but has not taken effect. Note: If the remote I2C master
                                                     terminates the transfer with a STOP condition before the
                                                     DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0]
                                                     has been set to 0, then this bit will also be set to 1.
                                                     When read as 0, DW_apb_i2c is deemed to have been disabled
                                                     when there is master activity, or when the I2C bus is idle.
                                                     Note: The CPU can safely read this bit when IC_EN (bit
                                                     0) is read as 0. Reset value: 0x0                                         */
      __IM  uint32_t SLV_RX_DATA_LOST : 1;      /*!< Slave Received Data Lost. This bit indicates if a Slave-Receiver
                                                     operation has been aborted with at least one data byte
                                                     received from an I2C transfer due to the setting bit 0
                                                     of IC_ENABLE from 1 to 0. When read as 1, DW_apb_i2c is
                                                     deemed to have been actively engaged in an aborted I2C
                                                     transfer (with matching address) and the data phase of
                                                     the I2C transfer has been entered, even though a data byte
                                                     has been responded with a NACK. Note: If the remote I2C
                                                     master terminates the transfer with a STOP condition before
                                                     the DW_apb_i2c has a chance to NACK a transfer, and IC_ENABLE[0]
                                                     has been set to 0, then this bit is also set to 1. When
                                                     read as 0, DW_apb_i2c is deemed to have been disabled without
                                                     being actively involved in the data phase of a Slave-Receiver
                                                     transfer. Note: The CPU can safely read this bit when IC_EN
                                                     (bit 0) is read as 0. Reset value: 0x0                                    */
            uint32_t            : 29;
    } bit;
  } IC_ENABLE_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C SS, FS or FM+ spike suppression limit This register is used
                                                     to store the duration, measured in ic_clk cycles, of the
                                                     longest spike that is filtered out by the spike suppression
                                                     logic when the component is operating in SS, FS or FM+
                                                     modes. The relevant I2C requirement is tSP (table 4) as
                                                     detailed in the I2C Bus Specification. This register must
                                                     be programmed with a minimum value of 1.                                  */
    
    struct {
      __IOM uint32_t IC_FS_SPKLEN : 8;          /*!< This register must be set before any I2C bus transaction can
                                                     take place to ensure stable operation. This register sets
                                                     the duration, measured in ic_clk cycles, of the longest
                                                     spike in the SCL or SDA lines that will be filtered out
                                                     by the spike suppression logic. This register can be written
                                                     only when the I2C interface is disabled which corresponds
                                                     to the IC_ENABLE[0] register being set to 0. Writes at
                                                     other times have no effect. The minimum valid value is
                                                     1; hardware prevents values less than this being written,
                                                     and if attempted results in 1 being set. or more information,
                                                     refer to 'Spike Suppression'.                                             */
            uint32_t            : 24;
    } bit;
  } IC_FS_SPKLEN;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t reg;                         /*!< Clear RESTART_DET Interrupt Register                                      */
    
    struct {
      __IM  uint32_t CLR_RESTART_DET : 1;       /*!< Read this register to clear the RESTART_DET interrupt (bit 12)
                                                     of IC_RAW_INTR_STAT register. Reset value: 0x0                            */
            uint32_t            : 31;
    } bit;
  } IC_CLR_RESTART_DET;
  __IM  uint32_t  RESERVED3[18];
  
  union {
    __IOM uint32_t reg;                         /*!< Component Parameter Register 1 Note This register is not implemented
                                                     and therefore reads as 0. If it was implemented it would
                                                     be a constant read-only register that contains encoded
                                                     information about the component's parameter settings. Fields
                                                     shown below are the settings for those parameters                         */
    
    struct {
      __IM  uint32_t APB_DATA_WIDTH : 2;        /*!< APB data bus width is 32 bits                                             */
      __IM  uint32_t MAX_SPEED_MODE : 2;        /*!< MAX SPEED MODE = FAST MODE                                                */
      __IM  uint32_t HC_COUNT_VALUES : 1;       /*!< Programmable count values for each mode.                                  */
      __IM  uint32_t INTR_IO    : 1;            /*!< COMBINED Interrupt outputs                                                */
      __IM  uint32_t HAS_DMA    : 1;            /*!< DMA handshaking signals are enabled                                       */
      __IM  uint32_t ADD_ENCODED_PARAMS : 1;    /*!< Encoded parameters not visible                                            */
      __IM  uint32_t RX_BUFFER_DEPTH : 8;       /*!< RX Buffer Depth = 16                                                      */
      __IM  uint32_t TX_BUFFER_DEPTH : 8;       /*!< TX Buffer Depth = 16                                                      */
            uint32_t            : 8;
    } bit;
  } IC_COMP_PARAM_1;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C Component Version Register                                            */
    
    struct {
      __IM  uint32_t IC_COMP_VERSION : 32;      /*!< IC_COMP_VERSION                                                           */
    } bit;
  } IC_COMP_VERSION;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C Component Type Register                                               */
    
    struct {
      __IM  uint32_t IC_COMP_TYPE : 32;         /*!< Designware Component Type number = 0x44_57_01_40. This assigned
                                                     unique hex value is constant and is derived from the two
                                                     ASCII letters 'DW' followed by a 16-bit unsigned number.                  */
    } bit;
  } IC_COMP_TYPE;
} I2C0_Type;                                    /*!< Size = 256 (0x100)                                                        */



/* =========================================================================================================================== */
/* ================                                           SPI0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief SPI0 (SPI0)
  */

typedef struct {                                /*!< SPI0 Structure                                                            */
  
  union {
    __IOM uint32_t reg;                         /*!< Control register 0, SSPCR0 on page 3-4                                    */
    
    struct {
      __IOM uint32_t DSS        : 4;            /*!< Data Size Select: 0000 Reserved, undefined operation. 0001 Reserved,
                                                     undefined operation. 0010 Reserved, undefined operation.
                                                     0011 4-bit data. 0100 5-bit data. 0101 6-bit data. 0110
                                                     7-bit data. 0111 8-bit data. 1000 9-bit data. 1001 10-bit
                                                     data. 1010 11-bit data. 1011 12-bit data. 1100 13-bit data.
                                                     1101 14-bit data. 1110 15-bit data. 1111 16-bit data.                     */
      __IOM uint32_t FRF        : 2;            /*!< Frame format: 00 Motorola SPI frame format. 01 TI synchronous
                                                     serial frame format. 10 National Microwire frame format.
                                                     11 Reserved, undefined operation.                                         */
      __IOM uint32_t SPO        : 1;            /*!< SSPCLKOUT polarity, applicable to Motorola SPI frame format
                                                     only. See Motorola SPI frame format on page 2-10.                         */
      __IOM uint32_t SPH        : 1;            /*!< SSPCLKOUT phase, applicable to Motorola SPI frame format only.
                                                     See Motorola SPI frame format on page 2-10.                               */
      __IOM uint32_t SCR        : 8;            /*!< Serial clock rate. The value SCR is used to generate the transmit
                                                     and receive bit rate of the PrimeCell SSP. The bit rate
                                                     is: F SSPCLK CPSDVSR x (1+SCR) where CPSDVSR is an even
                                                     value from 2-254, programmed through the SSPCPSR register
                                                     and SCR is a value from 0-255.                                            */
            uint32_t            : 16;
    } bit;
  } SSPCR0;
  
  union {
    __IOM uint32_t reg;                         /*!< Control register 1, SSPCR1 on page 3-5                                    */
    
    struct {
      __IOM uint32_t LBM        : 1;            /*!< Loop back mode: 0 Normal serial port operation enabled. 1 Output
                                                     of transmit serial shifter is connected to input of receive
                                                     serial shifter internally.                                                */
      __IOM uint32_t SSE        : 1;            /*!< Synchronous serial port enable: 0 SSP operation disabled. 1
                                                     SSP operation enabled.                                                    */
      __IOM uint32_t MS         : 1;            /*!< Master or slave mode select. This bit can be modified only when
                                                     the PrimeCell SSP is disabled, SSE=0: 0 Device configured
                                                     as master, default. 1 Device configured as slave.                         */
      __IOM uint32_t SOD        : 1;            /*!< Slave-mode output disable. This bit is relevant only in the
                                                     slave mode, MS=1. In multiple-slave systems, it is possible
                                                     for an PrimeCell SSP master to broadcast a message to all
                                                     slaves in the system while ensuring that only one slave
                                                     drives data onto its serial output line. In such systems
                                                     the RXD lines from multiple slaves could be tied together.
                                                     To operate in such systems, the SOD bit can be set if the
                                                     PrimeCell SSP slave is not supposed to drive the SSPTXD
                                                     line: 0 SSP can drive the SSPTXD output in slave mode.
                                                     1 SSP must not drive the SSPTXD output in slave mode.                     */
            uint32_t            : 28;
    } bit;
  } SSPCR1;
  
  union {
    __IOM uint32_t reg;                         /*!< Data register, SSPDR on page 3-6                                          */
    
    struct {
      __IOM uint32_t DATA       : 16;           /*!< Transmit/Receive FIFO: Read Receive FIFO. Write Transmit FIFO.
                                                     You must right-justify data when the PrimeCell SSP is programmed
                                                     for a data size that is less than 16 bits. Unused bits
                                                     at the top are ignored by transmit logic. The receive logic
                                                     automatically right-justifies.                                            */
            uint32_t            : 16;
    } bit;
  } SSPDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register, SSPSR on page 3-7                                        */
    
    struct {
      __IM  uint32_t TFE        : 1;            /*!< Transmit FIFO empty, RO: 0 Transmit FIFO is not empty. 1 Transmit
                                                     FIFO is empty.                                                            */
      __IM  uint32_t TNF        : 1;            /*!< Transmit FIFO not full, RO: 0 Transmit FIFO is full. 1 Transmit
                                                     FIFO is not full.                                                         */
      __IM  uint32_t RNE        : 1;            /*!< Receive FIFO not empty, RO: 0 Receive FIFO is empty. 1 Receive
                                                     FIFO is not empty.                                                        */
      __IM  uint32_t RFF        : 1;            /*!< Receive FIFO full, RO: 0 Receive FIFO is not full. 1 Receive
                                                     FIFO is full.                                                             */
      __IM  uint32_t BSY        : 1;            /*!< PrimeCell SSP busy flag, RO: 0 SSP is idle. 1 SSP is currently
                                                     transmitting and/or receiving a frame or the transmit FIFO
                                                     is not empty.                                                             */
            uint32_t            : 27;
    } bit;
  } SSPSR;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock prescale register, SSPCPSR on page 3-8                              */
    
    struct {
      __IOM uint32_t CPSDVSR    : 8;            /*!< Clock prescale divisor. Must be an even number from 2-254, depending
                                                     on the frequency of SSPCLK. The least significant bit always
                                                     returns zero on reads.                                                    */
            uint32_t            : 24;
    } bit;
  } SSPCPSR;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt mask set or clear register, SSPIMSC on page 3-9                 */
    
    struct {
      __IOM uint32_t RORIM      : 1;            /*!< Receive overrun interrupt mask: 0 Receive FIFO written to while
                                                     full condition interrupt is masked. 1 Receive FIFO written
                                                     to while full condition interrupt is not masked.                          */
      __IOM uint32_t RTIM       : 1;            /*!< Receive timeout interrupt mask: 0 Receive FIFO not empty and
                                                     no read prior to timeout period interrupt is masked. 1
                                                     Receive FIFO not empty and no read prior to timeout period
                                                     interrupt is not masked.                                                  */
      __IOM uint32_t RXIM       : 1;            /*!< Receive FIFO interrupt mask: 0 Receive FIFO half full or less
                                                     condition interrupt is masked. 1 Receive FIFO half full
                                                     or less condition interrupt is not masked.                                */
      __IOM uint32_t TXIM       : 1;            /*!< Transmit FIFO interrupt mask: 0 Transmit FIFO half empty or
                                                     less condition interrupt is masked. 1 Transmit FIFO half
                                                     empty or less condition interrupt is not masked.                          */
            uint32_t            : 28;
    } bit;
  } SSPIMSC;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw interrupt status register, SSPRIS on page 3-10                        */
    
    struct {
      __IM  uint32_t RORRIS     : 1;            /*!< Gives the raw interrupt state, prior to masking, of the SSPRORINTR
                                                     interrupt                                                                 */
      __IM  uint32_t RTRIS      : 1;            /*!< Gives the raw interrupt state, prior to masking, of the SSPRTINTR
                                                     interrupt                                                                 */
      __IM  uint32_t RXRIS      : 1;            /*!< Gives the raw interrupt state, prior to masking, of the SSPRXINTR
                                                     interrupt                                                                 */
      __IM  uint32_t TXRIS      : 1;            /*!< Gives the raw interrupt state, prior to masking, of the SSPTXINTR
                                                     interrupt                                                                 */
            uint32_t            : 28;
    } bit;
  } SSPRIS;
  
  union {
    __IOM uint32_t reg;                         /*!< Masked interrupt status register, SSPMIS on page 3-11                     */
    
    struct {
      __IM  uint32_t RORMIS     : 1;            /*!< Gives the receive over run masked interrupt status, after masking,
                                                     of the SSPRORINTR interrupt                                               */
      __IM  uint32_t RTMIS      : 1;            /*!< Gives the receive timeout masked interrupt state, after masking,
                                                     of the SSPRTINTR interrupt                                                */
      __IM  uint32_t RXMIS      : 1;            /*!< Gives the receive FIFO masked interrupt state, after masking,
                                                     of the SSPRXINTR interrupt                                                */
      __IM  uint32_t TXMIS      : 1;            /*!< Gives the transmit FIFO masked interrupt state, after masking,
                                                     of the SSPTXINTR interrupt                                                */
            uint32_t            : 28;
    } bit;
  } SSPMIS;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear register, SSPICR on page 3-11                             */
    
    struct {
      __IOM uint32_t RORIC      : 1;            /*!< Clears the SSPRORINTR interrupt                                           */
      __IOM uint32_t RTIC       : 1;            /*!< Clears the SSPRTINTR interrupt                                            */
            uint32_t            : 30;
    } bit;
  } SSPICR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA control register, SSPDMACR on page 3-12                               */
    
    struct {
      __IOM uint32_t RXDMAE     : 1;            /*!< Receive DMA Enable. If this bit is set to 1, DMA for the receive
                                                     FIFO is enabled.                                                          */
      __IOM uint32_t TXDMAE     : 1;            /*!< Transmit DMA Enable. If this bit is set to 1, DMA for the transmit
                                                     FIFO is enabled.                                                          */
            uint32_t            : 30;
    } bit;
  } SSPDMACR;
  __IM  uint32_t  RESERVED[1006];
  
  union {
    __IOM uint32_t reg;                         /*!< Peripheral identification registers, SSPPeriphID0-3 on page
                                                     3-13                                                                      */
    
    struct {
      __IM  uint32_t PARTNUMBER0 : 8;           /*!< These bits read back as 0x22                                              */
            uint32_t            : 24;
    } bit;
  } SSPPERIPHID0;
  
  union {
    __IOM uint32_t reg;                         /*!< Peripheral identification registers, SSPPeriphID0-3 on page
                                                     3-13                                                                      */
    
    struct {
      __IM  uint32_t PARTNUMBER1 : 4;           /*!< These bits read back as 0x0                                               */
      __IM  uint32_t DESIGNER0  : 4;            /*!< These bits read back as 0x1                                               */
            uint32_t            : 24;
    } bit;
  } SSPPERIPHID1;
  
  union {
    __IOM uint32_t reg;                         /*!< Peripheral identification registers, SSPPeriphID0-3 on page
                                                     3-13                                                                      */
    
    struct {
      __IM  uint32_t DESIGNER1  : 4;            /*!< These bits read back as 0x4                                               */
      __IM  uint32_t REVISION   : 4;            /*!< These bits return the peripheral revision                                 */
            uint32_t            : 24;
    } bit;
  } SSPPERIPHID2;
  
  union {
    __IOM uint32_t reg;                         /*!< Peripheral identification registers, SSPPeriphID0-3 on page
                                                     3-13                                                                      */
    
    struct {
      __IM  uint32_t CONFIGURATION : 8;         /*!< These bits read back as 0x00                                              */
            uint32_t            : 24;
    } bit;
  } SSPPERIPHID3;
  
  union {
    __IOM uint32_t reg;                         /*!< PrimeCell identification registers, SSPPCellID0-3 on page 3-16            */
    
    struct {
      __IM  uint32_t SSPPCELLID0 : 8;           /*!< These bits read back as 0x0D                                              */
            uint32_t            : 24;
    } bit;
  } SSPPCELLID0;
  
  union {
    __IOM uint32_t reg;                         /*!< PrimeCell identification registers, SSPPCellID0-3 on page 3-16            */
    
    struct {
      __IM  uint32_t SSPPCELLID1 : 8;           /*!< These bits read back as 0xF0                                              */
            uint32_t            : 24;
    } bit;
  } SSPPCELLID1;
  
  union {
    __IOM uint32_t reg;                         /*!< PrimeCell identification registers, SSPPCellID0-3 on page 3-16            */
    
    struct {
      __IM  uint32_t SSPPCELLID2 : 8;           /*!< These bits read back as 0x05                                              */
            uint32_t            : 24;
    } bit;
  } SSPPCELLID2;
  
  union {
    __IOM uint32_t reg;                         /*!< PrimeCell identification registers, SSPPCellID0-3 on page 3-16            */
    
    struct {
      __IM  uint32_t SSPPCELLID3 : 8;           /*!< These bits read back as 0xB1                                              */
            uint32_t            : 24;
    } bit;
  } SSPPCELLID3;
} SPI0_Type;                                    /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           PIO0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Programmable IO block (PIO0)
  */

typedef struct {                                /*!< PIO0 Structure                                                            */
  
  union {
    __IOM uint32_t reg;                         /*!< PIO control register                                                      */
    
    struct {
      __IOM uint32_t SM_ENABLE  : 4;            /*!< Enable/disable each of the four state machines by writing 1/0
                                                     to each of these four bits. When disabled, a state machine
                                                     will cease executing instructions, except those written
                                                     directly to SMx_INSTR by the system. Multiple bits can
                                                     be set/cleared at once to run/halt multiple state machines
                                                     simultaneously.                                                           */
      __OM  uint32_t SM_RESTART : 4;            /*!< Write 1 to instantly clear internal SM state which may be otherwise
                                                     difficult to access and will affect future execution. Specifically,
                                                     the following are cleared: input and output shift counters;
                                                     the contents of the input shift register; the delay counter;
                                                     the waiting-on-IRQ state; any stalled instruction written
                                                     to SMx_INSTR or run by OUT/MOV EXEC; any pin write left
                                                     asserted due to OUT_STICKY. The program counter, the contents
                                                     of the output shift register and the X/Y scratch registers
                                                     are not affected.                                                         */
      __OM  uint32_t CLKDIV_RESTART : 4;        /*!< Restart a state machine's clock divider from an initial phase
                                                     of 0. Clock dividers are free-running, so once started,
                                                     their output (including fractional jitter) is completely
                                                     determined by the integer/fractional divisor configured
                                                     in SMx_CLKDIV. This means that, if multiple clock dividers
                                                     with the same divisor are restarted simultaneously, by
                                                     writing multiple 1 bits to this field, the execution clocks
                                                     of those state machines will run in precise lockstep. Note
                                                     that setting/clearing SM_ENABLE does not stop the clock
                                                     divider from running, so once multiple state machines'
                                                     clocks are synchronised, it is safe to disable/reenable
                                                     a state machine, whilst keeping the clock dividers in sync.
                                                     Note also that CLKDIV_RESTART can be written to whilst
                                                     the state machine is running, and this is useful to resynchronise
                                                     clock dividers after the divisors (SMx_CLKDIV) have been
                                                     changed on-the-fly.                                                       */
            uint32_t            : 20;
    } bit;
  } CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< FIFO status register                                                      */
    
    struct {
      __IM  uint32_t RXFULL     : 4;            /*!< State machine RX FIFO is full                                             */
            uint32_t            : 4;
      __IM  uint32_t RXEMPTY    : 4;            /*!< State machine RX FIFO is empty                                            */
            uint32_t            : 4;
      __IM  uint32_t TXFULL     : 4;            /*!< State machine TX FIFO is full                                             */
            uint32_t            : 4;
      __IM  uint32_t TXEMPTY    : 4;            /*!< State machine TX FIFO is empty                                            */
            uint32_t            : 4;
    } bit;
  } FSTAT;
  
  union {
    __IOM uint32_t reg;                         /*!< FIFO debug register                                                       */
    
    struct {
      __IOM uint32_t RXSTALL    : 4;            /*!< State machine has stalled on full RX FIFO during a blocking
                                                     PUSH, or an IN with autopush enabled. This flag is also
                                                     set when a nonblocking PUSH to a full FIFO took place,
                                                     in which case the state machine has dropped data. Write
                                                     1 to clear.                                                               */
            uint32_t            : 4;
      __IOM uint32_t RXUNDER    : 4;            /*!< RX FIFO underflow (i.e. read-on-empty by the system) has occurred.
                                                     Write 1 to clear. Note that read-on-empty does not perturb
                                                     the state of the FIFO in any way, but the data returned
                                                     by reading from an empty FIFO is undefined, so this flag
                                                     generally only becomes set due to some kind of software
                                                     error.                                                                    */
            uint32_t            : 4;
      __IOM uint32_t TXOVER     : 4;            /*!< TX FIFO overflow (i.e. write-on-full by the system) has occurred.
                                                     Write 1 to clear. Note that write-on-full does not alter
                                                     the state or contents of the FIFO in any way, but the data
                                                     that the system attempted to write is dropped, so if this
                                                     flag is set, your software has quite likely dropped some
                                                     data on the floor.                                                        */
            uint32_t            : 4;
      __IOM uint32_t TXSTALL    : 4;            /*!< State machine has stalled on empty TX FIFO during a blocking
                                                     PULL, or an OUT with autopull enabled. Write 1 to clear.                  */
            uint32_t            : 4;
    } bit;
  } FDEBUG;
  
  union {
    __IOM uint32_t reg;                         /*!< FIFO levels                                                               */
    
    struct {
      __IM  uint32_t TX0        : 4;            /*!< TX0                                                                       */
      __IM  uint32_t RX0        : 4;            /*!< RX0                                                                       */
      __IM  uint32_t TX1        : 4;            /*!< TX1                                                                       */
      __IM  uint32_t RX1        : 4;            /*!< RX1                                                                       */
      __IM  uint32_t TX2        : 4;            /*!< TX2                                                                       */
      __IM  uint32_t RX2        : 4;            /*!< RX2                                                                       */
      __IM  uint32_t TX3        : 4;            /*!< TX3                                                                       */
      __IM  uint32_t RX3        : 4;            /*!< RX3                                                                       */
    } bit;
  } FLEVEL;
  
  union {
    __IOM uint32_t reg;                         /*!< Direct write access to the TX FIFO for this state machine. Each
                                                     write pushes one word to the FIFO. Attempting to write
                                                     to a full FIFO has no effect on the FIFO state or contents,
                                                     and sets the sticky FDEBUG_TXOVER error flag for this FIFO.               */
    
    struct {
      __OM  uint32_t TXF0       : 32;           /*!< TXF0                                                                      */
    } bit;
  } TXF0;
  
  union {
    __IOM uint32_t reg;                         /*!< Direct write access to the TX FIFO for this state machine. Each
                                                     write pushes one word to the FIFO. Attempting to write
                                                     to a full FIFO has no effect on the FIFO state or contents,
                                                     and sets the sticky FDEBUG_TXOVER error flag for this FIFO.               */
    
    struct {
      __OM  uint32_t TXF1       : 32;           /*!< TXF1                                                                      */
    } bit;
  } TXF1;
  
  union {
    __IOM uint32_t reg;                         /*!< Direct write access to the TX FIFO for this state machine. Each
                                                     write pushes one word to the FIFO. Attempting to write
                                                     to a full FIFO has no effect on the FIFO state or contents,
                                                     and sets the sticky FDEBUG_TXOVER error flag for this FIFO.               */
    
    struct {
      __OM  uint32_t TXF2       : 32;           /*!< TXF2                                                                      */
    } bit;
  } TXF2;
  
  union {
    __IOM uint32_t reg;                         /*!< Direct write access to the TX FIFO for this state machine. Each
                                                     write pushes one word to the FIFO. Attempting to write
                                                     to a full FIFO has no effect on the FIFO state or contents,
                                                     and sets the sticky FDEBUG_TXOVER error flag for this FIFO.               */
    
    struct {
      __OM  uint32_t TXF3       : 32;           /*!< TXF3                                                                      */
    } bit;
  } TXF3;
  
  union {
    __IOM uint32_t reg;                         /*!< Direct read access to the RX FIFO for this state machine. Each
                                                     read pops one word from the FIFO. Attempting to read from
                                                     an empty FIFO has no effect on the FIFO state, and sets
                                                     the sticky FDEBUG_RXUNDER error flag for this FIFO. The
                                                     data returned to the system on a read from an empty FIFO
                                                     is undefined.                                                             */
    
    struct {
      __IM  uint32_t RXF0       : 32;           /*!< RXF0                                                                      */
    } bit;
  } RXF0;
  
  union {
    __IOM uint32_t reg;                         /*!< Direct read access to the RX FIFO for this state machine. Each
                                                     read pops one word from the FIFO. Attempting to read from
                                                     an empty FIFO has no effect on the FIFO state, and sets
                                                     the sticky FDEBUG_RXUNDER error flag for this FIFO. The
                                                     data returned to the system on a read from an empty FIFO
                                                     is undefined.                                                             */
    
    struct {
      __IM  uint32_t RXF1       : 32;           /*!< RXF1                                                                      */
    } bit;
  } RXF1;
  
  union {
    __IOM uint32_t reg;                         /*!< Direct read access to the RX FIFO for this state machine. Each
                                                     read pops one word from the FIFO. Attempting to read from
                                                     an empty FIFO has no effect on the FIFO state, and sets
                                                     the sticky FDEBUG_RXUNDER error flag for this FIFO. The
                                                     data returned to the system on a read from an empty FIFO
                                                     is undefined.                                                             */
    
    struct {
      __IM  uint32_t RXF2       : 32;           /*!< RXF2                                                                      */
    } bit;
  } RXF2;
  
  union {
    __IOM uint32_t reg;                         /*!< Direct read access to the RX FIFO for this state machine. Each
                                                     read pops one word from the FIFO. Attempting to read from
                                                     an empty FIFO has no effect on the FIFO state, and sets
                                                     the sticky FDEBUG_RXUNDER error flag for this FIFO. The
                                                     data returned to the system on a read from an empty FIFO
                                                     is undefined.                                                             */
    
    struct {
      __IM  uint32_t RXF3       : 32;           /*!< RXF3                                                                      */
    } bit;
  } RXF3;
  
  union {
    __IOM uint32_t reg;                         /*!< State machine IRQ flags register. Write 1 to clear. There are
                                                     8 state machine IRQ flags, which can be set, cleared, and
                                                     waited on by the state machines. There's no fixed association
                                                     between flags and state machines -- any state machine can
                                                     use any flag. Any of the 8 flags can be used for timing
                                                     synchronisation between state machines, using IRQ and WAIT
                                                     instructions. The lower four of these flags are also routed
                                                     out to system-level interrupt requests, alongside FIFO
                                                     status interrupts -- see e.g. IRQ0_INTE.                                  */
    
    struct {
      __IOM uint32_t IRQ        : 8;            /*!< IRQ                                                                       */
            uint32_t            : 24;
    } bit;
  } IRQ;
  
  union {
    __IOM uint32_t reg;                         /*!< Writing a 1 to each of these bits will forcibly assert the corresponding
                                                     IRQ. Note this is different to the INTF register: writing
                                                     here affects PIO internal state. INTF just asserts the
                                                     processor-facing IRQ signal for testing ISRs, and is not
                                                     visible to the state machines.                                            */
    
    struct {
      __OM  uint32_t IRQ_FORCE  : 8;            /*!< IRQ_FORCE                                                                 */
            uint32_t            : 24;
    } bit;
  } IRQ_FORCE;
  
  union {
    __IOM uint32_t reg;                         /*!< There is a 2-flipflop synchronizer on each GPIO input, which
                                                     protects PIO logic from metastabilities. This increases
                                                     input delay, and for fast synchronous IO (e.g. SPI) these
                                                     synchronizers may need to be bypassed. Each bit in this
                                                     register corresponds to one GPIO. 0 -> input is synchronized
                                                     (default) 1 -> synchronizer is bypassed If in doubt, leave
                                                     this register as all zeroes.                                              */
    
    struct {
      __IOM uint32_t INPUT_SYNC_BYPASS : 32;    /*!< INPUT_SYNC_BYPASS                                                         */
    } bit;
  } INPUT_SYNC_BYPASS;
  
  union {
    __IOM uint32_t reg;                         /*!< Read to sample the pad output values PIO is currently driving
                                                     to the GPIOs. On RP2040 there are 30 GPIOs, so the two
                                                     most significant bits are hardwired to 0.                                 */
    
    struct {
      __IM  uint32_t DBG_PADOUT : 32;           /*!< DBG_PADOUT                                                                */
    } bit;
  } DBG_PADOUT;
  
  union {
    __IOM uint32_t reg;                         /*!< Read to sample the pad output enables (direction) PIO is currently
                                                     driving to the GPIOs. On RP2040 there are 30 GPIOs, so
                                                     the two most significant bits are hardwired to 0.                         */
    
    struct {
      __IM  uint32_t DBG_PADOE  : 32;           /*!< DBG_PADOE                                                                 */
    } bit;
  } DBG_PADOE;
  
  union {
    __IOM uint32_t reg;                         /*!< The PIO hardware has some free parameters that may vary between
                                                     chip products. These should be provided in the chip datasheet,
                                                     but are also exposed here.                                                */
    
    struct {
      __IM  uint32_t FIFO_DEPTH : 6;            /*!< The depth of the state machine TX/RX FIFOs, measured in words.
                                                     Joining fifos via SHIFTCTRL_FJOIN gives one FIFO with double
                                                     this depth.                                                               */
            uint32_t            : 2;
      __IM  uint32_t SM_COUNT   : 4;            /*!< The number of state machines this PIO instance is equipped with.          */
            uint32_t            : 4;
      __IM  uint32_t IMEM_SIZE  : 6;            /*!< The size of the instruction memory, measured in units of one
                                                     instruction                                                               */
            uint32_t            : 10;
    } bit;
  } DBG_CFGINFO;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 0                        */
    
    struct {
      __OM  uint32_t INSTR_MEM0 : 16;           /*!< INSTR_MEM0                                                                */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM0;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 1                        */
    
    struct {
      __OM  uint32_t INSTR_MEM1 : 16;           /*!< INSTR_MEM1                                                                */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM1;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 2                        */
    
    struct {
      __OM  uint32_t INSTR_MEM2 : 16;           /*!< INSTR_MEM2                                                                */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM2;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 3                        */
    
    struct {
      __OM  uint32_t INSTR_MEM3 : 16;           /*!< INSTR_MEM3                                                                */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM3;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 4                        */
    
    struct {
      __OM  uint32_t INSTR_MEM4 : 16;           /*!< INSTR_MEM4                                                                */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM4;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 5                        */
    
    struct {
      __OM  uint32_t INSTR_MEM5 : 16;           /*!< INSTR_MEM5                                                                */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM5;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 6                        */
    
    struct {
      __OM  uint32_t INSTR_MEM6 : 16;           /*!< INSTR_MEM6                                                                */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM6;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 7                        */
    
    struct {
      __OM  uint32_t INSTR_MEM7 : 16;           /*!< INSTR_MEM7                                                                */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM7;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 8                        */
    
    struct {
      __OM  uint32_t INSTR_MEM8 : 16;           /*!< INSTR_MEM8                                                                */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM8;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 9                        */
    
    struct {
      __OM  uint32_t INSTR_MEM9 : 16;           /*!< INSTR_MEM9                                                                */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM9;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 10                       */
    
    struct {
      __OM  uint32_t INSTR_MEM10 : 16;          /*!< INSTR_MEM10                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM10;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 11                       */
    
    struct {
      __OM  uint32_t INSTR_MEM11 : 16;          /*!< INSTR_MEM11                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM11;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 12                       */
    
    struct {
      __OM  uint32_t INSTR_MEM12 : 16;          /*!< INSTR_MEM12                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM12;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 13                       */
    
    struct {
      __OM  uint32_t INSTR_MEM13 : 16;          /*!< INSTR_MEM13                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM13;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 14                       */
    
    struct {
      __OM  uint32_t INSTR_MEM14 : 16;          /*!< INSTR_MEM14                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM14;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 15                       */
    
    struct {
      __OM  uint32_t INSTR_MEM15 : 16;          /*!< INSTR_MEM15                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM15;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 16                       */
    
    struct {
      __OM  uint32_t INSTR_MEM16 : 16;          /*!< INSTR_MEM16                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM16;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 17                       */
    
    struct {
      __OM  uint32_t INSTR_MEM17 : 16;          /*!< INSTR_MEM17                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM17;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 18                       */
    
    struct {
      __OM  uint32_t INSTR_MEM18 : 16;          /*!< INSTR_MEM18                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM18;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 19                       */
    
    struct {
      __OM  uint32_t INSTR_MEM19 : 16;          /*!< INSTR_MEM19                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM19;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 20                       */
    
    struct {
      __OM  uint32_t INSTR_MEM20 : 16;          /*!< INSTR_MEM20                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM20;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 21                       */
    
    struct {
      __OM  uint32_t INSTR_MEM21 : 16;          /*!< INSTR_MEM21                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM21;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 22                       */
    
    struct {
      __OM  uint32_t INSTR_MEM22 : 16;          /*!< INSTR_MEM22                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM22;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 23                       */
    
    struct {
      __OM  uint32_t INSTR_MEM23 : 16;          /*!< INSTR_MEM23                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM23;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 24                       */
    
    struct {
      __OM  uint32_t INSTR_MEM24 : 16;          /*!< INSTR_MEM24                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM24;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 25                       */
    
    struct {
      __OM  uint32_t INSTR_MEM25 : 16;          /*!< INSTR_MEM25                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM25;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 26                       */
    
    struct {
      __OM  uint32_t INSTR_MEM26 : 16;          /*!< INSTR_MEM26                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM26;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 27                       */
    
    struct {
      __OM  uint32_t INSTR_MEM27 : 16;          /*!< INSTR_MEM27                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM27;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 28                       */
    
    struct {
      __OM  uint32_t INSTR_MEM28 : 16;          /*!< INSTR_MEM28                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM28;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 29                       */
    
    struct {
      __OM  uint32_t INSTR_MEM29 : 16;          /*!< INSTR_MEM29                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM29;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 30                       */
    
    struct {
      __OM  uint32_t INSTR_MEM30 : 16;          /*!< INSTR_MEM30                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM30;
  
  union {
    __IOM uint32_t reg;                         /*!< Write-only access to instruction memory location 31                       */
    
    struct {
      __OM  uint32_t INSTR_MEM31 : 16;          /*!< INSTR_MEM31                                                               */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM31;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock divisor register for state machine 0 Frequency = clock
                                                     freq / (CLKDIV_INT + CLKDIV_FRAC / 256)                                   */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t FRAC       : 8;            /*!< Fractional part of clock divisor                                          */
      __IOM uint32_t INT        : 16;           /*!< Effective frequency is sysclk/(int + frac/256). Value of 0 is
                                                     interpreted as 65536. If INT is 0, FRAC must also be 0.                   */
    } bit;
  } SM0_CLKDIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Execution/behavioural settings for state machine 0                        */
    
    struct {
      __IOM uint32_t STATUS_N   : 4;            /*!< Comparison level for the MOV x, STATUS instruction                        */
      __IOM uint32_t STATUS_SEL : 1;            /*!< Comparison used for the MOV x, STATUS instruction.                        */
            uint32_t            : 2;
      __IOM uint32_t WRAP_BOTTOM : 5;           /*!< After reaching wrap_top, execution is wrapped to this address.            */
      __IOM uint32_t WRAP_TOP   : 5;            /*!< After reaching this address, execution is wrapped to wrap_bottom.
                                                     If the instruction is a jump, and the jump condition is
                                                     true, the jump takes priority.                                            */
      __IOM uint32_t OUT_STICKY : 1;            /*!< Continuously assert the most recent OUT/SET to the pins                   */
      __IOM uint32_t INLINE_OUT_EN : 1;         /*!< If 1, use a bit of OUT data as an auxiliary write enable When
                                                     used in conjunction with OUT_STICKY, writes with an enable
                                                     of 0 will deassert the latest pin write. This can create
                                                     useful masking/override behaviour due to the priority ordering
                                                     of state machine pin writes (SM0 < SM1 < ...)                             */
      __IOM uint32_t OUT_EN_SEL : 5;            /*!< Which data bit to use for inline OUT enable                               */
      __IOM uint32_t JMP_PIN    : 5;            /*!< The GPIO number to use as condition for JMP PIN. Unaffected
                                                     by input mapping.                                                         */
      __IOM uint32_t SIDE_PINDIR : 1;           /*!< If 1, side-set data is asserted to pin directions, instead of
                                                     pin values                                                                */
      __IOM uint32_t SIDE_EN    : 1;            /*!< If 1, the MSB of the Delay/Side-set instruction field is used
                                                     as side-set enable, rather than a side-set data bit. This
                                                     allows instructions to perform side-set optionally, rather
                                                     than on every instruction, but the maximum possible side-set
                                                     width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUN
                                                     is inclusive of this enable bit.                                          */
      __IM  uint32_t EXEC_STALLED : 1;          /*!< If 1, an instruction written to SMx_INSTR is stalled, and latched
                                                     by the state machine. Will clear to 0 once this instruction
                                                     completes.                                                                */
    } bit;
  } SM0_EXECCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Control behaviour of the input/output shift registers for state
                                                     machine 0                                                                 */
    
    struct {
            uint32_t            : 16;
      __IOM uint32_t AUTOPUSH   : 1;            /*!< Push automatically when the input shift register is filled,
                                                     i.e. on an IN instruction which causes the input shift
                                                     counter to reach or exceed PUSH_THRESH.                                   */
      __IOM uint32_t AUTOPULL   : 1;            /*!< Pull automatically when the output shift register is emptied,
                                                     i.e. on or following an OUT instruction which causes the
                                                     output shift counter to reach or exceed PULL_THRESH.                      */
      __IOM uint32_t IN_SHIFTDIR : 1;           /*!< 1 = shift input shift register to right (data enters from left).
                                                     0 = to left.                                                              */
      __IOM uint32_t OUT_SHIFTDIR : 1;          /*!< 1 = shift out of output shift register to right. 0 = to left.             */
      __IOM uint32_t PUSH_THRESH : 5;           /*!< Number of bits shifted into ISR before autopush, or conditional
                                                     push (PUSH IFFULL), will take place. Write 0 for value
                                                     of 32.                                                                    */
      __IOM uint32_t PULL_THRESH : 5;           /*!< Number of bits shifted out of OSR before autopull, or conditional
                                                     pull (PULL IFEMPTY), will take place. Write 0 for value
                                                     of 32.                                                                    */
      __IOM uint32_t FJOIN_TX   : 1;            /*!< When 1, TX FIFO steals the RX FIFO's storage, and becomes twice
                                                     as deep. RX FIFO is disabled as a result (always reads
                                                     as both full and empty). FIFOs are flushed when this bit
                                                     is changed.                                                               */
      __IOM uint32_t FJOIN_RX   : 1;            /*!< When 1, RX FIFO steals the TX FIFO's storage, and becomes twice
                                                     as deep. TX FIFO is disabled as a result (always reads
                                                     as both full and empty). FIFOs are flushed when this bit
                                                     is changed.                                                               */
    } bit;
  } SM0_SHIFTCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Current instruction address of state machine 0                            */
    
    struct {
      __IM  uint32_t SM0_ADDR   : 5;            /*!< SM0_ADDR                                                                  */
            uint32_t            : 27;
    } bit;
  } SM0_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Read to see the instruction currently addressed by state machine
                                                     0's program counter Write to execute an instruction immediately
                                                     (including jumps) and then resume execution.                              */
    
    struct {
      __IOM uint32_t SM0_INSTR  : 16;           /*!< SM0_INSTR                                                                 */
            uint32_t            : 16;
    } bit;
  } SM0_INSTR;
  
  union {
    __IOM uint32_t reg;                         /*!< State machine pin control                                                 */
    
    struct {
      __IOM uint32_t OUT_BASE   : 5;            /*!< The lowest-numbered pin that will be affected by an OUT PINS,
                                                     OUT PINDIRS or MOV PINS instruction. The data written to
                                                     this pin will always be the least-significant bit of the
                                                     OUT or MOV data.                                                          */
      __IOM uint32_t SET_BASE   : 5;            /*!< The lowest-numbered pin that will be affected by a SET PINS
                                                     or SET PINDIRS instruction. The data written to this pin
                                                     is the least-significant bit of the SET data.                             */
      __IOM uint32_t SIDESET_BASE : 5;          /*!< The lowest-numbered pin that will be affected by a side-set
                                                     operation. The MSBs of an instruction's side-set/delay
                                                     field (up to 5, determined by SIDESET_COUNT) are used for
                                                     side-set data, with the remaining LSBs used for delay.
                                                     The least-significant bit of the side-set portion is the
                                                     bit written to this pin, with more-significant bits written
                                                     to higher-numbered pins.                                                  */
      __IOM uint32_t IN_BASE    : 5;            /*!< The pin which is mapped to the least-significant bit of a state
                                                     machine's IN data bus. Higher-numbered pins are mapped
                                                     to consecutively more-significant data bits, with a modulo
                                                     of 32 applied to pin number.                                              */
      __IOM uint32_t OUT_COUNT  : 6;            /*!< The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV
                                                     PINS instruction. In the range 0 to 32 inclusive.                         */
      __IOM uint32_t SET_COUNT  : 3;            /*!< The number of pins asserted by a SET. In the range 0 to 5 inclusive.      */
      __IOM uint32_t SIDESET_COUNT : 3;         /*!< The number of MSBs of the Delay/Side-set instruction field which
                                                     are used for side-set. Inclusive of the enable bit, if
                                                     present. Minimum of 0 (all delay bits, no side-set) and
                                                     maximum of 5 (all side-set, no delay).                                    */
    } bit;
  } SM0_PINCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock divisor register for state machine 1 Frequency = clock
                                                     freq / (CLKDIV_INT + CLKDIV_FRAC / 256)                                   */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t FRAC       : 8;            /*!< Fractional part of clock divisor                                          */
      __IOM uint32_t INT        : 16;           /*!< Effective frequency is sysclk/(int + frac/256). Value of 0 is
                                                     interpreted as 65536. If INT is 0, FRAC must also be 0.                   */
    } bit;
  } SM1_CLKDIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Execution/behavioural settings for state machine 1                        */
    
    struct {
      __IOM uint32_t STATUS_N   : 4;            /*!< Comparison level for the MOV x, STATUS instruction                        */
      __IOM uint32_t STATUS_SEL : 1;            /*!< Comparison used for the MOV x, STATUS instruction.                        */
            uint32_t            : 2;
      __IOM uint32_t WRAP_BOTTOM : 5;           /*!< After reaching wrap_top, execution is wrapped to this address.            */
      __IOM uint32_t WRAP_TOP   : 5;            /*!< After reaching this address, execution is wrapped to wrap_bottom.
                                                     If the instruction is a jump, and the jump condition is
                                                     true, the jump takes priority.                                            */
      __IOM uint32_t OUT_STICKY : 1;            /*!< Continuously assert the most recent OUT/SET to the pins                   */
      __IOM uint32_t INLINE_OUT_EN : 1;         /*!< If 1, use a bit of OUT data as an auxiliary write enable When
                                                     used in conjunction with OUT_STICKY, writes with an enable
                                                     of 0 will deassert the latest pin write. This can create
                                                     useful masking/override behaviour due to the priority ordering
                                                     of state machine pin writes (SM0 < SM1 < ...)                             */
      __IOM uint32_t OUT_EN_SEL : 5;            /*!< Which data bit to use for inline OUT enable                               */
      __IOM uint32_t JMP_PIN    : 5;            /*!< The GPIO number to use as condition for JMP PIN. Unaffected
                                                     by input mapping.                                                         */
      __IOM uint32_t SIDE_PINDIR : 1;           /*!< If 1, side-set data is asserted to pin directions, instead of
                                                     pin values                                                                */
      __IOM uint32_t SIDE_EN    : 1;            /*!< If 1, the MSB of the Delay/Side-set instruction field is used
                                                     as side-set enable, rather than a side-set data bit. This
                                                     allows instructions to perform side-set optionally, rather
                                                     than on every instruction, but the maximum possible side-set
                                                     width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUN
                                                     is inclusive of this enable bit.                                          */
      __IM  uint32_t EXEC_STALLED : 1;          /*!< If 1, an instruction written to SMx_INSTR is stalled, and latched
                                                     by the state machine. Will clear to 0 once this instruction
                                                     completes.                                                                */
    } bit;
  } SM1_EXECCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Control behaviour of the input/output shift registers for state
                                                     machine 1                                                                 */
    
    struct {
            uint32_t            : 16;
      __IOM uint32_t AUTOPUSH   : 1;            /*!< Push automatically when the input shift register is filled,
                                                     i.e. on an IN instruction which causes the input shift
                                                     counter to reach or exceed PUSH_THRESH.                                   */
      __IOM uint32_t AUTOPULL   : 1;            /*!< Pull automatically when the output shift register is emptied,
                                                     i.e. on or following an OUT instruction which causes the
                                                     output shift counter to reach or exceed PULL_THRESH.                      */
      __IOM uint32_t IN_SHIFTDIR : 1;           /*!< 1 = shift input shift register to right (data enters from left).
                                                     0 = to left.                                                              */
      __IOM uint32_t OUT_SHIFTDIR : 1;          /*!< 1 = shift out of output shift register to right. 0 = to left.             */
      __IOM uint32_t PUSH_THRESH : 5;           /*!< Number of bits shifted into ISR before autopush, or conditional
                                                     push (PUSH IFFULL), will take place. Write 0 for value
                                                     of 32.                                                                    */
      __IOM uint32_t PULL_THRESH : 5;           /*!< Number of bits shifted out of OSR before autopull, or conditional
                                                     pull (PULL IFEMPTY), will take place. Write 0 for value
                                                     of 32.                                                                    */
      __IOM uint32_t FJOIN_TX   : 1;            /*!< When 1, TX FIFO steals the RX FIFO's storage, and becomes twice
                                                     as deep. RX FIFO is disabled as a result (always reads
                                                     as both full and empty). FIFOs are flushed when this bit
                                                     is changed.                                                               */
      __IOM uint32_t FJOIN_RX   : 1;            /*!< When 1, RX FIFO steals the TX FIFO's storage, and becomes twice
                                                     as deep. TX FIFO is disabled as a result (always reads
                                                     as both full and empty). FIFOs are flushed when this bit
                                                     is changed.                                                               */
    } bit;
  } SM1_SHIFTCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Current instruction address of state machine 1                            */
    
    struct {
      __IM  uint32_t SM1_ADDR   : 5;            /*!< SM1_ADDR                                                                  */
            uint32_t            : 27;
    } bit;
  } SM1_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Read to see the instruction currently addressed by state machine
                                                     1's program counter Write to execute an instruction immediately
                                                     (including jumps) and then resume execution.                              */
    
    struct {
      __IOM uint32_t SM1_INSTR  : 16;           /*!< SM1_INSTR                                                                 */
            uint32_t            : 16;
    } bit;
  } SM1_INSTR;
  
  union {
    __IOM uint32_t reg;                         /*!< State machine pin control                                                 */
    
    struct {
      __IOM uint32_t OUT_BASE   : 5;            /*!< The lowest-numbered pin that will be affected by an OUT PINS,
                                                     OUT PINDIRS or MOV PINS instruction. The data written to
                                                     this pin will always be the least-significant bit of the
                                                     OUT or MOV data.                                                          */
      __IOM uint32_t SET_BASE   : 5;            /*!< The lowest-numbered pin that will be affected by a SET PINS
                                                     or SET PINDIRS instruction. The data written to this pin
                                                     is the least-significant bit of the SET data.                             */
      __IOM uint32_t SIDESET_BASE : 5;          /*!< The lowest-numbered pin that will be affected by a side-set
                                                     operation. The MSBs of an instruction's side-set/delay
                                                     field (up to 5, determined by SIDESET_COUNT) are used for
                                                     side-set data, with the remaining LSBs used for delay.
                                                     The least-significant bit of the side-set portion is the
                                                     bit written to this pin, with more-significant bits written
                                                     to higher-numbered pins.                                                  */
      __IOM uint32_t IN_BASE    : 5;            /*!< The pin which is mapped to the least-significant bit of a state
                                                     machine's IN data bus. Higher-numbered pins are mapped
                                                     to consecutively more-significant data bits, with a modulo
                                                     of 32 applied to pin number.                                              */
      __IOM uint32_t OUT_COUNT  : 6;            /*!< The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV
                                                     PINS instruction. In the range 0 to 32 inclusive.                         */
      __IOM uint32_t SET_COUNT  : 3;            /*!< The number of pins asserted by a SET. In the range 0 to 5 inclusive.      */
      __IOM uint32_t SIDESET_COUNT : 3;         /*!< The number of MSBs of the Delay/Side-set instruction field which
                                                     are used for side-set. Inclusive of the enable bit, if
                                                     present. Minimum of 0 (all delay bits, no side-set) and
                                                     maximum of 5 (all side-set, no delay).                                    */
    } bit;
  } SM1_PINCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock divisor register for state machine 2 Frequency = clock
                                                     freq / (CLKDIV_INT + CLKDIV_FRAC / 256)                                   */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t FRAC       : 8;            /*!< Fractional part of clock divisor                                          */
      __IOM uint32_t INT        : 16;           /*!< Effective frequency is sysclk/(int + frac/256). Value of 0 is
                                                     interpreted as 65536. If INT is 0, FRAC must also be 0.                   */
    } bit;
  } SM2_CLKDIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Execution/behavioural settings for state machine 2                        */
    
    struct {
      __IOM uint32_t STATUS_N   : 4;            /*!< Comparison level for the MOV x, STATUS instruction                        */
      __IOM uint32_t STATUS_SEL : 1;            /*!< Comparison used for the MOV x, STATUS instruction.                        */
            uint32_t            : 2;
      __IOM uint32_t WRAP_BOTTOM : 5;           /*!< After reaching wrap_top, execution is wrapped to this address.            */
      __IOM uint32_t WRAP_TOP   : 5;            /*!< After reaching this address, execution is wrapped to wrap_bottom.
                                                     If the instruction is a jump, and the jump condition is
                                                     true, the jump takes priority.                                            */
      __IOM uint32_t OUT_STICKY : 1;            /*!< Continuously assert the most recent OUT/SET to the pins                   */
      __IOM uint32_t INLINE_OUT_EN : 1;         /*!< If 1, use a bit of OUT data as an auxiliary write enable When
                                                     used in conjunction with OUT_STICKY, writes with an enable
                                                     of 0 will deassert the latest pin write. This can create
                                                     useful masking/override behaviour due to the priority ordering
                                                     of state machine pin writes (SM0 < SM1 < ...)                             */
      __IOM uint32_t OUT_EN_SEL : 5;            /*!< Which data bit to use for inline OUT enable                               */
      __IOM uint32_t JMP_PIN    : 5;            /*!< The GPIO number to use as condition for JMP PIN. Unaffected
                                                     by input mapping.                                                         */
      __IOM uint32_t SIDE_PINDIR : 1;           /*!< If 1, side-set data is asserted to pin directions, instead of
                                                     pin values                                                                */
      __IOM uint32_t SIDE_EN    : 1;            /*!< If 1, the MSB of the Delay/Side-set instruction field is used
                                                     as side-set enable, rather than a side-set data bit. This
                                                     allows instructions to perform side-set optionally, rather
                                                     than on every instruction, but the maximum possible side-set
                                                     width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUN
                                                     is inclusive of this enable bit.                                          */
      __IM  uint32_t EXEC_STALLED : 1;          /*!< If 1, an instruction written to SMx_INSTR is stalled, and latched
                                                     by the state machine. Will clear to 0 once this instruction
                                                     completes.                                                                */
    } bit;
  } SM2_EXECCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Control behaviour of the input/output shift registers for state
                                                     machine 2                                                                 */
    
    struct {
            uint32_t            : 16;
      __IOM uint32_t AUTOPUSH   : 1;            /*!< Push automatically when the input shift register is filled,
                                                     i.e. on an IN instruction which causes the input shift
                                                     counter to reach or exceed PUSH_THRESH.                                   */
      __IOM uint32_t AUTOPULL   : 1;            /*!< Pull automatically when the output shift register is emptied,
                                                     i.e. on or following an OUT instruction which causes the
                                                     output shift counter to reach or exceed PULL_THRESH.                      */
      __IOM uint32_t IN_SHIFTDIR : 1;           /*!< 1 = shift input shift register to right (data enters from left).
                                                     0 = to left.                                                              */
      __IOM uint32_t OUT_SHIFTDIR : 1;          /*!< 1 = shift out of output shift register to right. 0 = to left.             */
      __IOM uint32_t PUSH_THRESH : 5;           /*!< Number of bits shifted into ISR before autopush, or conditional
                                                     push (PUSH IFFULL), will take place. Write 0 for value
                                                     of 32.                                                                    */
      __IOM uint32_t PULL_THRESH : 5;           /*!< Number of bits shifted out of OSR before autopull, or conditional
                                                     pull (PULL IFEMPTY), will take place. Write 0 for value
                                                     of 32.                                                                    */
      __IOM uint32_t FJOIN_TX   : 1;            /*!< When 1, TX FIFO steals the RX FIFO's storage, and becomes twice
                                                     as deep. RX FIFO is disabled as a result (always reads
                                                     as both full and empty). FIFOs are flushed when this bit
                                                     is changed.                                                               */
      __IOM uint32_t FJOIN_RX   : 1;            /*!< When 1, RX FIFO steals the TX FIFO's storage, and becomes twice
                                                     as deep. TX FIFO is disabled as a result (always reads
                                                     as both full and empty). FIFOs are flushed when this bit
                                                     is changed.                                                               */
    } bit;
  } SM2_SHIFTCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Current instruction address of state machine 2                            */
    
    struct {
      __IM  uint32_t SM2_ADDR   : 5;            /*!< SM2_ADDR                                                                  */
            uint32_t            : 27;
    } bit;
  } SM2_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Read to see the instruction currently addressed by state machine
                                                     2's program counter Write to execute an instruction immediately
                                                     (including jumps) and then resume execution.                              */
    
    struct {
      __IOM uint32_t SM2_INSTR  : 16;           /*!< SM2_INSTR                                                                 */
            uint32_t            : 16;
    } bit;
  } SM2_INSTR;
  
  union {
    __IOM uint32_t reg;                         /*!< State machine pin control                                                 */
    
    struct {
      __IOM uint32_t OUT_BASE   : 5;            /*!< The lowest-numbered pin that will be affected by an OUT PINS,
                                                     OUT PINDIRS or MOV PINS instruction. The data written to
                                                     this pin will always be the least-significant bit of the
                                                     OUT or MOV data.                                                          */
      __IOM uint32_t SET_BASE   : 5;            /*!< The lowest-numbered pin that will be affected by a SET PINS
                                                     or SET PINDIRS instruction. The data written to this pin
                                                     is the least-significant bit of the SET data.                             */
      __IOM uint32_t SIDESET_BASE : 5;          /*!< The lowest-numbered pin that will be affected by a side-set
                                                     operation. The MSBs of an instruction's side-set/delay
                                                     field (up to 5, determined by SIDESET_COUNT) are used for
                                                     side-set data, with the remaining LSBs used for delay.
                                                     The least-significant bit of the side-set portion is the
                                                     bit written to this pin, with more-significant bits written
                                                     to higher-numbered pins.                                                  */
      __IOM uint32_t IN_BASE    : 5;            /*!< The pin which is mapped to the least-significant bit of a state
                                                     machine's IN data bus. Higher-numbered pins are mapped
                                                     to consecutively more-significant data bits, with a modulo
                                                     of 32 applied to pin number.                                              */
      __IOM uint32_t OUT_COUNT  : 6;            /*!< The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV
                                                     PINS instruction. In the range 0 to 32 inclusive.                         */
      __IOM uint32_t SET_COUNT  : 3;            /*!< The number of pins asserted by a SET. In the range 0 to 5 inclusive.      */
      __IOM uint32_t SIDESET_COUNT : 3;         /*!< The number of MSBs of the Delay/Side-set instruction field which
                                                     are used for side-set. Inclusive of the enable bit, if
                                                     present. Minimum of 0 (all delay bits, no side-set) and
                                                     maximum of 5 (all side-set, no delay).                                    */
    } bit;
  } SM2_PINCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock divisor register for state machine 3 Frequency = clock
                                                     freq / (CLKDIV_INT + CLKDIV_FRAC / 256)                                   */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t FRAC       : 8;            /*!< Fractional part of clock divisor                                          */
      __IOM uint32_t INT        : 16;           /*!< Effective frequency is sysclk/(int + frac/256). Value of 0 is
                                                     interpreted as 65536. If INT is 0, FRAC must also be 0.                   */
    } bit;
  } SM3_CLKDIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Execution/behavioural settings for state machine 3                        */
    
    struct {
      __IOM uint32_t STATUS_N   : 4;            /*!< Comparison level for the MOV x, STATUS instruction                        */
      __IOM uint32_t STATUS_SEL : 1;            /*!< Comparison used for the MOV x, STATUS instruction.                        */
            uint32_t            : 2;
      __IOM uint32_t WRAP_BOTTOM : 5;           /*!< After reaching wrap_top, execution is wrapped to this address.            */
      __IOM uint32_t WRAP_TOP   : 5;            /*!< After reaching this address, execution is wrapped to wrap_bottom.
                                                     If the instruction is a jump, and the jump condition is
                                                     true, the jump takes priority.                                            */
      __IOM uint32_t OUT_STICKY : 1;            /*!< Continuously assert the most recent OUT/SET to the pins                   */
      __IOM uint32_t INLINE_OUT_EN : 1;         /*!< If 1, use a bit of OUT data as an auxiliary write enable When
                                                     used in conjunction with OUT_STICKY, writes with an enable
                                                     of 0 will deassert the latest pin write. This can create
                                                     useful masking/override behaviour due to the priority ordering
                                                     of state machine pin writes (SM0 < SM1 < ...)                             */
      __IOM uint32_t OUT_EN_SEL : 5;            /*!< Which data bit to use for inline OUT enable                               */
      __IOM uint32_t JMP_PIN    : 5;            /*!< The GPIO number to use as condition for JMP PIN. Unaffected
                                                     by input mapping.                                                         */
      __IOM uint32_t SIDE_PINDIR : 1;           /*!< If 1, side-set data is asserted to pin directions, instead of
                                                     pin values                                                                */
      __IOM uint32_t SIDE_EN    : 1;            /*!< If 1, the MSB of the Delay/Side-set instruction field is used
                                                     as side-set enable, rather than a side-set data bit. This
                                                     allows instructions to perform side-set optionally, rather
                                                     than on every instruction, but the maximum possible side-set
                                                     width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUN
                                                     is inclusive of this enable bit.                                          */
      __IM  uint32_t EXEC_STALLED : 1;          /*!< If 1, an instruction written to SMx_INSTR is stalled, and latched
                                                     by the state machine. Will clear to 0 once this instruction
                                                     completes.                                                                */
    } bit;
  } SM3_EXECCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Control behaviour of the input/output shift registers for state
                                                     machine 3                                                                 */
    
    struct {
            uint32_t            : 16;
      __IOM uint32_t AUTOPUSH   : 1;            /*!< Push automatically when the input shift register is filled,
                                                     i.e. on an IN instruction which causes the input shift
                                                     counter to reach or exceed PUSH_THRESH.                                   */
      __IOM uint32_t AUTOPULL   : 1;            /*!< Pull automatically when the output shift register is emptied,
                                                     i.e. on or following an OUT instruction which causes the
                                                     output shift counter to reach or exceed PULL_THRESH.                      */
      __IOM uint32_t IN_SHIFTDIR : 1;           /*!< 1 = shift input shift register to right (data enters from left).
                                                     0 = to left.                                                              */
      __IOM uint32_t OUT_SHIFTDIR : 1;          /*!< 1 = shift out of output shift register to right. 0 = to left.             */
      __IOM uint32_t PUSH_THRESH : 5;           /*!< Number of bits shifted into ISR before autopush, or conditional
                                                     push (PUSH IFFULL), will take place. Write 0 for value
                                                     of 32.                                                                    */
      __IOM uint32_t PULL_THRESH : 5;           /*!< Number of bits shifted out of OSR before autopull, or conditional
                                                     pull (PULL IFEMPTY), will take place. Write 0 for value
                                                     of 32.                                                                    */
      __IOM uint32_t FJOIN_TX   : 1;            /*!< When 1, TX FIFO steals the RX FIFO's storage, and becomes twice
                                                     as deep. RX FIFO is disabled as a result (always reads
                                                     as both full and empty). FIFOs are flushed when this bit
                                                     is changed.                                                               */
      __IOM uint32_t FJOIN_RX   : 1;            /*!< When 1, RX FIFO steals the TX FIFO's storage, and becomes twice
                                                     as deep. TX FIFO is disabled as a result (always reads
                                                     as both full and empty). FIFOs are flushed when this bit
                                                     is changed.                                                               */
    } bit;
  } SM3_SHIFTCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Current instruction address of state machine 3                            */
    
    struct {
      __IM  uint32_t SM3_ADDR   : 5;            /*!< SM3_ADDR                                                                  */
            uint32_t            : 27;
    } bit;
  } SM3_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Read to see the instruction currently addressed by state machine
                                                     3's program counter Write to execute an instruction immediately
                                                     (including jumps) and then resume execution.                              */
    
    struct {
      __IOM uint32_t SM3_INSTR  : 16;           /*!< SM3_INSTR                                                                 */
            uint32_t            : 16;
    } bit;
  } SM3_INSTR;
  
  union {
    __IOM uint32_t reg;                         /*!< State machine pin control                                                 */
    
    struct {
      __IOM uint32_t OUT_BASE   : 5;            /*!< The lowest-numbered pin that will be affected by an OUT PINS,
                                                     OUT PINDIRS or MOV PINS instruction. The data written to
                                                     this pin will always be the least-significant bit of the
                                                     OUT or MOV data.                                                          */
      __IOM uint32_t SET_BASE   : 5;            /*!< The lowest-numbered pin that will be affected by a SET PINS
                                                     or SET PINDIRS instruction. The data written to this pin
                                                     is the least-significant bit of the SET data.                             */
      __IOM uint32_t SIDESET_BASE : 5;          /*!< The lowest-numbered pin that will be affected by a side-set
                                                     operation. The MSBs of an instruction's side-set/delay
                                                     field (up to 5, determined by SIDESET_COUNT) are used for
                                                     side-set data, with the remaining LSBs used for delay.
                                                     The least-significant bit of the side-set portion is the
                                                     bit written to this pin, with more-significant bits written
                                                     to higher-numbered pins.                                                  */
      __IOM uint32_t IN_BASE    : 5;            /*!< The pin which is mapped to the least-significant bit of a state
                                                     machine's IN data bus. Higher-numbered pins are mapped
                                                     to consecutively more-significant data bits, with a modulo
                                                     of 32 applied to pin number.                                              */
      __IOM uint32_t OUT_COUNT  : 6;            /*!< The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV
                                                     PINS instruction. In the range 0 to 32 inclusive.                         */
      __IOM uint32_t SET_COUNT  : 3;            /*!< The number of pins asserted by a SET. In the range 0 to 5 inclusive.      */
      __IOM uint32_t SIDESET_COUNT : 3;         /*!< The number of MSBs of the Delay/Side-set instruction field which
                                                     are used for side-set. Inclusive of the enable bit, if
                                                     present. Minimum of 0 (all delay bits, no side-set) and
                                                     maximum of 5 (all side-set, no delay).                                    */
    } bit;
  } SM3_PINCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw Interrupts                                                            */
    
    struct {
      __IM  uint32_t SM0_RXNEMPTY : 1;          /*!< SM0_RXNEMPTY                                                              */
      __IM  uint32_t SM1_RXNEMPTY : 1;          /*!< SM1_RXNEMPTY                                                              */
      __IM  uint32_t SM2_RXNEMPTY : 1;          /*!< SM2_RXNEMPTY                                                              */
      __IM  uint32_t SM3_RXNEMPTY : 1;          /*!< SM3_RXNEMPTY                                                              */
      __IM  uint32_t SM0_TXNFULL : 1;           /*!< SM0_TXNFULL                                                               */
      __IM  uint32_t SM1_TXNFULL : 1;           /*!< SM1_TXNFULL                                                               */
      __IM  uint32_t SM2_TXNFULL : 1;           /*!< SM2_TXNFULL                                                               */
      __IM  uint32_t SM3_TXNFULL : 1;           /*!< SM3_TXNFULL                                                               */
      __IM  uint32_t SM0        : 1;            /*!< SM0                                                                       */
      __IM  uint32_t SM1        : 1;            /*!< SM1                                                                       */
      __IM  uint32_t SM2        : 1;            /*!< SM2                                                                       */
      __IM  uint32_t SM3        : 1;            /*!< SM3                                                                       */
            uint32_t            : 20;
    } bit;
  } INTR;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable for irq0                                                 */
    
    struct {
      __IOM uint32_t SM0_RXNEMPTY : 1;          /*!< SM0_RXNEMPTY                                                              */
      __IOM uint32_t SM1_RXNEMPTY : 1;          /*!< SM1_RXNEMPTY                                                              */
      __IOM uint32_t SM2_RXNEMPTY : 1;          /*!< SM2_RXNEMPTY                                                              */
      __IOM uint32_t SM3_RXNEMPTY : 1;          /*!< SM3_RXNEMPTY                                                              */
      __IOM uint32_t SM0_TXNFULL : 1;           /*!< SM0_TXNFULL                                                               */
      __IOM uint32_t SM1_TXNFULL : 1;           /*!< SM1_TXNFULL                                                               */
      __IOM uint32_t SM2_TXNFULL : 1;           /*!< SM2_TXNFULL                                                               */
      __IOM uint32_t SM3_TXNFULL : 1;           /*!< SM3_TXNFULL                                                               */
      __IOM uint32_t SM0        : 1;            /*!< SM0                                                                       */
      __IOM uint32_t SM1        : 1;            /*!< SM1                                                                       */
      __IOM uint32_t SM2        : 1;            /*!< SM2                                                                       */
      __IOM uint32_t SM3        : 1;            /*!< SM3                                                                       */
            uint32_t            : 20;
    } bit;
  } IRQ0_INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force for irq0                                                  */
    
    struct {
      __IOM uint32_t SM0_RXNEMPTY : 1;          /*!< SM0_RXNEMPTY                                                              */
      __IOM uint32_t SM1_RXNEMPTY : 1;          /*!< SM1_RXNEMPTY                                                              */
      __IOM uint32_t SM2_RXNEMPTY : 1;          /*!< SM2_RXNEMPTY                                                              */
      __IOM uint32_t SM3_RXNEMPTY : 1;          /*!< SM3_RXNEMPTY                                                              */
      __IOM uint32_t SM0_TXNFULL : 1;           /*!< SM0_TXNFULL                                                               */
      __IOM uint32_t SM1_TXNFULL : 1;           /*!< SM1_TXNFULL                                                               */
      __IOM uint32_t SM2_TXNFULL : 1;           /*!< SM2_TXNFULL                                                               */
      __IOM uint32_t SM3_TXNFULL : 1;           /*!< SM3_TXNFULL                                                               */
      __IOM uint32_t SM0        : 1;            /*!< SM0                                                                       */
      __IOM uint32_t SM1        : 1;            /*!< SM1                                                                       */
      __IOM uint32_t SM2        : 1;            /*!< SM2                                                                       */
      __IOM uint32_t SM3        : 1;            /*!< SM3                                                                       */
            uint32_t            : 20;
    } bit;
  } IRQ0_INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing for irq0                         */
    
    struct {
      __IM  uint32_t SM0_RXNEMPTY : 1;          /*!< SM0_RXNEMPTY                                                              */
      __IM  uint32_t SM1_RXNEMPTY : 1;          /*!< SM1_RXNEMPTY                                                              */
      __IM  uint32_t SM2_RXNEMPTY : 1;          /*!< SM2_RXNEMPTY                                                              */
      __IM  uint32_t SM3_RXNEMPTY : 1;          /*!< SM3_RXNEMPTY                                                              */
      __IM  uint32_t SM0_TXNFULL : 1;           /*!< SM0_TXNFULL                                                               */
      __IM  uint32_t SM1_TXNFULL : 1;           /*!< SM1_TXNFULL                                                               */
      __IM  uint32_t SM2_TXNFULL : 1;           /*!< SM2_TXNFULL                                                               */
      __IM  uint32_t SM3_TXNFULL : 1;           /*!< SM3_TXNFULL                                                               */
      __IM  uint32_t SM0        : 1;            /*!< SM0                                                                       */
      __IM  uint32_t SM1        : 1;            /*!< SM1                                                                       */
      __IM  uint32_t SM2        : 1;            /*!< SM2                                                                       */
      __IM  uint32_t SM3        : 1;            /*!< SM3                                                                       */
            uint32_t            : 20;
    } bit;
  } IRQ0_INTS;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable for irq1                                                 */
    
    struct {
      __IOM uint32_t SM0_RXNEMPTY : 1;          /*!< SM0_RXNEMPTY                                                              */
      __IOM uint32_t SM1_RXNEMPTY : 1;          /*!< SM1_RXNEMPTY                                                              */
      __IOM uint32_t SM2_RXNEMPTY : 1;          /*!< SM2_RXNEMPTY                                                              */
      __IOM uint32_t SM3_RXNEMPTY : 1;          /*!< SM3_RXNEMPTY                                                              */
      __IOM uint32_t SM0_TXNFULL : 1;           /*!< SM0_TXNFULL                                                               */
      __IOM uint32_t SM1_TXNFULL : 1;           /*!< SM1_TXNFULL                                                               */
      __IOM uint32_t SM2_TXNFULL : 1;           /*!< SM2_TXNFULL                                                               */
      __IOM uint32_t SM3_TXNFULL : 1;           /*!< SM3_TXNFULL                                                               */
      __IOM uint32_t SM0        : 1;            /*!< SM0                                                                       */
      __IOM uint32_t SM1        : 1;            /*!< SM1                                                                       */
      __IOM uint32_t SM2        : 1;            /*!< SM2                                                                       */
      __IOM uint32_t SM3        : 1;            /*!< SM3                                                                       */
            uint32_t            : 20;
    } bit;
  } IRQ1_INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force for irq1                                                  */
    
    struct {
      __IOM uint32_t SM0_RXNEMPTY : 1;          /*!< SM0_RXNEMPTY                                                              */
      __IOM uint32_t SM1_RXNEMPTY : 1;          /*!< SM1_RXNEMPTY                                                              */
      __IOM uint32_t SM2_RXNEMPTY : 1;          /*!< SM2_RXNEMPTY                                                              */
      __IOM uint32_t SM3_RXNEMPTY : 1;          /*!< SM3_RXNEMPTY                                                              */
      __IOM uint32_t SM0_TXNFULL : 1;           /*!< SM0_TXNFULL                                                               */
      __IOM uint32_t SM1_TXNFULL : 1;           /*!< SM1_TXNFULL                                                               */
      __IOM uint32_t SM2_TXNFULL : 1;           /*!< SM2_TXNFULL                                                               */
      __IOM uint32_t SM3_TXNFULL : 1;           /*!< SM3_TXNFULL                                                               */
      __IOM uint32_t SM0        : 1;            /*!< SM0                                                                       */
      __IOM uint32_t SM1        : 1;            /*!< SM1                                                                       */
      __IOM uint32_t SM2        : 1;            /*!< SM2                                                                       */
      __IOM uint32_t SM3        : 1;            /*!< SM3                                                                       */
            uint32_t            : 20;
    } bit;
  } IRQ1_INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing for irq1                         */
    
    struct {
      __IM  uint32_t SM0_RXNEMPTY : 1;          /*!< SM0_RXNEMPTY                                                              */
      __IM  uint32_t SM1_RXNEMPTY : 1;          /*!< SM1_RXNEMPTY                                                              */
      __IM  uint32_t SM2_RXNEMPTY : 1;          /*!< SM2_RXNEMPTY                                                              */
      __IM  uint32_t SM3_RXNEMPTY : 1;          /*!< SM3_RXNEMPTY                                                              */
      __IM  uint32_t SM0_TXNFULL : 1;           /*!< SM0_TXNFULL                                                               */
      __IM  uint32_t SM1_TXNFULL : 1;           /*!< SM1_TXNFULL                                                               */
      __IM  uint32_t SM2_TXNFULL : 1;           /*!< SM2_TXNFULL                                                               */
      __IM  uint32_t SM3_TXNFULL : 1;           /*!< SM3_TXNFULL                                                               */
      __IM  uint32_t SM0        : 1;            /*!< SM0                                                                       */
      __IM  uint32_t SM1        : 1;            /*!< SM1                                                                       */
      __IM  uint32_t SM2        : 1;            /*!< SM2                                                                       */
      __IM  uint32_t SM3        : 1;            /*!< SM3                                                                       */
            uint32_t            : 20;
    } bit;
  } IRQ1_INTS;
} PIO0_Type;                                    /*!< Size = 324 (0x144)                                                        */



/* =========================================================================================================================== */
/* ================                                          BUSCTRL                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Register block for busfabric control signals and performance counters (BUSCTRL)
  */

typedef struct {                                /*!< BUSCTRL Structure                                                         */
  
  union {
    __IOM uint32_t reg;                         /*!< Set the priority of each master for bus arbitration.                      */
    
    struct {
      __IOM uint32_t PROC0      : 1;            /*!< 0 - low priority, 1 - high priority                                       */
            uint32_t            : 3;
      __IOM uint32_t PROC1      : 1;            /*!< 0 - low priority, 1 - high priority                                       */
            uint32_t            : 3;
      __IOM uint32_t DMA_R      : 1;            /*!< 0 - low priority, 1 - high priority                                       */
            uint32_t            : 3;
      __IOM uint32_t DMA_W      : 1;            /*!< 0 - low priority, 1 - high priority                                       */
            uint32_t            : 19;
    } bit;
  } BUS_PRIORITY;
  
  union {
    __IOM uint32_t reg;                         /*!< Bus priority acknowledge                                                  */
    
    struct {
      __IM  uint32_t BUS_PRIORITY_ACK : 1;      /*!< Goes to 1 once all arbiters have registered the new global priority
                                                     levels. Arbiters update their local priority when servicing
                                                     a new nonsequential access. In normal circumstances this
                                                     will happen almost immediately.                                           */
            uint32_t            : 31;
    } bit;
  } BUS_PRIORITY_ACK;
  
  union {
    __IOM uint32_t reg;                         /*!< Bus fabric performance counter 0                                          */
    
    struct {
      __IOM uint32_t PERFCTR0   : 24;           /*!< Busfabric saturating performance counter 0 Count some event
                                                     signal from the busfabric arbiters. Write any value to
                                                     clear. Select an event to count using PERFSEL0                            */
            uint32_t            : 8;
    } bit;
  } PERFCTR0;
  
  union {
    __IOM uint32_t reg;                         /*!< Bus fabric performance event select for PERFCTR0                          */
    
    struct {
      __IOM uint32_t PERFSEL0   : 5;            /*!< Select an event for PERFCTR0. Count either contested accesses,
                                                     or all accesses, on a downstream port of the main crossbar.               */
            uint32_t            : 27;
    } bit;
  } PERFSEL0;
  
  union {
    __IOM uint32_t reg;                         /*!< Bus fabric performance counter 1                                          */
    
    struct {
      __IOM uint32_t PERFCTR1   : 24;           /*!< Busfabric saturating performance counter 1 Count some event
                                                     signal from the busfabric arbiters. Write any value to
                                                     clear. Select an event to count using PERFSEL1                            */
            uint32_t            : 8;
    } bit;
  } PERFCTR1;
  
  union {
    __IOM uint32_t reg;                         /*!< Bus fabric performance event select for PERFCTR1                          */
    
    struct {
      __IOM uint32_t PERFSEL1   : 5;            /*!< Select an event for PERFCTR1. Count either contested accesses,
                                                     or all accesses, on a downstream port of the main crossbar.               */
            uint32_t            : 27;
    } bit;
  } PERFSEL1;
  
  union {
    __IOM uint32_t reg;                         /*!< Bus fabric performance counter 2                                          */
    
    struct {
      __IOM uint32_t PERFCTR2   : 24;           /*!< Busfabric saturating performance counter 2 Count some event
                                                     signal from the busfabric arbiters. Write any value to
                                                     clear. Select an event to count using PERFSEL2                            */
            uint32_t            : 8;
    } bit;
  } PERFCTR2;
  
  union {
    __IOM uint32_t reg;                         /*!< Bus fabric performance event select for PERFCTR2                          */
    
    struct {
      __IOM uint32_t PERFSEL2   : 5;            /*!< Select an event for PERFCTR2. Count either contested accesses,
                                                     or all accesses, on a downstream port of the main crossbar.               */
            uint32_t            : 27;
    } bit;
  } PERFSEL2;
  
  union {
    __IOM uint32_t reg;                         /*!< Bus fabric performance counter 3                                          */
    
    struct {
      __IOM uint32_t PERFCTR3   : 24;           /*!< Busfabric saturating performance counter 3 Count some event
                                                     signal from the busfabric arbiters. Write any value to
                                                     clear. Select an event to count using PERFSEL3                            */
            uint32_t            : 8;
    } bit;
  } PERFCTR3;
  
  union {
    __IOM uint32_t reg;                         /*!< Bus fabric performance event select for PERFCTR3                          */
    
    struct {
      __IOM uint32_t PERFSEL3   : 5;            /*!< Select an event for PERFCTR3. Count either contested accesses,
                                                     or all accesses, on a downstream port of the main crossbar.               */
            uint32_t            : 27;
    } bit;
  } PERFSEL3;
} BUSCTRL_Type;                                 /*!< Size = 40 (0x28)                                                          */



/* =========================================================================================================================== */
/* ================                                            SIO                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Single-cycle IO block 
            Provides core-local and inter-core hardware for the two processors, with single-cycle access. (SIO)
  */

typedef struct {                                /*!< SIO Structure                                                             */
  
  union {
    __IOM uint32_t reg;                         /*!< Processor core identifier                                                 */
    
    struct {
      __IM  uint32_t CPUID      : 32;           /*!< Value is 0 when read from processor core 0, and 1 when read
                                                     from processor core 1.                                                    */
    } bit;
  } CPUID;
  
  union {
    __IOM uint32_t reg;                         /*!< Input value for GPIO pins                                                 */
    
    struct {
      __IM  uint32_t GPIO_IN    : 30;           /*!< Input value for GPIO0...29                                                */
            uint32_t            : 2;
    } bit;
  } GPIO_IN;
  
  union {
    __IOM uint32_t reg;                         /*!< Input value for QSPI pins                                                 */
    
    struct {
      __IM  uint32_t GPIO_HI_IN : 6;            /*!< Input value on QSPI IO in order 0..5: SCLK, SSn, SD0, SD1, SD2,
                                                     SD3                                                                       */
            uint32_t            : 26;
    } bit;
  } GPIO_HI_IN;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO output value                                                         */
    
    struct {
      __IOM uint32_t GPIO_OUT   : 30;           /*!< Set output level (1/0 -> high/low) for GPIO0...29. Reading back
                                                     gives the last value written, NOT the input value from
                                                     the pins. If core 0 and core 1 both write to GPIO_OUT simultaneously
                                                     (or to a SET/CLR/XOR alias), the result is as though the
                                                     write from core 0 took place first, and the write from
                                                     core 1 was then applied to that intermediate result.                      */
            uint32_t            : 2;
    } bit;
  } GPIO_OUT;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO output value set                                                     */
    
    struct {
      __OM  uint32_t GPIO_OUT_SET : 30;         /*!< Perform an atomic bit-set on GPIO_OUT, i.e. `GPIO_OUT |= wdata`           */
            uint32_t            : 2;
    } bit;
  } GPIO_OUT_SET;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO output value clear                                                   */
    
    struct {
      __OM  uint32_t GPIO_OUT_CLR : 30;         /*!< Perform an atomic bit-clear on GPIO_OUT, i.e. `GPIO_OUT &= ~wdata`        */
            uint32_t            : 2;
    } bit;
  } GPIO_OUT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO output value XOR                                                     */
    
    struct {
      __OM  uint32_t GPIO_OUT_XOR : 30;         /*!< Perform an atomic bitwise XOR on GPIO_OUT, i.e. `GPIO_OUT ^=
                                                     wdata`                                                                    */
            uint32_t            : 2;
    } bit;
  } GPIO_OUT_XOR;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO output enable                                                        */
    
    struct {
      __IOM uint32_t GPIO_OE    : 30;           /*!< Set output enable (1/0 -> output/input) for GPIO0...29. Reading
                                                     back gives the last value written. If core 0 and core 1
                                                     both write to GPIO_OE simultaneously (or to a SET/CLR/XOR
                                                     alias), the result is as though the write from core 0 took
                                                     place first, and the write from core 1 was then applied
                                                     to that intermediate result.                                              */
            uint32_t            : 2;
    } bit;
  } GPIO_OE;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO output enable set                                                    */
    
    struct {
      __OM  uint32_t GPIO_OE_SET : 30;          /*!< Perform an atomic bit-set on GPIO_OE, i.e. `GPIO_OE |= wdata`             */
            uint32_t            : 2;
    } bit;
  } GPIO_OE_SET;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO output enable clear                                                  */
    
    struct {
      __OM  uint32_t GPIO_OE_CLR : 30;          /*!< Perform an atomic bit-clear on GPIO_OE, i.e. `GPIO_OE &= ~wdata`          */
            uint32_t            : 2;
    } bit;
  } GPIO_OE_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO output enable XOR                                                    */
    
    struct {
      __OM  uint32_t GPIO_OE_XOR : 30;          /*!< Perform an atomic bitwise XOR on GPIO_OE, i.e. `GPIO_OE ^= wdata`         */
            uint32_t            : 2;
    } bit;
  } GPIO_OE_XOR;
  
  union {
    __IOM uint32_t reg;                         /*!< QSPI output value                                                         */
    
    struct {
      __IOM uint32_t GPIO_HI_OUT : 6;           /*!< Set output level (1/0 -> high/low) for QSPI IO0...5. Reading
                                                     back gives the last value written, NOT the input value
                                                     from the pins. If core 0 and core 1 both write to GPIO_HI_OUT
                                                     simultaneously (or to a SET/CLR/XOR alias), the result
                                                     is as though the write from core 0 took place first, and
                                                     the write from core 1 was then applied to that intermediate
                                                     result.                                                                   */
            uint32_t            : 26;
    } bit;
  } GPIO_HI_OUT;
  
  union {
    __IOM uint32_t reg;                         /*!< QSPI output value set                                                     */
    
    struct {
      __OM  uint32_t GPIO_HI_OUT_SET : 6;       /*!< Perform an atomic bit-set on GPIO_HI_OUT, i.e. `GPIO_HI_OUT
                                                     |= wdata`                                                                 */
            uint32_t            : 26;
    } bit;
  } GPIO_HI_OUT_SET;
  
  union {
    __IOM uint32_t reg;                         /*!< QSPI output value clear                                                   */
    
    struct {
      __OM  uint32_t GPIO_HI_OUT_CLR : 6;       /*!< Perform an atomic bit-clear on GPIO_HI_OUT, i.e. `GPIO_HI_OUT
                                                     &= ~wdata`                                                                */
            uint32_t            : 26;
    } bit;
  } GPIO_HI_OUT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< QSPI output value XOR                                                     */
    
    struct {
      __OM  uint32_t GPIO_HI_OUT_XOR : 6;       /*!< Perform an atomic bitwise XOR on GPIO_HI_OUT, i.e. `GPIO_HI_OUT
                                                     ^= wdata`                                                                 */
            uint32_t            : 26;
    } bit;
  } GPIO_HI_OUT_XOR;
  
  union {
    __IOM uint32_t reg;                         /*!< QSPI output enable                                                        */
    
    struct {
      __IOM uint32_t GPIO_HI_OE : 6;            /*!< Set output enable (1/0 -> output/input) for QSPI IO0...5. Reading
                                                     back gives the last value written. If core 0 and core 1
                                                     both write to GPIO_HI_OE simultaneously (or to a SET/CLR/XOR
                                                     alias), the result is as though the write from core 0 took
                                                     place first, and the write from core 1 was then applied
                                                     to that intermediate result.                                              */
            uint32_t            : 26;
    } bit;
  } GPIO_HI_OE;
  
  union {
    __IOM uint32_t reg;                         /*!< QSPI output enable set                                                    */
    
    struct {
      __OM  uint32_t GPIO_HI_OE_SET : 6;        /*!< Perform an atomic bit-set on GPIO_HI_OE, i.e. `GPIO_HI_OE |=
                                                     wdata`                                                                    */
            uint32_t            : 26;
    } bit;
  } GPIO_HI_OE_SET;
  
  union {
    __IOM uint32_t reg;                         /*!< QSPI output enable clear                                                  */
    
    struct {
      __OM  uint32_t GPIO_HI_OE_CLR : 6;        /*!< Perform an atomic bit-clear on GPIO_HI_OE, i.e. `GPIO_HI_OE
                                                     &= ~wdata`                                                                */
            uint32_t            : 26;
    } bit;
  } GPIO_HI_OE_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< QSPI output enable XOR                                                    */
    
    struct {
      __OM  uint32_t GPIO_HI_OE_XOR : 6;        /*!< Perform an atomic bitwise XOR on GPIO_HI_OE, i.e. `GPIO_HI_OE
                                                     ^= wdata`                                                                 */
            uint32_t            : 26;
    } bit;
  } GPIO_HI_OE_XOR;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register for inter-core FIFOs (mailboxes). There is one
                                                     FIFO in the core 0 -> core 1 direction, and one core 1
                                                     -> core 0. Both are 32 bits wide and 8 words deep. Core
                                                     0 can see the read side of the 1->0 FIFO (RX), and the
                                                     write side of 0->1 FIFO (TX). Core 1 can see the read side
                                                     of the 0->1 FIFO (RX), and the write side of 1->0 FIFO
                                                     (TX). The SIO IRQ for each core is the logical OR of the
                                                     VLD, WOF and ROE fields of its FIFO_ST register.                          */
    
    struct {
      __IM  uint32_t VLD        : 1;            /*!< Value is 1 if this core's RX FIFO is not empty (i.e. if FIFO_RD
                                                     is valid)                                                                 */
      __IM  uint32_t RDY        : 1;            /*!< Value is 1 if this core's TX FIFO is not full (i.e. if FIFO_WR
                                                     is ready for more data)                                                   */
      __IOM uint32_t WOF        : 1;            /*!< Sticky flag indicating the TX FIFO was written when full. This
                                                     write was ignored by the FIFO.                                            */
      __IOM uint32_t ROE        : 1;            /*!< Sticky flag indicating the RX FIFO was read when empty. This
                                                     read was ignored by the FIFO.                                             */
            uint32_t            : 28;
    } bit;
  } FIFO_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< Write access to this core's TX FIFO                                       */
    
    struct {
      __OM  uint32_t FIFO_WR    : 32;           /*!< FIFO_WR                                                                   */
    } bit;
  } FIFO_WR;
  
  union {
    __IOM uint32_t reg;                         /*!< Read access to this core's RX FIFO                                        */
    
    struct {
      __IM  uint32_t FIFO_RD    : 32;           /*!< FIFO_RD                                                                   */
    } bit;
  } FIFO_RD;
  
  union {
    __IOM uint32_t reg;                         /*!< Spinlock state A bitmap containing the state of all 32 spinlocks
                                                     (1=locked). Mainly intended for debugging.                                */
    
    struct {
      __IM  uint32_t SPINLOCK_ST : 32;          /*!< SPINLOCK_ST                                                               */
    } bit;
  } SPINLOCK_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< Divider unsigned dividend Write to the DIVIDEND operand of the
                                                     divider, i.e. the p in `p / q`. Any operand write starts
                                                     a new calculation. The results appear in QUOTIENT, REMAINDER.
                                                     UDIVIDEND/SDIVIDEND are aliases of the same internal register.
                                                     The U alias starts an unsigned calculation, and the S alias
                                                     starts a signed calculation.                                              */
    
    struct {
      __IOM uint32_t DIV_UDIVIDEND : 32;        /*!< DIV_UDIVIDEND                                                             */
    } bit;
  } DIV_UDIVIDEND;
  
  union {
    __IOM uint32_t reg;                         /*!< Divider unsigned divisor Write to the DIVISOR operand of the
                                                     divider, i.e. the q in `p / q`. Any operand write starts
                                                     a new calculation. The results appear in QUOTIENT, REMAINDER.
                                                     UDIVISOR/SDIVISOR are aliases of the same internal register.
                                                     The U alias starts an unsigned calculation, and the S alias
                                                     starts a signed calculation.                                              */
    
    struct {
      __IOM uint32_t DIV_UDIVISOR : 32;         /*!< DIV_UDIVISOR                                                              */
    } bit;
  } DIV_UDIVISOR;
  
  union {
    __IOM uint32_t reg;                         /*!< Divider signed dividend The same as UDIVIDEND, but starts a
                                                     signed calculation, rather than unsigned.                                 */
    
    struct {
      __IOM uint32_t DIV_SDIVIDEND : 32;        /*!< DIV_SDIVIDEND                                                             */
    } bit;
  } DIV_SDIVIDEND;
  
  union {
    __IOM uint32_t reg;                         /*!< Divider signed divisor The same as UDIVISOR, but starts a signed
                                                     calculation, rather than unsigned.                                        */
    
    struct {
      __IOM uint32_t DIV_SDIVISOR : 32;         /*!< DIV_SDIVISOR                                                              */
    } bit;
  } DIV_SDIVISOR;
  
  union {
    __IOM uint32_t reg;                         /*!< Divider result quotient The result of `DIVIDEND / DIVISOR` (division).
                                                     Contents undefined while CSR_READY is low. For signed calculations,
                                                     QUOTIENT is negative when the signs of DIVIDEND and DIVISOR
                                                     differ. This register can be written to directly, for context
                                                     save/restore purposes. This halts any in-progress calculation
                                                     and sets the CSR_READY and CSR_DIRTY flags. Reading from
                                                     QUOTIENT clears the CSR_DIRTY flag, so should read results
                                                     in the order REMAINDER, QUOTIENT if CSR_DIRTY is used.                    */
    
    struct {
      __IOM uint32_t DIV_QUOTIENT : 32;         /*!< DIV_QUOTIENT                                                              */
    } bit;
  } DIV_QUOTIENT;
  
  union {
    __IOM uint32_t reg;                         /*!< Divider result remainder The result of `DIVIDEND % DIVISOR`
                                                     (modulo). Contents undefined while CSR_READY is low. For
                                                     signed calculations, REMAINDER is negative only when DIVIDEND
                                                     is negative. This register can be written to directly,
                                                     for context save/restore purposes. This halts any in-progress
                                                     calculation and sets the CSR_READY and CSR_DIRTY flags.                   */
    
    struct {
      __IOM uint32_t DIV_REMAINDER : 32;        /*!< DIV_REMAINDER                                                             */
    } bit;
  } DIV_REMAINDER;
  
  union {
    __IOM uint32_t reg;                         /*!< Control and status register for divider.                                  */
    
    struct {
      __IM  uint32_t READY      : 1;            /*!< Reads as 0 when a calculation is in progress, 1 otherwise. Writing
                                                     an operand (xDIVIDEND, xDIVISOR) will immediately start
                                                     a new calculation, no matter if one is already in progress.
                                                     Writing to a result register will immediately terminate
                                                     any in-progress calculation and set the READY and DIRTY
                                                     flags.                                                                    */
      __IM  uint32_t DIRTY      : 1;            /*!< Changes to 1 when any register is written, and back to 0 when
                                                     QUOTIENT is read. Software can use this flag to make save/restore
                                                     more efficient (skip if not DIRTY). If the flag is used
                                                     in this way, it's recommended to either read QUOTIENT only,
                                                     or REMAINDER and then QUOTIENT, to prevent data loss on
                                                     context switch.                                                           */
            uint32_t            : 30;
    } bit;
  } DIV_CSR;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t reg;                         /*!< Read/write access to accumulator 0                                        */
    
    struct {
      __IOM uint32_t INTERP0_ACCUM0 : 32;       /*!< INTERP0_ACCUM0                                                            */
    } bit;
  } INTERP0_ACCUM0;
  
  union {
    __IOM uint32_t reg;                         /*!< Read/write access to accumulator 1                                        */
    
    struct {
      __IOM uint32_t INTERP0_ACCUM1 : 32;       /*!< INTERP0_ACCUM1                                                            */
    } bit;
  } INTERP0_ACCUM1;
  
  union {
    __IOM uint32_t reg;                         /*!< Read/write access to BASE0 register.                                      */
    
    struct {
      __IOM uint32_t INTERP0_BASE0 : 32;        /*!< INTERP0_BASE0                                                             */
    } bit;
  } INTERP0_BASE0;
  
  union {
    __IOM uint32_t reg;                         /*!< Read/write access to BASE1 register.                                      */
    
    struct {
      __IOM uint32_t INTERP0_BASE1 : 32;        /*!< INTERP0_BASE1                                                             */
    } bit;
  } INTERP0_BASE1;
  
  union {
    __IOM uint32_t reg;                         /*!< Read/write access to BASE2 register.                                      */
    
    struct {
      __IOM uint32_t INTERP0_BASE2 : 32;        /*!< INTERP0_BASE2                                                             */
    } bit;
  } INTERP0_BASE2;
  
  union {
    __IOM uint32_t reg;                         /*!< Read LANE0 result, and simultaneously write lane results to
                                                     both accumulators (POP).                                                  */
    
    struct {
      __IM  uint32_t INTERP0_POP_LANE0 : 32;    /*!< INTERP0_POP_LANE0                                                         */
    } bit;
  } INTERP0_POP_LANE0;
  
  union {
    __IOM uint32_t reg;                         /*!< Read LANE1 result, and simultaneously write lane results to
                                                     both accumulators (POP).                                                  */
    
    struct {
      __IM  uint32_t INTERP0_POP_LANE1 : 32;    /*!< INTERP0_POP_LANE1                                                         */
    } bit;
  } INTERP0_POP_LANE1;
  
  union {
    __IOM uint32_t reg;                         /*!< Read FULL result, and simultaneously write lane results to both
                                                     accumulators (POP).                                                       */
    
    struct {
      __IM  uint32_t INTERP0_POP_FULL : 32;     /*!< INTERP0_POP_FULL                                                          */
    } bit;
  } INTERP0_POP_FULL;
  
  union {
    __IOM uint32_t reg;                         /*!< Read LANE0 result, without altering any internal state (PEEK).            */
    
    struct {
      __IM  uint32_t INTERP0_PEEK_LANE0 : 32;   /*!< INTERP0_PEEK_LANE0                                                        */
    } bit;
  } INTERP0_PEEK_LANE0;
  
  union {
    __IOM uint32_t reg;                         /*!< Read LANE1 result, without altering any internal state (PEEK).            */
    
    struct {
      __IM  uint32_t INTERP0_PEEK_LANE1 : 32;   /*!< INTERP0_PEEK_LANE1                                                        */
    } bit;
  } INTERP0_PEEK_LANE1;
  
  union {
    __IOM uint32_t reg;                         /*!< Read FULL result, without altering any internal state (PEEK).             */
    
    struct {
      __IM  uint32_t INTERP0_PEEK_FULL : 32;    /*!< INTERP0_PEEK_FULL                                                         */
    } bit;
  } INTERP0_PEEK_FULL;
  
  union {
    __IOM uint32_t reg;                         /*!< Control register for lane 0                                               */
    
    struct {
      __IOM uint32_t SHIFT      : 5;            /*!< Logical right-shift applied to accumulator before masking                 */
      __IOM uint32_t MASK_LSB   : 5;            /*!< The least-significant bit allowed to pass by the mask (inclusive)         */
      __IOM uint32_t MASK_MSB   : 5;            /*!< The most-significant bit allowed to pass by the mask (inclusive)
                                                     Setting MSB < LSB may cause chip to turn inside-out                       */
      __IOM uint32_t SIGNED     : 1;            /*!< If SIGNED is set, the shifted and masked accumulator value is
                                                     sign-extended to 32 bits before adding to BASE0, and LANE0
                                                     PEEK/POP appear extended to 32 bits when read by processor.               */
      __IOM uint32_t CROSS_INPUT : 1;           /*!< If 1, feed the opposite lane's accumulator into this lane's
                                                     shift + mask hardware. Takes effect even if ADD_RAW is
                                                     set (the CROSS_INPUT mux is before the shift+mask bypass)                 */
      __IOM uint32_t CROSS_RESULT : 1;          /*!< If 1, feed the opposite lane's result into this lane's accumulator
                                                     on POP.                                                                   */
      __IOM uint32_t ADD_RAW    : 1;            /*!< If 1, mask + shift is bypassed for LANE0 result. This does not
                                                     affect FULL result.                                                       */
      __IOM uint32_t FORCE_MSB  : 2;            /*!< ORed into bits 29:28 of the lane result presented to the processor
                                                     on the bus. No effect on the internal 32-bit datapath.
                                                     Handy for using a lane to generate sequence of pointers
                                                     into flash or SRAM.                                                       */
      __IOM uint32_t BLEND      : 1;            /*!< Only present on INTERP0 on each core. If BLEND mode is enabled:
                                                     - LANE1 result is a linear interpolation between BASE0
                                                     and BASE1, controlled by the 8 LSBs of lane 1 shift and
                                                     mask value (a fractional number between 0 and 255/256ths)
                                                     - LANE0 result does not have BASE0 added (yields only the
                                                     8 LSBs of lane 1 shift+mask value) - FULL result does not
                                                     have lane 1 shift+mask value added (BASE2 + lane 0 shift+mask)
                                                     LANE1 SIGNED flag controls whether the interpolation is
                                                     signed or unsigned.                                                       */
            uint32_t            : 1;
      __IM  uint32_t OVERF0     : 1;            /*!< Indicates if any masked-off MSBs in ACCUM0 are set.                       */
      __IM  uint32_t OVERF1     : 1;            /*!< Indicates if any masked-off MSBs in ACCUM1 are set.                       */
      __IM  uint32_t OVERF      : 1;            /*!< Set if either OVERF0 or OVERF1 is set.                                    */
            uint32_t            : 6;
    } bit;
  } INTERP0_CTRL_LANE0;
  
  union {
    __IOM uint32_t reg;                         /*!< Control register for lane 1                                               */
    
    struct {
      __IOM uint32_t SHIFT      : 5;            /*!< Logical right-shift applied to accumulator before masking                 */
      __IOM uint32_t MASK_LSB   : 5;            /*!< The least-significant bit allowed to pass by the mask (inclusive)         */
      __IOM uint32_t MASK_MSB   : 5;            /*!< The most-significant bit allowed to pass by the mask (inclusive)
                                                     Setting MSB < LSB may cause chip to turn inside-out                       */
      __IOM uint32_t SIGNED     : 1;            /*!< If SIGNED is set, the shifted and masked accumulator value is
                                                     sign-extended to 32 bits before adding to BASE1, and LANE1
                                                     PEEK/POP appear extended to 32 bits when read by processor.               */
      __IOM uint32_t CROSS_INPUT : 1;           /*!< If 1, feed the opposite lane's accumulator into this lane's
                                                     shift + mask hardware. Takes effect even if ADD_RAW is
                                                     set (the CROSS_INPUT mux is before the shift+mask bypass)                 */
      __IOM uint32_t CROSS_RESULT : 1;          /*!< If 1, feed the opposite lane's result into this lane's accumulator
                                                     on POP.                                                                   */
      __IOM uint32_t ADD_RAW    : 1;            /*!< If 1, mask + shift is bypassed for LANE1 result. This does not
                                                     affect FULL result.                                                       */
      __IOM uint32_t FORCE_MSB  : 2;            /*!< ORed into bits 29:28 of the lane result presented to the processor
                                                     on the bus. No effect on the internal 32-bit datapath.
                                                     Handy for using a lane to generate sequence of pointers
                                                     into flash or SRAM.                                                       */
            uint32_t            : 11;
    } bit;
  } INTERP0_CTRL_LANE1;
  
  union {
    __IOM uint32_t reg;                         /*!< Values written here are atomically added to ACCUM0 Reading yields
                                                     lane 0's raw shift and mask value (BASE0 not added).                      */
    
    struct {
      __IOM uint32_t INTERP0_ACCUM0_ADD : 24;   /*!< INTERP0_ACCUM0_ADD                                                        */
            uint32_t            : 8;
    } bit;
  } INTERP0_ACCUM0_ADD;
  
  union {
    __IOM uint32_t reg;                         /*!< Values written here are atomically added to ACCUM1 Reading yields
                                                     lane 1's raw shift and mask value (BASE1 not added).                      */
    
    struct {
      __IOM uint32_t INTERP0_ACCUM1_ADD : 24;   /*!< INTERP0_ACCUM1_ADD                                                        */
            uint32_t            : 8;
    } bit;
  } INTERP0_ACCUM1_ADD;
  
  union {
    __IOM uint32_t reg;                         /*!< On write, the lower 16 bits go to BASE0, upper bits to BASE1
                                                     simultaneously. Each half is sign-extended to 32 bits if
                                                     that lane's SIGNED flag is set.                                           */
    
    struct {
      __OM  uint32_t INTERP0_BASE_1AND0 : 32;   /*!< INTERP0_BASE_1AND0                                                        */
    } bit;
  } INTERP0_BASE_1AND0;
  
  union {
    __IOM uint32_t reg;                         /*!< Read/write access to accumulator 0                                        */
    
    struct {
      __IOM uint32_t INTERP1_ACCUM0 : 32;       /*!< INTERP1_ACCUM0                                                            */
    } bit;
  } INTERP1_ACCUM0;
  
  union {
    __IOM uint32_t reg;                         /*!< Read/write access to accumulator 1                                        */
    
    struct {
      __IOM uint32_t INTERP1_ACCUM1 : 32;       /*!< INTERP1_ACCUM1                                                            */
    } bit;
  } INTERP1_ACCUM1;
  
  union {
    __IOM uint32_t reg;                         /*!< Read/write access to BASE0 register.                                      */
    
    struct {
      __IOM uint32_t INTERP1_BASE0 : 32;        /*!< INTERP1_BASE0                                                             */
    } bit;
  } INTERP1_BASE0;
  
  union {
    __IOM uint32_t reg;                         /*!< Read/write access to BASE1 register.                                      */
    
    struct {
      __IOM uint32_t INTERP1_BASE1 : 32;        /*!< INTERP1_BASE1                                                             */
    } bit;
  } INTERP1_BASE1;
  
  union {
    __IOM uint32_t reg;                         /*!< Read/write access to BASE2 register.                                      */
    
    struct {
      __IOM uint32_t INTERP1_BASE2 : 32;        /*!< INTERP1_BASE2                                                             */
    } bit;
  } INTERP1_BASE2;
  
  union {
    __IOM uint32_t reg;                         /*!< Read LANE0 result, and simultaneously write lane results to
                                                     both accumulators (POP).                                                  */
    
    struct {
      __IM  uint32_t INTERP1_POP_LANE0 : 32;    /*!< INTERP1_POP_LANE0                                                         */
    } bit;
  } INTERP1_POP_LANE0;
  
  union {
    __IOM uint32_t reg;                         /*!< Read LANE1 result, and simultaneously write lane results to
                                                     both accumulators (POP).                                                  */
    
    struct {
      __IM  uint32_t INTERP1_POP_LANE1 : 32;    /*!< INTERP1_POP_LANE1                                                         */
    } bit;
  } INTERP1_POP_LANE1;
  
  union {
    __IOM uint32_t reg;                         /*!< Read FULL result, and simultaneously write lane results to both
                                                     accumulators (POP).                                                       */
    
    struct {
      __IM  uint32_t INTERP1_POP_FULL : 32;     /*!< INTERP1_POP_FULL                                                          */
    } bit;
  } INTERP1_POP_FULL;
  
  union {
    __IOM uint32_t reg;                         /*!< Read LANE0 result, without altering any internal state (PEEK).            */
    
    struct {
      __IM  uint32_t INTERP1_PEEK_LANE0 : 32;   /*!< INTERP1_PEEK_LANE0                                                        */
    } bit;
  } INTERP1_PEEK_LANE0;
  
  union {
    __IOM uint32_t reg;                         /*!< Read LANE1 result, without altering any internal state (PEEK).            */
    
    struct {
      __IM  uint32_t INTERP1_PEEK_LANE1 : 32;   /*!< INTERP1_PEEK_LANE1                                                        */
    } bit;
  } INTERP1_PEEK_LANE1;
  
  union {
    __IOM uint32_t reg;                         /*!< Read FULL result, without altering any internal state (PEEK).             */
    
    struct {
      __IM  uint32_t INTERP1_PEEK_FULL : 32;    /*!< INTERP1_PEEK_FULL                                                         */
    } bit;
  } INTERP1_PEEK_FULL;
  
  union {
    __IOM uint32_t reg;                         /*!< Control register for lane 0                                               */
    
    struct {
      __IOM uint32_t SHIFT      : 5;            /*!< Logical right-shift applied to accumulator before masking                 */
      __IOM uint32_t MASK_LSB   : 5;            /*!< The least-significant bit allowed to pass by the mask (inclusive)         */
      __IOM uint32_t MASK_MSB   : 5;            /*!< The most-significant bit allowed to pass by the mask (inclusive)
                                                     Setting MSB < LSB may cause chip to turn inside-out                       */
      __IOM uint32_t SIGNED     : 1;            /*!< If SIGNED is set, the shifted and masked accumulator value is
                                                     sign-extended to 32 bits before adding to BASE0, and LANE0
                                                     PEEK/POP appear extended to 32 bits when read by processor.               */
      __IOM uint32_t CROSS_INPUT : 1;           /*!< If 1, feed the opposite lane's accumulator into this lane's
                                                     shift + mask hardware. Takes effect even if ADD_RAW is
                                                     set (the CROSS_INPUT mux is before the shift+mask bypass)                 */
      __IOM uint32_t CROSS_RESULT : 1;          /*!< If 1, feed the opposite lane's result into this lane's accumulator
                                                     on POP.                                                                   */
      __IOM uint32_t ADD_RAW    : 1;            /*!< If 1, mask + shift is bypassed for LANE0 result. This does not
                                                     affect FULL result.                                                       */
      __IOM uint32_t FORCE_MSB  : 2;            /*!< ORed into bits 29:28 of the lane result presented to the processor
                                                     on the bus. No effect on the internal 32-bit datapath.
                                                     Handy for using a lane to generate sequence of pointers
                                                     into flash or SRAM.                                                       */
            uint32_t            : 1;
      __IOM uint32_t CLAMP      : 1;            /*!< Only present on INTERP1 on each core. If CLAMP mode is enabled:
                                                     - LANE0 result is shifted and masked ACCUM0, clamped by
                                                     a lower bound of BASE0 and an upper bound of BASE1. - Signedness
                                                     of these comparisons is determined by LANE0_CTRL_SIGNED                   */
      __IM  uint32_t OVERF0     : 1;            /*!< Indicates if any masked-off MSBs in ACCUM0 are set.                       */
      __IM  uint32_t OVERF1     : 1;            /*!< Indicates if any masked-off MSBs in ACCUM1 are set.                       */
      __IM  uint32_t OVERF      : 1;            /*!< Set if either OVERF0 or OVERF1 is set.                                    */
            uint32_t            : 6;
    } bit;
  } INTERP1_CTRL_LANE0;
  
  union {
    __IOM uint32_t reg;                         /*!< Control register for lane 1                                               */
    
    struct {
      __IOM uint32_t SHIFT      : 5;            /*!< Logical right-shift applied to accumulator before masking                 */
      __IOM uint32_t MASK_LSB   : 5;            /*!< The least-significant bit allowed to pass by the mask (inclusive)         */
      __IOM uint32_t MASK_MSB   : 5;            /*!< The most-significant bit allowed to pass by the mask (inclusive)
                                                     Setting MSB < LSB may cause chip to turn inside-out                       */
      __IOM uint32_t SIGNED     : 1;            /*!< If SIGNED is set, the shifted and masked accumulator value is
                                                     sign-extended to 32 bits before adding to BASE1, and LANE1
                                                     PEEK/POP appear extended to 32 bits when read by processor.               */
      __IOM uint32_t CROSS_INPUT : 1;           /*!< If 1, feed the opposite lane's accumulator into this lane's
                                                     shift + mask hardware. Takes effect even if ADD_RAW is
                                                     set (the CROSS_INPUT mux is before the shift+mask bypass)                 */
      __IOM uint32_t CROSS_RESULT : 1;          /*!< If 1, feed the opposite lane's result into this lane's accumulator
                                                     on POP.                                                                   */
      __IOM uint32_t ADD_RAW    : 1;            /*!< If 1, mask + shift is bypassed for LANE1 result. This does not
                                                     affect FULL result.                                                       */
      __IOM uint32_t FORCE_MSB  : 2;            /*!< ORed into bits 29:28 of the lane result presented to the processor
                                                     on the bus. No effect on the internal 32-bit datapath.
                                                     Handy for using a lane to generate sequence of pointers
                                                     into flash or SRAM.                                                       */
            uint32_t            : 11;
    } bit;
  } INTERP1_CTRL_LANE1;
  
  union {
    __IOM uint32_t reg;                         /*!< Values written here are atomically added to ACCUM0 Reading yields
                                                     lane 0's raw shift and mask value (BASE0 not added).                      */
    
    struct {
      __IOM uint32_t INTERP1_ACCUM0_ADD : 24;   /*!< INTERP1_ACCUM0_ADD                                                        */
            uint32_t            : 8;
    } bit;
  } INTERP1_ACCUM0_ADD;
  
  union {
    __IOM uint32_t reg;                         /*!< Values written here are atomically added to ACCUM1 Reading yields
                                                     lane 1's raw shift and mask value (BASE1 not added).                      */
    
    struct {
      __IOM uint32_t INTERP1_ACCUM1_ADD : 24;   /*!< INTERP1_ACCUM1_ADD                                                        */
            uint32_t            : 8;
    } bit;
  } INTERP1_ACCUM1_ADD;
  
  union {
    __IOM uint32_t reg;                         /*!< On write, the lower 16 bits go to BASE0, upper bits to BASE1
                                                     simultaneously. Each half is sign-extended to 32 bits if
                                                     that lane's SIGNED flag is set.                                           */
    
    struct {
      __OM  uint32_t INTERP1_BASE_1AND0 : 32;   /*!< INTERP1_BASE_1AND0                                                        */
    } bit;
  } INTERP1_BASE_1AND0;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK0  : 32;           /*!< SPINLOCK0                                                                 */
    } bit;
  } SPINLOCK0;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK1  : 32;           /*!< SPINLOCK1                                                                 */
    } bit;
  } SPINLOCK1;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK2  : 32;           /*!< SPINLOCK2                                                                 */
    } bit;
  } SPINLOCK2;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK3  : 32;           /*!< SPINLOCK3                                                                 */
    } bit;
  } SPINLOCK3;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK4  : 32;           /*!< SPINLOCK4                                                                 */
    } bit;
  } SPINLOCK4;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK5  : 32;           /*!< SPINLOCK5                                                                 */
    } bit;
  } SPINLOCK5;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK6  : 32;           /*!< SPINLOCK6                                                                 */
    } bit;
  } SPINLOCK6;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK7  : 32;           /*!< SPINLOCK7                                                                 */
    } bit;
  } SPINLOCK7;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK8  : 32;           /*!< SPINLOCK8                                                                 */
    } bit;
  } SPINLOCK8;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK9  : 32;           /*!< SPINLOCK9                                                                 */
    } bit;
  } SPINLOCK9;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK10 : 32;           /*!< SPINLOCK10                                                                */
    } bit;
  } SPINLOCK10;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK11 : 32;           /*!< SPINLOCK11                                                                */
    } bit;
  } SPINLOCK11;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK12 : 32;           /*!< SPINLOCK12                                                                */
    } bit;
  } SPINLOCK12;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK13 : 32;           /*!< SPINLOCK13                                                                */
    } bit;
  } SPINLOCK13;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK14 : 32;           /*!< SPINLOCK14                                                                */
    } bit;
  } SPINLOCK14;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK15 : 32;           /*!< SPINLOCK15                                                                */
    } bit;
  } SPINLOCK15;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK16 : 32;           /*!< SPINLOCK16                                                                */
    } bit;
  } SPINLOCK16;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK17 : 32;           /*!< SPINLOCK17                                                                */
    } bit;
  } SPINLOCK17;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK18 : 32;           /*!< SPINLOCK18                                                                */
    } bit;
  } SPINLOCK18;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK19 : 32;           /*!< SPINLOCK19                                                                */
    } bit;
  } SPINLOCK19;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK20 : 32;           /*!< SPINLOCK20                                                                */
    } bit;
  } SPINLOCK20;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK21 : 32;           /*!< SPINLOCK21                                                                */
    } bit;
  } SPINLOCK21;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK22 : 32;           /*!< SPINLOCK22                                                                */
    } bit;
  } SPINLOCK22;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK23 : 32;           /*!< SPINLOCK23                                                                */
    } bit;
  } SPINLOCK23;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK24 : 32;           /*!< SPINLOCK24                                                                */
    } bit;
  } SPINLOCK24;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK25 : 32;           /*!< SPINLOCK25                                                                */
    } bit;
  } SPINLOCK25;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK26 : 32;           /*!< SPINLOCK26                                                                */
    } bit;
  } SPINLOCK26;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK27 : 32;           /*!< SPINLOCK27                                                                */
    } bit;
  } SPINLOCK27;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK28 : 32;           /*!< SPINLOCK28                                                                */
    } bit;
  } SPINLOCK28;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK29 : 32;           /*!< SPINLOCK29                                                                */
    } bit;
  } SPINLOCK29;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK30 : 32;           /*!< SPINLOCK30                                                                */
    } bit;
  } SPINLOCK30;
  
  union {
    __IOM uint32_t reg;                         /*!< Reading from a spinlock address will: - Return 0 if lock is
                                                     already locked - Otherwise return nonzero, and simultaneously
                                                     claim the lock Writing (any value) releases the lock. If
                                                     core 0 and core 1 attempt to claim the same lock simultaneously,
                                                     core 0 wins. The value returned on success is 0x1 << lock
                                                     number.                                                                   */
    
    struct {
      __IOM uint32_t SPINLOCK31 : 32;           /*!< SPINLOCK31                                                                */
    } bit;
  } SPINLOCK31;
} SIO_Type;                                     /*!< Size = 384 (0x180)                                                        */



/* =========================================================================================================================== */
/* ================                                            USB                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief USB FS/LS controller device registers (USB)
  */

typedef struct {                                /*!< USB Structure                                                             */
  
  union {
    __IOM uint32_t reg;                         /*!< Device address and endpoint control                                       */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< In device mode, the address that the device should respond to.
                                                     Set in response to a SET_ADDR setup packet from the host.
                                                     In host mode set to the address of the device to communicate
                                                     with.                                                                     */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< Device endpoint to send data to. Only valid for HOST mode.                */
            uint32_t            : 12;
    } bit;
  } ADDR_ENDP;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt endpoint 1. Only valid for HOST mode.                           */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< Device address                                                            */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< Endpoint number of the interrupt endpoint                                 */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< Direction of the interrupt endpoint. In=0, Out=1                          */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< Interrupt EP requires preamble (is a low speed device on a full
                                                     speed hub)                                                                */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP1;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt endpoint 2. Only valid for HOST mode.                           */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< Device address                                                            */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< Endpoint number of the interrupt endpoint                                 */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< Direction of the interrupt endpoint. In=0, Out=1                          */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< Interrupt EP requires preamble (is a low speed device on a full
                                                     speed hub)                                                                */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP2;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt endpoint 3. Only valid for HOST mode.                           */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< Device address                                                            */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< Endpoint number of the interrupt endpoint                                 */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< Direction of the interrupt endpoint. In=0, Out=1                          */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< Interrupt EP requires preamble (is a low speed device on a full
                                                     speed hub)                                                                */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP3;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt endpoint 4. Only valid for HOST mode.                           */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< Device address                                                            */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< Endpoint number of the interrupt endpoint                                 */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< Direction of the interrupt endpoint. In=0, Out=1                          */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< Interrupt EP requires preamble (is a low speed device on a full
                                                     speed hub)                                                                */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP4;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt endpoint 5. Only valid for HOST mode.                           */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< Device address                                                            */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< Endpoint number of the interrupt endpoint                                 */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< Direction of the interrupt endpoint. In=0, Out=1                          */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< Interrupt EP requires preamble (is a low speed device on a full
                                                     speed hub)                                                                */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP5;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt endpoint 6. Only valid for HOST mode.                           */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< Device address                                                            */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< Endpoint number of the interrupt endpoint                                 */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< Direction of the interrupt endpoint. In=0, Out=1                          */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< Interrupt EP requires preamble (is a low speed device on a full
                                                     speed hub)                                                                */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP6;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt endpoint 7. Only valid for HOST mode.                           */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< Device address                                                            */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< Endpoint number of the interrupt endpoint                                 */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< Direction of the interrupt endpoint. In=0, Out=1                          */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< Interrupt EP requires preamble (is a low speed device on a full
                                                     speed hub)                                                                */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP7;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt endpoint 8. Only valid for HOST mode.                           */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< Device address                                                            */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< Endpoint number of the interrupt endpoint                                 */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< Direction of the interrupt endpoint. In=0, Out=1                          */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< Interrupt EP requires preamble (is a low speed device on a full
                                                     speed hub)                                                                */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP8;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt endpoint 9. Only valid for HOST mode.                           */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< Device address                                                            */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< Endpoint number of the interrupt endpoint                                 */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< Direction of the interrupt endpoint. In=0, Out=1                          */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< Interrupt EP requires preamble (is a low speed device on a full
                                                     speed hub)                                                                */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP9;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt endpoint 10. Only valid for HOST mode.                          */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< Device address                                                            */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< Endpoint number of the interrupt endpoint                                 */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< Direction of the interrupt endpoint. In=0, Out=1                          */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< Interrupt EP requires preamble (is a low speed device on a full
                                                     speed hub)                                                                */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP10;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt endpoint 11. Only valid for HOST mode.                          */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< Device address                                                            */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< Endpoint number of the interrupt endpoint                                 */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< Direction of the interrupt endpoint. In=0, Out=1                          */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< Interrupt EP requires preamble (is a low speed device on a full
                                                     speed hub)                                                                */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP11;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt endpoint 12. Only valid for HOST mode.                          */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< Device address                                                            */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< Endpoint number of the interrupt endpoint                                 */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< Direction of the interrupt endpoint. In=0, Out=1                          */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< Interrupt EP requires preamble (is a low speed device on a full
                                                     speed hub)                                                                */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP12;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt endpoint 13. Only valid for HOST mode.                          */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< Device address                                                            */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< Endpoint number of the interrupt endpoint                                 */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< Direction of the interrupt endpoint. In=0, Out=1                          */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< Interrupt EP requires preamble (is a low speed device on a full
                                                     speed hub)                                                                */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP13;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt endpoint 14. Only valid for HOST mode.                          */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< Device address                                                            */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< Endpoint number of the interrupt endpoint                                 */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< Direction of the interrupt endpoint. In=0, Out=1                          */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< Interrupt EP requires preamble (is a low speed device on a full
                                                     speed hub)                                                                */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP14;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt endpoint 15. Only valid for HOST mode.                          */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< Device address                                                            */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< Endpoint number of the interrupt endpoint                                 */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< Direction of the interrupt endpoint. In=0, Out=1                          */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< Interrupt EP requires preamble (is a low speed device on a full
                                                     speed hub)                                                                */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP15;
  
  union {
    __IOM uint32_t reg;                         /*!< Main control register                                                     */
    
    struct {
      __IOM uint32_t CONTROLLER_EN : 1;         /*!< Enable controller                                                         */
      __IOM uint32_t HOST_NDEVICE : 1;          /*!< Device mode = 0, Host mode = 1                                            */
            uint32_t            : 29;
      __IOM uint32_t SIM_TIMING : 1;            /*!< Reduced timings for simulation                                            */
    } bit;
  } MAIN_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Set the SOF (Start of Frame) frame number in the host controller.
                                                     The SOF packet is sent every 1ms and the host will increment
                                                     the frame number by 1 each time.                                          */
    
    struct {
      __OM  uint32_t COUNT      : 11;           /*!< COUNT                                                                     */
            uint32_t            : 21;
    } bit;
  } SOF_WR;
  
  union {
    __IOM uint32_t reg;                         /*!< Read the last SOF (Start of Frame) frame number seen. In device
                                                     mode the last SOF received from the host. In host mode
                                                     the last SOF sent by the host.                                            */
    
    struct {
      __IM  uint32_t COUNT      : 11;           /*!< COUNT                                                                     */
            uint32_t            : 21;
    } bit;
  } SOF_RD;
  
  union {
    __IOM uint32_t reg;                         /*!< SIE control register                                                      */
    
    struct {
      __OM  uint32_t START_TRANS : 1;           /*!< Host: Start transaction                                                   */
      __IOM uint32_t SEND_SETUP : 1;            /*!< Host: Send Setup packet                                                   */
      __IOM uint32_t SEND_DATA  : 1;            /*!< Host: Send transaction (OUT from host)                                    */
      __IOM uint32_t RECEIVE_DATA : 1;          /*!< Host: Receive transaction (IN to host)                                    */
      __OM  uint32_t STOP_TRANS : 1;            /*!< Host: Stop transaction                                                    */
            uint32_t            : 1;
      __IOM uint32_t PREAMBLE_EN : 1;           /*!< Host: Preable enable for LS device on FS hub                              */
            uint32_t            : 1;
      __IOM uint32_t SOF_SYNC   : 1;            /*!< Host: Delay packet(s) until after SOF                                     */
      __IOM uint32_t SOF_EN     : 1;            /*!< Host: Enable SOF generation (for full speed bus)                          */
      __IOM uint32_t KEEP_ALIVE_EN : 1;         /*!< Host: Enable keep alive packet (for low speed bus)                        */
      __IOM uint32_t VBUS_EN    : 1;            /*!< Host: Enable VBUS                                                         */
      __OM  uint32_t RESUME     : 1;            /*!< Device: Remote wakeup. Device can initiate its own resume after
                                                     suspend.                                                                  */
      __OM  uint32_t RESET_BUS  : 1;            /*!< Host: Reset bus                                                           */
            uint32_t            : 1;
      __IOM uint32_t PULLDOWN_EN : 1;           /*!< Host: Enable pull down resistors                                          */
      __IOM uint32_t PULLUP_EN  : 1;            /*!< Device: Enable pull up resistor                                           */
      __IOM uint32_t RPU_OPT    : 1;            /*!< Device: Pull-up strength (0=1K2, 1=2k3)                                   */
      __IOM uint32_t TRANSCEIVER_PD : 1;        /*!< Power down bus transceiver                                                */
            uint32_t            : 5;
      __IOM uint32_t DIRECT_DM  : 1;            /*!< Direct control of DM                                                      */
      __IOM uint32_t DIRECT_DP  : 1;            /*!< Direct control of DP                                                      */
      __IOM uint32_t DIRECT_EN  : 1;            /*!< Direct bus drive enable                                                   */
      __IOM uint32_t EP0_INT_NAK : 1;           /*!< Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a NAK               */
      __IOM uint32_t EP0_INT_2BUF : 1;          /*!< Device: Set bit in BUFF_STATUS for every 2 buffers completed
                                                     on EP0                                                                    */
      __IOM uint32_t EP0_INT_1BUF : 1;          /*!< Device: Set bit in BUFF_STATUS for every buffer completed on
                                                     EP0                                                                       */
      __IOM uint32_t EP0_DOUBLE_BUF : 1;        /*!< Device: EP0 single buffered = 0, double buffered = 1                      */
      __IOM uint32_t EP0_INT_STALL : 1;         /*!< Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a STALL             */
    } bit;
  } SIE_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< SIE status register                                                       */
    
    struct {
      __IM  uint32_t VBUS_DETECTED : 1;         /*!< Device: VBUS Detected                                                     */
            uint32_t            : 1;
      __IM  uint32_t LINE_STATE : 2;            /*!< USB bus line state                                                        */
      __IM  uint32_t SUSPENDED  : 1;            /*!< Bus in suspended state. Valid for device and host. Host and
                                                     device will go into suspend if neither Keep Alive / SOF
                                                     frames are enabled.                                                       */
            uint32_t            : 3;
      __IM  uint32_t SPEED      : 2;            /*!< Host: device speed. Disconnected = 00, LS = 01, FS = 10                   */
      __IM  uint32_t VBUS_OVER_CURR : 1;        /*!< VBUS over current detected                                                */
      __IOM uint32_t RESUME     : 1;            /*!< Host: Device has initiated a remote resume. Device: host has
                                                     initiated a resume.                                                       */
            uint32_t            : 4;
      __IM  uint32_t CONNECTED  : 1;            /*!< Device: connected                                                         */
      __IOM uint32_t SETUP_REC  : 1;            /*!< Device: Setup packet received                                             */
      __IOM uint32_t TRANS_COMPLETE : 1;        /*!< Transaction complete. Raised by device if: * An IN or OUT packet
                                                     is sent with the `LAST_BUFF` bit set in the buffer control
                                                     register Raised by host if: * A setup packet is sent when
                                                     no data in or data out transaction follows * An IN packet
                                                     is received and the `LAST_BUFF` bit is set in the buffer
                                                     control register * An IN packet is received with zero length
                                                     * An OUT packet is sent and the `LAST_BUFF` bit is set                    */
      __IOM uint32_t BUS_RESET  : 1;            /*!< Device: bus reset received                                                */
            uint32_t            : 4;
      __IOM uint32_t CRC_ERROR  : 1;            /*!< CRC Error. Raised by the Serial RX engine.                                */
      __IOM uint32_t BIT_STUFF_ERROR : 1;       /*!< Bit Stuff Error. Raised by the Serial RX engine.                          */
      __IOM uint32_t RX_OVERFLOW : 1;           /*!< RX overflow is raised by the Serial RX engine if the incoming
                                                     data is too fast.                                                         */
      __IOM uint32_t RX_TIMEOUT : 1;            /*!< RX timeout is raised by both the host and device if an ACK is
                                                     not received in the maximum time specified by the USB spec.               */
      __IOM uint32_t NAK_REC    : 1;            /*!< Host: NAK received                                                        */
      __IOM uint32_t STALL_REC  : 1;            /*!< Host: STALL received                                                      */
      __IOM uint32_t ACK_REC    : 1;            /*!< ACK received. Raised by both host and device.                             */
      __IOM uint32_t DATA_SEQ_ERROR : 1;        /*!< Data Sequence Error. The device can raise a sequence error in
                                                     the following conditions: * A SETUP packet is received
                                                     followed by a DATA1 packet (data phase should always be
                                                     DATA0) * An OUT packet is received from the host but doesn't
                                                     match the data pid in the buffer control register read
                                                     from DPSRAM The host can raise a data sequence error in
                                                     the following conditions: * An IN packet from the device
                                                     has the wrong data PID                                                    */
    } bit;
  } SIE_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< interrupt endpoint control register                                       */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t INT_EP_ACTIVE : 15;        /*!< Host: Enable interrupt endpoint 1 => 15                                   */
            uint32_t            : 16;
    } bit;
  } INT_EP_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer status register. A bit set here indicates that a buffer
                                                     has completed on the endpoint (if the buffer interrupt
                                                     is enabled). It is possible for 2 buffers to be completed,
                                                     so clearing the buffer status bit may instantly re set
                                                     it on the next clock cycle.                                               */
    
    struct {
      __IOM uint32_t EP0_IN     : 1;            /*!< EP0_IN                                                                    */
      __IOM uint32_t EP0_OUT    : 1;            /*!< EP0_OUT                                                                   */
      __IOM uint32_t EP1_IN     : 1;            /*!< EP1_IN                                                                    */
      __IOM uint32_t EP1_OUT    : 1;            /*!< EP1_OUT                                                                   */
      __IOM uint32_t EP2_IN     : 1;            /*!< EP2_IN                                                                    */
      __IOM uint32_t EP2_OUT    : 1;            /*!< EP2_OUT                                                                   */
      __IOM uint32_t EP3_IN     : 1;            /*!< EP3_IN                                                                    */
      __IOM uint32_t EP3_OUT    : 1;            /*!< EP3_OUT                                                                   */
      __IOM uint32_t EP4_IN     : 1;            /*!< EP4_IN                                                                    */
      __IOM uint32_t EP4_OUT    : 1;            /*!< EP4_OUT                                                                   */
      __IOM uint32_t EP5_IN     : 1;            /*!< EP5_IN                                                                    */
      __IOM uint32_t EP5_OUT    : 1;            /*!< EP5_OUT                                                                   */
      __IOM uint32_t EP6_IN     : 1;            /*!< EP6_IN                                                                    */
      __IOM uint32_t EP6_OUT    : 1;            /*!< EP6_OUT                                                                   */
      __IOM uint32_t EP7_IN     : 1;            /*!< EP7_IN                                                                    */
      __IOM uint32_t EP7_OUT    : 1;            /*!< EP7_OUT                                                                   */
      __IOM uint32_t EP8_IN     : 1;            /*!< EP8_IN                                                                    */
      __IOM uint32_t EP8_OUT    : 1;            /*!< EP8_OUT                                                                   */
      __IOM uint32_t EP9_IN     : 1;            /*!< EP9_IN                                                                    */
      __IOM uint32_t EP9_OUT    : 1;            /*!< EP9_OUT                                                                   */
      __IOM uint32_t EP10_IN    : 1;            /*!< EP10_IN                                                                   */
      __IOM uint32_t EP10_OUT   : 1;            /*!< EP10_OUT                                                                  */
      __IOM uint32_t EP11_IN    : 1;            /*!< EP11_IN                                                                   */
      __IOM uint32_t EP11_OUT   : 1;            /*!< EP11_OUT                                                                  */
      __IOM uint32_t EP12_IN    : 1;            /*!< EP12_IN                                                                   */
      __IOM uint32_t EP12_OUT   : 1;            /*!< EP12_OUT                                                                  */
      __IOM uint32_t EP13_IN    : 1;            /*!< EP13_IN                                                                   */
      __IOM uint32_t EP13_OUT   : 1;            /*!< EP13_OUT                                                                  */
      __IOM uint32_t EP14_IN    : 1;            /*!< EP14_IN                                                                   */
      __IOM uint32_t EP14_OUT   : 1;            /*!< EP14_OUT                                                                  */
      __IOM uint32_t EP15_IN    : 1;            /*!< EP15_IN                                                                   */
      __IOM uint32_t EP15_OUT   : 1;            /*!< EP15_OUT                                                                  */
    } bit;
  } BUFF_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< Which of the double buffers should be handled. Only valid if
                                                     using an interrupt per buffer (i.e. not per 2 buffers).
                                                     Not valid for host interrupt endpoint polling because they
                                                     are only single buffered.                                                 */
    
    struct {
      __IM  uint32_t EP0_IN     : 1;            /*!< EP0_IN                                                                    */
      __IM  uint32_t EP0_OUT    : 1;            /*!< EP0_OUT                                                                   */
      __IM  uint32_t EP1_IN     : 1;            /*!< EP1_IN                                                                    */
      __IM  uint32_t EP1_OUT    : 1;            /*!< EP1_OUT                                                                   */
      __IM  uint32_t EP2_IN     : 1;            /*!< EP2_IN                                                                    */
      __IM  uint32_t EP2_OUT    : 1;            /*!< EP2_OUT                                                                   */
      __IM  uint32_t EP3_IN     : 1;            /*!< EP3_IN                                                                    */
      __IM  uint32_t EP3_OUT    : 1;            /*!< EP3_OUT                                                                   */
      __IM  uint32_t EP4_IN     : 1;            /*!< EP4_IN                                                                    */
      __IM  uint32_t EP4_OUT    : 1;            /*!< EP4_OUT                                                                   */
      __IM  uint32_t EP5_IN     : 1;            /*!< EP5_IN                                                                    */
      __IM  uint32_t EP5_OUT    : 1;            /*!< EP5_OUT                                                                   */
      __IM  uint32_t EP6_IN     : 1;            /*!< EP6_IN                                                                    */
      __IM  uint32_t EP6_OUT    : 1;            /*!< EP6_OUT                                                                   */
      __IM  uint32_t EP7_IN     : 1;            /*!< EP7_IN                                                                    */
      __IM  uint32_t EP7_OUT    : 1;            /*!< EP7_OUT                                                                   */
      __IM  uint32_t EP8_IN     : 1;            /*!< EP8_IN                                                                    */
      __IM  uint32_t EP8_OUT    : 1;            /*!< EP8_OUT                                                                   */
      __IM  uint32_t EP9_IN     : 1;            /*!< EP9_IN                                                                    */
      __IM  uint32_t EP9_OUT    : 1;            /*!< EP9_OUT                                                                   */
      __IM  uint32_t EP10_IN    : 1;            /*!< EP10_IN                                                                   */
      __IM  uint32_t EP10_OUT   : 1;            /*!< EP10_OUT                                                                  */
      __IM  uint32_t EP11_IN    : 1;            /*!< EP11_IN                                                                   */
      __IM  uint32_t EP11_OUT   : 1;            /*!< EP11_OUT                                                                  */
      __IM  uint32_t EP12_IN    : 1;            /*!< EP12_IN                                                                   */
      __IM  uint32_t EP12_OUT   : 1;            /*!< EP12_OUT                                                                  */
      __IM  uint32_t EP13_IN    : 1;            /*!< EP13_IN                                                                   */
      __IM  uint32_t EP13_OUT   : 1;            /*!< EP13_OUT                                                                  */
      __IM  uint32_t EP14_IN    : 1;            /*!< EP14_IN                                                                   */
      __IM  uint32_t EP14_OUT   : 1;            /*!< EP14_OUT                                                                  */
      __IM  uint32_t EP15_IN    : 1;            /*!< EP15_IN                                                                   */
      __IM  uint32_t EP15_OUT   : 1;            /*!< EP15_OUT                                                                  */
    } bit;
  } BUFF_CPU_SHOULD_HANDLE;
  
  union {
    __IOM uint32_t reg;                         /*!< Device only: Can be set to ignore the buffer control register
                                                     for this endpoint in case you would like to revoke a buffer.
                                                     A NAK will be sent for every access to the endpoint until
                                                     this bit is cleared. A corresponding bit in `EP_ABORT_DONE`
                                                     is set when it is safe to modify the buffer control register.             */
    
    struct {
      __IOM uint32_t EP0_IN     : 1;            /*!< EP0_IN                                                                    */
      __IOM uint32_t EP0_OUT    : 1;            /*!< EP0_OUT                                                                   */
      __IOM uint32_t EP1_IN     : 1;            /*!< EP1_IN                                                                    */
      __IOM uint32_t EP1_OUT    : 1;            /*!< EP1_OUT                                                                   */
      __IOM uint32_t EP2_IN     : 1;            /*!< EP2_IN                                                                    */
      __IOM uint32_t EP2_OUT    : 1;            /*!< EP2_OUT                                                                   */
      __IOM uint32_t EP3_IN     : 1;            /*!< EP3_IN                                                                    */
      __IOM uint32_t EP3_OUT    : 1;            /*!< EP3_OUT                                                                   */
      __IOM uint32_t EP4_IN     : 1;            /*!< EP4_IN                                                                    */
      __IOM uint32_t EP4_OUT    : 1;            /*!< EP4_OUT                                                                   */
      __IOM uint32_t EP5_IN     : 1;            /*!< EP5_IN                                                                    */
      __IOM uint32_t EP5_OUT    : 1;            /*!< EP5_OUT                                                                   */
      __IOM uint32_t EP6_IN     : 1;            /*!< EP6_IN                                                                    */
      __IOM uint32_t EP6_OUT    : 1;            /*!< EP6_OUT                                                                   */
      __IOM uint32_t EP7_IN     : 1;            /*!< EP7_IN                                                                    */
      __IOM uint32_t EP7_OUT    : 1;            /*!< EP7_OUT                                                                   */
      __IOM uint32_t EP8_IN     : 1;            /*!< EP8_IN                                                                    */
      __IOM uint32_t EP8_OUT    : 1;            /*!< EP8_OUT                                                                   */
      __IOM uint32_t EP9_IN     : 1;            /*!< EP9_IN                                                                    */
      __IOM uint32_t EP9_OUT    : 1;            /*!< EP9_OUT                                                                   */
      __IOM uint32_t EP10_IN    : 1;            /*!< EP10_IN                                                                   */
      __IOM uint32_t EP10_OUT   : 1;            /*!< EP10_OUT                                                                  */
      __IOM uint32_t EP11_IN    : 1;            /*!< EP11_IN                                                                   */
      __IOM uint32_t EP11_OUT   : 1;            /*!< EP11_OUT                                                                  */
      __IOM uint32_t EP12_IN    : 1;            /*!< EP12_IN                                                                   */
      __IOM uint32_t EP12_OUT   : 1;            /*!< EP12_OUT                                                                  */
      __IOM uint32_t EP13_IN    : 1;            /*!< EP13_IN                                                                   */
      __IOM uint32_t EP13_OUT   : 1;            /*!< EP13_OUT                                                                  */
      __IOM uint32_t EP14_IN    : 1;            /*!< EP14_IN                                                                   */
      __IOM uint32_t EP14_OUT   : 1;            /*!< EP14_OUT                                                                  */
      __IOM uint32_t EP15_IN    : 1;            /*!< EP15_IN                                                                   */
      __IOM uint32_t EP15_OUT   : 1;            /*!< EP15_OUT                                                                  */
    } bit;
  } EP_ABORT;
  
  union {
    __IOM uint32_t reg;                         /*!< Device only: Used in conjunction with `EP_ABORT`. Set once an
                                                     endpoint is idle so the programmer knows it is safe to
                                                     modify the buffer control register.                                       */
    
    struct {
      __IOM uint32_t EP0_IN     : 1;            /*!< EP0_IN                                                                    */
      __IOM uint32_t EP0_OUT    : 1;            /*!< EP0_OUT                                                                   */
      __IOM uint32_t EP1_IN     : 1;            /*!< EP1_IN                                                                    */
      __IOM uint32_t EP1_OUT    : 1;            /*!< EP1_OUT                                                                   */
      __IOM uint32_t EP2_IN     : 1;            /*!< EP2_IN                                                                    */
      __IOM uint32_t EP2_OUT    : 1;            /*!< EP2_OUT                                                                   */
      __IOM uint32_t EP3_IN     : 1;            /*!< EP3_IN                                                                    */
      __IOM uint32_t EP3_OUT    : 1;            /*!< EP3_OUT                                                                   */
      __IOM uint32_t EP4_IN     : 1;            /*!< EP4_IN                                                                    */
      __IOM uint32_t EP4_OUT    : 1;            /*!< EP4_OUT                                                                   */
      __IOM uint32_t EP5_IN     : 1;            /*!< EP5_IN                                                                    */
      __IOM uint32_t EP5_OUT    : 1;            /*!< EP5_OUT                                                                   */
      __IOM uint32_t EP6_IN     : 1;            /*!< EP6_IN                                                                    */
      __IOM uint32_t EP6_OUT    : 1;            /*!< EP6_OUT                                                                   */
      __IOM uint32_t EP7_IN     : 1;            /*!< EP7_IN                                                                    */
      __IOM uint32_t EP7_OUT    : 1;            /*!< EP7_OUT                                                                   */
      __IOM uint32_t EP8_IN     : 1;            /*!< EP8_IN                                                                    */
      __IOM uint32_t EP8_OUT    : 1;            /*!< EP8_OUT                                                                   */
      __IOM uint32_t EP9_IN     : 1;            /*!< EP9_IN                                                                    */
      __IOM uint32_t EP9_OUT    : 1;            /*!< EP9_OUT                                                                   */
      __IOM uint32_t EP10_IN    : 1;            /*!< EP10_IN                                                                   */
      __IOM uint32_t EP10_OUT   : 1;            /*!< EP10_OUT                                                                  */
      __IOM uint32_t EP11_IN    : 1;            /*!< EP11_IN                                                                   */
      __IOM uint32_t EP11_OUT   : 1;            /*!< EP11_OUT                                                                  */
      __IOM uint32_t EP12_IN    : 1;            /*!< EP12_IN                                                                   */
      __IOM uint32_t EP12_OUT   : 1;            /*!< EP12_OUT                                                                  */
      __IOM uint32_t EP13_IN    : 1;            /*!< EP13_IN                                                                   */
      __IOM uint32_t EP13_OUT   : 1;            /*!< EP13_OUT                                                                  */
      __IOM uint32_t EP14_IN    : 1;            /*!< EP14_IN                                                                   */
      __IOM uint32_t EP14_OUT   : 1;            /*!< EP14_OUT                                                                  */
      __IOM uint32_t EP15_IN    : 1;            /*!< EP15_IN                                                                   */
      __IOM uint32_t EP15_OUT   : 1;            /*!< EP15_OUT                                                                  */
    } bit;
  } EP_ABORT_DONE;
  
  union {
    __IOM uint32_t reg;                         /*!< Device: this bit must be set in conjunction with the `STALL`
                                                     bit in the buffer control register to send a STALL on EP0.
                                                     The device controller clears these bits when a SETUP packet
                                                     is received because the USB spec requires that a STALL
                                                     condition is cleared when a SETUP packet is received.                     */
    
    struct {
      __IOM uint32_t EP0_IN     : 1;            /*!< EP0_IN                                                                    */
      __IOM uint32_t EP0_OUT    : 1;            /*!< EP0_OUT                                                                   */
            uint32_t            : 30;
    } bit;
  } EP_STALL_ARM;
  
  union {
    __IOM uint32_t reg;                         /*!< Used by the host controller. Sets the wait time in microseconds
                                                     before trying again if the device replies with a NAK.                     */
    
    struct {
      __IOM uint32_t DELAY_LS   : 10;           /*!< NAK polling interval for a low speed device                               */
            uint32_t            : 6;
      __IOM uint32_t DELAY_FS   : 10;           /*!< NAK polling interval for a full speed device                              */
            uint32_t            : 6;
    } bit;
  } NAK_POLL;
  
  union {
    __IOM uint32_t reg;                         /*!< Device: bits are set when the `IRQ_ON_NAK` or `IRQ_ON_STALL`
                                                     bits are set. For EP0 this comes from `SIE_CTRL`. For all
                                                     other endpoints it comes from the endpoint control register.              */
    
    struct {
      __IOM uint32_t EP0_IN     : 1;            /*!< EP0_IN                                                                    */
      __IOM uint32_t EP0_OUT    : 1;            /*!< EP0_OUT                                                                   */
      __IOM uint32_t EP1_IN     : 1;            /*!< EP1_IN                                                                    */
      __IOM uint32_t EP1_OUT    : 1;            /*!< EP1_OUT                                                                   */
      __IOM uint32_t EP2_IN     : 1;            /*!< EP2_IN                                                                    */
      __IOM uint32_t EP2_OUT    : 1;            /*!< EP2_OUT                                                                   */
      __IOM uint32_t EP3_IN     : 1;            /*!< EP3_IN                                                                    */
      __IOM uint32_t EP3_OUT    : 1;            /*!< EP3_OUT                                                                   */
      __IOM uint32_t EP4_IN     : 1;            /*!< EP4_IN                                                                    */
      __IOM uint32_t EP4_OUT    : 1;            /*!< EP4_OUT                                                                   */
      __IOM uint32_t EP5_IN     : 1;            /*!< EP5_IN                                                                    */
      __IOM uint32_t EP5_OUT    : 1;            /*!< EP5_OUT                                                                   */
      __IOM uint32_t EP6_IN     : 1;            /*!< EP6_IN                                                                    */
      __IOM uint32_t EP6_OUT    : 1;            /*!< EP6_OUT                                                                   */
      __IOM uint32_t EP7_IN     : 1;            /*!< EP7_IN                                                                    */
      __IOM uint32_t EP7_OUT    : 1;            /*!< EP7_OUT                                                                   */
      __IOM uint32_t EP8_IN     : 1;            /*!< EP8_IN                                                                    */
      __IOM uint32_t EP8_OUT    : 1;            /*!< EP8_OUT                                                                   */
      __IOM uint32_t EP9_IN     : 1;            /*!< EP9_IN                                                                    */
      __IOM uint32_t EP9_OUT    : 1;            /*!< EP9_OUT                                                                   */
      __IOM uint32_t EP10_IN    : 1;            /*!< EP10_IN                                                                   */
      __IOM uint32_t EP10_OUT   : 1;            /*!< EP10_OUT                                                                  */
      __IOM uint32_t EP11_IN    : 1;            /*!< EP11_IN                                                                   */
      __IOM uint32_t EP11_OUT   : 1;            /*!< EP11_OUT                                                                  */
      __IOM uint32_t EP12_IN    : 1;            /*!< EP12_IN                                                                   */
      __IOM uint32_t EP12_OUT   : 1;            /*!< EP12_OUT                                                                  */
      __IOM uint32_t EP13_IN    : 1;            /*!< EP13_IN                                                                   */
      __IOM uint32_t EP13_OUT   : 1;            /*!< EP13_OUT                                                                  */
      __IOM uint32_t EP14_IN    : 1;            /*!< EP14_IN                                                                   */
      __IOM uint32_t EP14_OUT   : 1;            /*!< EP14_OUT                                                                  */
      __IOM uint32_t EP15_IN    : 1;            /*!< EP15_IN                                                                   */
      __IOM uint32_t EP15_OUT   : 1;            /*!< EP15_OUT                                                                  */
    } bit;
  } EP_STATUS_STALL_NAK;
  
  union {
    __IOM uint32_t reg;                         /*!< Where to connect the USB controller. Should be to_phy by default.         */
    
    struct {
      __IOM uint32_t TO_PHY     : 1;            /*!< TO_PHY                                                                    */
      __IOM uint32_t TO_EXTPHY  : 1;            /*!< TO_EXTPHY                                                                 */
      __IOM uint32_t TO_DIGITAL_PAD : 1;        /*!< TO_DIGITAL_PAD                                                            */
      __IOM uint32_t SOFTCON    : 1;            /*!< SOFTCON                                                                   */
            uint32_t            : 28;
    } bit;
  } USB_MUXING;
  
  union {
    __IOM uint32_t reg;                         /*!< Overrides for the power signals in the event that the VBUS signals
                                                     are not hooked up to GPIO. Set the value of the override
                                                     and then the override enable so switch over to the override
                                                     value.                                                                    */
    
    struct {
      __IOM uint32_t VBUS_EN    : 1;            /*!< VBUS_EN                                                                   */
      __IOM uint32_t VBUS_EN_OVERRIDE_EN : 1;   /*!< VBUS_EN_OVERRIDE_EN                                                       */
      __IOM uint32_t VBUS_DETECT : 1;           /*!< VBUS_DETECT                                                               */
      __IOM uint32_t VBUS_DETECT_OVERRIDE_EN : 1;/*!< VBUS_DETECT_OVERRIDE_EN                                                  */
      __IOM uint32_t OVERCURR_DETECT : 1;       /*!< OVERCURR_DETECT                                                           */
      __IOM uint32_t OVERCURR_DETECT_EN : 1;    /*!< OVERCURR_DETECT_EN                                                        */
            uint32_t            : 26;
    } bit;
  } USB_PWR;
  
  union {
    __IOM uint32_t reg;                         /*!< Note that most functions are driven directly from usb_fsls controller.
                                                     This register allows more detailed control/status from
                                                     the USB PHY. Useful for debug but not expected to be used
                                                     in normal operation Use in conjunction with usbphy_direct_override
                                                     register                                                                  */
    
    struct {
      __IOM uint32_t DP_PULLUP_HISEL : 1;       /*!< when dp_pullup_en is set high, this enables second resistor.
                                                     0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2                                   */
      __IOM uint32_t DP_PULLUP_EN : 1;          /*!< Value to drive to USB PHY when override enable is set (which
                                                     will override the default value or value driven from USB
                                                     controller                                                                */
      __IOM uint32_t DP_PULLDN_EN : 1;          /*!< Value to drive to USB PHY when override enable is set (which
                                                     will override the default value or value driven from USB
                                                     controller 1 - Enable Rpd on DPP                                          */
            uint32_t            : 1;
      __IOM uint32_t DM_PULLUP_HISEL : 1;       /*!< when dm_pullup_en is set high, this enables second resistor.
                                                     0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2                                   */
      __IOM uint32_t DM_PULLUP_EN : 1;          /*!< Value to drive to USB PHY when override enable is set (which
                                                     will override the default value or value driven from USB
                                                     controller 1 - Enable Rpu on DPM                                          */
      __IOM uint32_t DM_PULLDN_EN : 1;          /*!< Value to drive to USB PHY when override enable is set (which
                                                     will override the default value or value driven from USB
                                                     controller 1 - Enable Rpd on DPM                                          */
            uint32_t            : 1;
      __IOM uint32_t TX_DP_OE   : 1;            /*!< Value to drive to USB PHY when override enable is set (which
                                                     will override the default value or value driven from USB
                                                     controller TX_SEMODE=0, OE for DPP/DPM diff pair. 0 - DPP/DPM
                                                     in Hi-Z state; 1 - DPP/DPM driving TX_SEMODE=1, OE for
                                                     DPP only. 0 - DPP in Hi-Z state; 1 - DPP driving                          */
      __IOM uint32_t TX_DM_OE   : 1;            /*!< Value to drive to USB PHY when override enable is set (which
                                                     will override the default value or value driven from USB
                                                     controller TX_SEMODE=0, Ignored. TX_SEMODE=1, OE for DPM
                                                     only. 0 - DPM in Hi-Z state; 1 - DPM driving                              */
      __IOM uint32_t TX_DP      : 1;            /*!< Value to drive to USB PHY when override enable is set (which
                                                     will override the default value or value driven from USB
                                                     controller TX_SEMODE=0, Drives DPP/DPM diff pair. TX_DP_OE=1
                                                     to enable drive. DPP=TX_DP, DPM=~TX_DP TX_SEMODE=1, Drives
                                                     DPP only. TX_DP_OE=1 to enable drive. DPP=TX_DP                           */
      __IOM uint32_t TX_DM      : 1;            /*!< Value to drive to USB PHY when override enable is set (which
                                                     will override the default value or value driven from USB
                                                     controller TX_SEMODE=0, Ignored TX_SEMODE=1, Drives DPM
                                                     only. TX_DM_OE=1 to enable drive. DPM=TX_DM                               */
      __IOM uint32_t RX_PD      : 1;            /*!< RX_PD                                                                     */
      __IOM uint32_t TX_PD      : 1;            /*!< TX_PD                                                                     */
      __IOM uint32_t TX_FSSLEW  : 1;            /*!< TX_FSSLEW                                                                 */
      __IOM uint32_t TX_DIFFMODE : 1;           /*!< TX_DIFFMODE                                                               */
      __IM  uint32_t RX_DD      : 1;            /*!< Status bit from USB PHY RX Diff data                                      */
      __IM  uint32_t RX_DP      : 1;            /*!< Status bit from USB PHY DPP pin state                                     */
      __IM  uint32_t RX_DM      : 1;            /*!< Status bit from USB PHY DPM pin state                                     */
      __IM  uint32_t DP_OVCN    : 1;            /*!< Status bit from USB PHY                                                   */
      __IM  uint32_t DM_OVCN    : 1;            /*!< Status bit from USB PHY                                                   */
      __IM  uint32_t DP_OVV     : 1;            /*!< Status bit from USB PHY                                                   */
      __IM  uint32_t DM_OVV     : 1;            /*!< Status bit from USB PHY                                                   */
            uint32_t            : 9;
    } bit;
  } USBPHY_DIRECT;
  
  union {
    __IOM uint32_t reg;                         /*!< USBPHY_DIRECT_OVERRIDE                                                    */
    
    struct {
      __IOM uint32_t DP_PULLUP_HISEL_OVERRIDE_EN : 1;/*!< DP_PULLUP_HISEL_OVERRIDE_EN                                          */
      __IOM uint32_t DM_PULLUP_HISEL_OVERRIDE_EN : 1;/*!< DM_PULLUP_HISEL_OVERRIDE_EN                                          */
      __IOM uint32_t DP_PULLUP_EN_OVERRIDE_EN : 1;/*!< Override default value or value driven from USB Controller to
                                                     PHY                                                                       */
      __IOM uint32_t DP_PULLDN_EN_OVERRIDE_EN : 1;/*!< Override default value or value driven from USB Controller to
                                                     PHY                                                                       */
      __IOM uint32_t DM_PULLDN_EN_OVERRIDE_EN : 1;/*!< Override default value or value driven from USB Controller to
                                                     PHY                                                                       */
      __IOM uint32_t TX_DP_OE_OVERRIDE_EN : 1;  /*!< Override default value or value driven from USB Controller to
                                                     PHY                                                                       */
      __IOM uint32_t TX_DM_OE_OVERRIDE_EN : 1;  /*!< Override default value or value driven from USB Controller to
                                                     PHY                                                                       */
      __IOM uint32_t TX_DP_OVERRIDE_EN : 1;     /*!< Override default value or value driven from USB Controller to
                                                     PHY                                                                       */
      __IOM uint32_t TX_DM_OVERRIDE_EN : 1;     /*!< Override default value or value driven from USB Controller to
                                                     PHY                                                                       */
      __IOM uint32_t RX_PD_OVERRIDE_EN : 1;     /*!< RX_PD_OVERRIDE_EN                                                         */
      __IOM uint32_t TX_PD_OVERRIDE_EN : 1;     /*!< TX_PD_OVERRIDE_EN                                                         */
      __IOM uint32_t TX_FSSLEW_OVERRIDE_EN : 1; /*!< TX_FSSLEW_OVERRIDE_EN                                                     */
      __IOM uint32_t DM_PULLUP_OVERRIDE_EN : 1; /*!< DM_PULLUP_OVERRIDE_EN                                                     */
            uint32_t            : 2;
      __IOM uint32_t TX_DIFFMODE_OVERRIDE_EN : 1;/*!< TX_DIFFMODE_OVERRIDE_EN                                                  */
            uint32_t            : 16;
    } bit;
  } USBPHY_DIRECT_OVERRIDE;
  
  union {
    __IOM uint32_t reg;                         /*!< Note that most functions are driven directly from usb_fsls controller.
                                                     This register allows more detailed control/status from
                                                     the USB PHY. Useful for debug but not expected to be used
                                                     in normal operation                                                       */
    
    struct {
      __IOM uint32_t DP_PULLDN_TRIM : 5;        /*!< Value to drive to USB PHY DP pulldown resistor trim control
                                                     Experimental data suggests that the reset value will work,
                                                     but this register allows adjustment if required                           */
            uint32_t            : 3;
      __IOM uint32_t DM_PULLDN_TRIM : 5;        /*!< Value to drive to USB PHY DM pulldown resistor trim control
                                                     Experimental data suggests that the reset value will work,
                                                     but this register allows adjustment if required                           */
            uint32_t            : 19;
    } bit;
  } USBPHY_TRIM;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw Interrupts                                                            */
    
    struct {
      __IM  uint32_t HOST_CONN_DIS : 1;         /*!< Host: raised when a device is connected or disconnected (i.e.
                                                     when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED    */
      __IM  uint32_t HOST_RESUME : 1;           /*!< Host: raised when a device wakes up the host. Cleared by writing
                                                     to SIE_STATUS.RESUME_REMOTE                                               */
      __IM  uint32_t HOST_SOF   : 1;            /*!< Host: raised every time the host sends a SOF (Start of Frame).
                                                     Cleared by reading SOF_RD                                                 */
      __IM  uint32_t TRANS_COMPLETE : 1;        /*!< Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by
                                                     writing to this bit.                                                      */
      __IM  uint32_t BUFF_STATUS : 1;           /*!< Raised when any bit in BUFF_STATUS is set. Clear by clearing
                                                     all bits in BUFF_STATUS.                                                  */
      __IM  uint32_t ERROR_DATA_SEQ : 1;        /*!< Source: SIE_STATUS.DATA_SEQ_ERROR                                         */
      __IM  uint32_t ERROR_RX_TIMEOUT : 1;      /*!< Source: SIE_STATUS.RX_TIMEOUT                                             */
      __IM  uint32_t ERROR_RX_OVERFLOW : 1;     /*!< Source: SIE_STATUS.RX_OVERFLOW                                            */
      __IM  uint32_t ERROR_BIT_STUFF : 1;       /*!< Source: SIE_STATUS.BIT_STUFF_ERROR                                        */
      __IM  uint32_t ERROR_CRC  : 1;            /*!< Source: SIE_STATUS.CRC_ERROR                                              */
      __IM  uint32_t STALL      : 1;            /*!< Source: SIE_STATUS.STALL_REC                                              */
      __IM  uint32_t VBUS_DETECT : 1;           /*!< Source: SIE_STATUS.VBUS_DETECT                                            */
      __IM  uint32_t BUS_RESET  : 1;            /*!< Source: SIE_STATUS.BUS_RESET                                              */
      __IM  uint32_t DEV_CONN_DIS : 1;          /*!< Set when the device connection state changes. Cleared by writing
                                                     to SIE_STATUS.CONNECTED                                                   */
      __IM  uint32_t DEV_SUSPEND : 1;           /*!< Set when the device suspend state changes. Cleared by writing
                                                     to SIE_STATUS.SUSPENDED                                                   */
      __IM  uint32_t DEV_RESUME_FROM_HOST : 1;  /*!< Set when the device receives a resume from the host. Cleared
                                                     by writing to SIE_STATUS.RESUME_REMOTE                                    */
      __IM  uint32_t SETUP_REQ  : 1;            /*!< Device. Source: SIE_STATUS.SETUP_REC                                      */
      __IM  uint32_t DEV_SOF    : 1;            /*!< Set every time the device receives a SOF (Start of Frame) packet.
                                                     Cleared by reading SOF_RD                                                 */
      __IM  uint32_t ABORT_DONE : 1;            /*!< Raised when any bit in ABORT_DONE is set. Clear by clearing
                                                     all bits in ABORT_DONE.                                                   */
      __IM  uint32_t EP_STALL_NAK : 1;          /*!< Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by
                                                     clearing all bits in EP_STATUS_STALL_NAK.                                 */
            uint32_t            : 12;
    } bit;
  } INTR;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable                                                          */
    
    struct {
      __IOM uint32_t HOST_CONN_DIS : 1;         /*!< Host: raised when a device is connected or disconnected (i.e.
                                                     when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED    */
      __IOM uint32_t HOST_RESUME : 1;           /*!< Host: raised when a device wakes up the host. Cleared by writing
                                                     to SIE_STATUS.RESUME_REMOTE                                               */
      __IOM uint32_t HOST_SOF   : 1;            /*!< Host: raised every time the host sends a SOF (Start of Frame).
                                                     Cleared by reading SOF_RD                                                 */
      __IOM uint32_t TRANS_COMPLETE : 1;        /*!< Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by
                                                     writing to this bit.                                                      */
      __IOM uint32_t BUFF_STATUS : 1;           /*!< Raised when any bit in BUFF_STATUS is set. Clear by clearing
                                                     all bits in BUFF_STATUS.                                                  */
      __IOM uint32_t ERROR_DATA_SEQ : 1;        /*!< Source: SIE_STATUS.DATA_SEQ_ERROR                                         */
      __IOM uint32_t ERROR_RX_TIMEOUT : 1;      /*!< Source: SIE_STATUS.RX_TIMEOUT                                             */
      __IOM uint32_t ERROR_RX_OVERFLOW : 1;     /*!< Source: SIE_STATUS.RX_OVERFLOW                                            */
      __IOM uint32_t ERROR_BIT_STUFF : 1;       /*!< Source: SIE_STATUS.BIT_STUFF_ERROR                                        */
      __IOM uint32_t ERROR_CRC  : 1;            /*!< Source: SIE_STATUS.CRC_ERROR                                              */
      __IOM uint32_t STALL      : 1;            /*!< Source: SIE_STATUS.STALL_REC                                              */
      __IOM uint32_t VBUS_DETECT : 1;           /*!< Source: SIE_STATUS.VBUS_DETECT                                            */
      __IOM uint32_t BUS_RESET  : 1;            /*!< Source: SIE_STATUS.BUS_RESET                                              */
      __IOM uint32_t DEV_CONN_DIS : 1;          /*!< Set when the device connection state changes. Cleared by writing
                                                     to SIE_STATUS.CONNECTED                                                   */
      __IOM uint32_t DEV_SUSPEND : 1;           /*!< Set when the device suspend state changes. Cleared by writing
                                                     to SIE_STATUS.SUSPENDED                                                   */
      __IOM uint32_t DEV_RESUME_FROM_HOST : 1;  /*!< Set when the device receives a resume from the host. Cleared
                                                     by writing to SIE_STATUS.RESUME_REMOTE                                    */
      __IOM uint32_t SETUP_REQ  : 1;            /*!< Device. Source: SIE_STATUS.SETUP_REC                                      */
      __IOM uint32_t DEV_SOF    : 1;            /*!< Set every time the device receives a SOF (Start of Frame) packet.
                                                     Cleared by reading SOF_RD                                                 */
      __IOM uint32_t ABORT_DONE : 1;            /*!< Raised when any bit in ABORT_DONE is set. Clear by clearing
                                                     all bits in ABORT_DONE.                                                   */
      __IOM uint32_t EP_STALL_NAK : 1;          /*!< Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by
                                                     clearing all bits in EP_STATUS_STALL_NAK.                                 */
            uint32_t            : 12;
    } bit;
  } INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force                                                           */
    
    struct {
      __IOM uint32_t HOST_CONN_DIS : 1;         /*!< Host: raised when a device is connected or disconnected (i.e.
                                                     when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED    */
      __IOM uint32_t HOST_RESUME : 1;           /*!< Host: raised when a device wakes up the host. Cleared by writing
                                                     to SIE_STATUS.RESUME_REMOTE                                               */
      __IOM uint32_t HOST_SOF   : 1;            /*!< Host: raised every time the host sends a SOF (Start of Frame).
                                                     Cleared by reading SOF_RD                                                 */
      __IOM uint32_t TRANS_COMPLETE : 1;        /*!< Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by
                                                     writing to this bit.                                                      */
      __IOM uint32_t BUFF_STATUS : 1;           /*!< Raised when any bit in BUFF_STATUS is set. Clear by clearing
                                                     all bits in BUFF_STATUS.                                                  */
      __IOM uint32_t ERROR_DATA_SEQ : 1;        /*!< Source: SIE_STATUS.DATA_SEQ_ERROR                                         */
      __IOM uint32_t ERROR_RX_TIMEOUT : 1;      /*!< Source: SIE_STATUS.RX_TIMEOUT                                             */
      __IOM uint32_t ERROR_RX_OVERFLOW : 1;     /*!< Source: SIE_STATUS.RX_OVERFLOW                                            */
      __IOM uint32_t ERROR_BIT_STUFF : 1;       /*!< Source: SIE_STATUS.BIT_STUFF_ERROR                                        */
      __IOM uint32_t ERROR_CRC  : 1;            /*!< Source: SIE_STATUS.CRC_ERROR                                              */
      __IOM uint32_t STALL      : 1;            /*!< Source: SIE_STATUS.STALL_REC                                              */
      __IOM uint32_t VBUS_DETECT : 1;           /*!< Source: SIE_STATUS.VBUS_DETECT                                            */
      __IOM uint32_t BUS_RESET  : 1;            /*!< Source: SIE_STATUS.BUS_RESET                                              */
      __IOM uint32_t DEV_CONN_DIS : 1;          /*!< Set when the device connection state changes. Cleared by writing
                                                     to SIE_STATUS.CONNECTED                                                   */
      __IOM uint32_t DEV_SUSPEND : 1;           /*!< Set when the device suspend state changes. Cleared by writing
                                                     to SIE_STATUS.SUSPENDED                                                   */
      __IOM uint32_t DEV_RESUME_FROM_HOST : 1;  /*!< Set when the device receives a resume from the host. Cleared
                                                     by writing to SIE_STATUS.RESUME_REMOTE                                    */
      __IOM uint32_t SETUP_REQ  : 1;            /*!< Device. Source: SIE_STATUS.SETUP_REC                                      */
      __IOM uint32_t DEV_SOF    : 1;            /*!< Set every time the device receives a SOF (Start of Frame) packet.
                                                     Cleared by reading SOF_RD                                                 */
      __IOM uint32_t ABORT_DONE : 1;            /*!< Raised when any bit in ABORT_DONE is set. Clear by clearing
                                                     all bits in ABORT_DONE.                                                   */
      __IOM uint32_t EP_STALL_NAK : 1;          /*!< Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by
                                                     clearing all bits in EP_STATUS_STALL_NAK.                                 */
            uint32_t            : 12;
    } bit;
  } INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing                                  */
    
    struct {
      __IM  uint32_t HOST_CONN_DIS : 1;         /*!< Host: raised when a device is connected or disconnected (i.e.
                                                     when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED    */
      __IM  uint32_t HOST_RESUME : 1;           /*!< Host: raised when a device wakes up the host. Cleared by writing
                                                     to SIE_STATUS.RESUME_REMOTE                                               */
      __IM  uint32_t HOST_SOF   : 1;            /*!< Host: raised every time the host sends a SOF (Start of Frame).
                                                     Cleared by reading SOF_RD                                                 */
      __IM  uint32_t TRANS_COMPLETE : 1;        /*!< Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by
                                                     writing to this bit.                                                      */
      __IM  uint32_t BUFF_STATUS : 1;           /*!< Raised when any bit in BUFF_STATUS is set. Clear by clearing
                                                     all bits in BUFF_STATUS.                                                  */
      __IM  uint32_t ERROR_DATA_SEQ : 1;        /*!< Source: SIE_STATUS.DATA_SEQ_ERROR                                         */
      __IM  uint32_t ERROR_RX_TIMEOUT : 1;      /*!< Source: SIE_STATUS.RX_TIMEOUT                                             */
      __IM  uint32_t ERROR_RX_OVERFLOW : 1;     /*!< Source: SIE_STATUS.RX_OVERFLOW                                            */
      __IM  uint32_t ERROR_BIT_STUFF : 1;       /*!< Source: SIE_STATUS.BIT_STUFF_ERROR                                        */
      __IM  uint32_t ERROR_CRC  : 1;            /*!< Source: SIE_STATUS.CRC_ERROR                                              */
      __IM  uint32_t STALL      : 1;            /*!< Source: SIE_STATUS.STALL_REC                                              */
      __IM  uint32_t VBUS_DETECT : 1;           /*!< Source: SIE_STATUS.VBUS_DETECT                                            */
      __IM  uint32_t BUS_RESET  : 1;            /*!< Source: SIE_STATUS.BUS_RESET                                              */
      __IM  uint32_t DEV_CONN_DIS : 1;          /*!< Set when the device connection state changes. Cleared by writing
                                                     to SIE_STATUS.CONNECTED                                                   */
      __IM  uint32_t DEV_SUSPEND : 1;           /*!< Set when the device suspend state changes. Cleared by writing
                                                     to SIE_STATUS.SUSPENDED                                                   */
      __IM  uint32_t DEV_RESUME_FROM_HOST : 1;  /*!< Set when the device receives a resume from the host. Cleared
                                                     by writing to SIE_STATUS.RESUME_REMOTE                                    */
      __IM  uint32_t SETUP_REQ  : 1;            /*!< Device. Source: SIE_STATUS.SETUP_REC                                      */
      __IM  uint32_t DEV_SOF    : 1;            /*!< Set every time the device receives a SOF (Start of Frame) packet.
                                                     Cleared by reading SOF_RD                                                 */
      __IM  uint32_t ABORT_DONE : 1;            /*!< Raised when any bit in ABORT_DONE is set. Clear by clearing
                                                     all bits in ABORT_DONE.                                                   */
      __IM  uint32_t EP_STALL_NAK : 1;          /*!< Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by
                                                     clearing all bits in EP_STATUS_STALL_NAK.                                 */
            uint32_t            : 12;
    } bit;
  } INTS;
} USB_Type;                                     /*!< Size = 156 (0x9c)                                                         */



/* =========================================================================================================================== */
/* ================                                         USB_DPRAM                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief DPRAM layout for USB device. (USB_DPRAM)
  */

typedef struct {                                /*!< USB_DPRAM Structure                                                       */
  
  union {
    __IOM uint32_t reg;                         /*!< Bytes 0-3 of the SETUP packet from the host.                              */
    
    struct {
      __IOM uint32_t BMREQUESTTYPE : 8;         /*!< BMREQUESTTYPE                                                             */
      __IOM uint32_t BREQUEST   : 8;            /*!< BREQUEST                                                                  */
      __IOM uint32_t WVALUE     : 16;           /*!< WVALUE                                                                    */
    } bit;
  } SETUP_PACKET_LOW;
  
  union {
    __IOM uint32_t reg;                         /*!< Bytes 4-7 of the setup packet from the host.                              */
    
    struct {
      __IOM uint32_t WINDEX     : 16;           /*!< WINDEX                                                                    */
      __IOM uint32_t WLENGTH    : 16;           /*!< WLENGTH                                                                   */
    } bit;
  } SETUP_PACKET_HIGH;
  
  union {
    __IOM uint32_t reg;                         /*!< EP1_IN_CONTROL                                                            */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP1_IN_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP1_OUT_CONTROL                                                           */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP1_OUT_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP2_IN_CONTROL                                                            */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP2_IN_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP2_OUT_CONTROL                                                           */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP2_OUT_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP3_IN_CONTROL                                                            */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP3_IN_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP3_OUT_CONTROL                                                           */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP3_OUT_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP4_IN_CONTROL                                                            */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP4_IN_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP4_OUT_CONTROL                                                           */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP4_OUT_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP5_IN_CONTROL                                                            */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP5_IN_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP5_OUT_CONTROL                                                           */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP5_OUT_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP6_IN_CONTROL                                                            */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP6_IN_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP6_OUT_CONTROL                                                           */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP6_OUT_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP7_IN_CONTROL                                                            */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP7_IN_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP7_OUT_CONTROL                                                           */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP7_OUT_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP8_IN_CONTROL                                                            */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP8_IN_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP8_OUT_CONTROL                                                           */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP8_OUT_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP9_IN_CONTROL                                                            */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP9_IN_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP9_OUT_CONTROL                                                           */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP9_OUT_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP10_IN_CONTROL                                                           */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP10_IN_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP10_OUT_CONTROL                                                          */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP10_OUT_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP11_IN_CONTROL                                                           */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP11_IN_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP11_OUT_CONTROL                                                          */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP11_OUT_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP12_IN_CONTROL                                                           */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP12_IN_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP12_OUT_CONTROL                                                          */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP12_OUT_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP13_IN_CONTROL                                                           */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP13_IN_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP13_OUT_CONTROL                                                          */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP13_OUT_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP14_IN_CONTROL                                                           */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP14_IN_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP14_OUT_CONTROL                                                          */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP14_OUT_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP15_IN_CONTROL                                                           */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP15_IN_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< EP15_OUT_CONTROL                                                          */
    
    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
                                                     Relative to the start of the DPRAM.                                       */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< Trigger an interrupt if a NAK is sent. Intended for debug only.           */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< Trigger an interrupt if a STALL is sent. Intended for debug
                                                     only.                                                                     */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< ENDPOINT_TYPE                                                             */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< Trigger an interrupt each time both buffers are done. Only valid
                                                     in double buffered mode.                                                  */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< Trigger an interrupt each time a buffer is done.                          */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< This endpoint is double buffered.                                         */
      __IOM uint32_t ENABLE     : 1;            /*!< Enable this endpoint. The device will not reply to any packets
                                                     for this endpoint if this bit is not set.                                 */
    } bit;
  } EP15_OUT_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP0_IN_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP0_OUT_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP1_IN_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP1_OUT_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP2_IN_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP2_OUT_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP3_IN_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP3_OUT_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP4_IN_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP4_OUT_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP5_IN_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP5_OUT_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP6_IN_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP6_OUT_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP7_IN_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP7_OUT_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP8_IN_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP8_OUT_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP9_IN_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP9_OUT_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP10_IN_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP10_OUT_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP11_IN_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP11_OUT_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP12_IN_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP12_OUT_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP13_IN_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP13_OUT_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP14_IN_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP14_OUT_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP15_IN_BUFFER_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< Buffer control for both buffers of an endpoint. Fields ending
                                                     in a _1 are for buffer 1. Fields ending in a _0 are for
                                                     buffer 0. Buffer 1 controls are only valid if the endpoint
                                                     is in double buffered mode.                                               */
    
    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< The length of the data in buffer 0.                                       */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< Buffer 0 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t STALL      : 1;            /*!< Reply with a stall (valid for both buffers).                              */
      __IOM uint32_t RESET      : 1;            /*!< Reset the buffer selector to buffer 0.                                    */
      __IOM uint32_t PID_0      : 1;            /*!< The data pid of buffer 0.                                                 */
      __IOM uint32_t LAST_0     : 1;            /*!< Buffer 0 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_0     : 1;            /*!< Buffer 0 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
      __IOM uint32_t LENGTH_1   : 10;           /*!< The length of the data in buffer 1.                                       */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< Buffer 1 is available. This bit is set to indicate the buffer
                                                     can be used by the controller. The controller clears the
                                                     available bit when writing the status back.                               */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< The number of bytes buffer 1 is offset from buffer 0 in Isochronous
                                                     mode. Only valid in double buffered mode for an Isochronous
                                                     endpoint. For a non Isochronous endpoint the offset is
                                                     always 64 bytes.                                                          */
      __IOM uint32_t PID_1      : 1;            /*!< The data pid of buffer 1.                                                 */
      __IOM uint32_t LAST_1     : 1;            /*!< Buffer 1 is the last buffer of the transfer.                              */
      __IOM uint32_t FULL_1     : 1;            /*!< Buffer 1 is full. For an IN transfer (TX to the host) the bit
                                                     is set to indicate the data is valid. For an OUT transfer
                                                     (RX from the host) this bit should be left as a 0. The
                                                     host will set it when it has filled the buffer with data.                 */
    } bit;
  } EP15_OUT_BUFFER_CONTROL;
} USB_DPRAM_Type;                               /*!< Size = 256 (0x100)                                                        */



/* =========================================================================================================================== */
/* ================                                           TBMAN                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Testbench manager. Allows the programmer to know what platform their software is running on. (TBMAN)
  */

typedef struct {                                /*!< TBMAN Structure                                                           */
  
  union {
    __IOM uint32_t reg;                         /*!< Indicates the type of platform in use                                     */
    
    struct {
      __IM  uint32_t ASIC       : 1;            /*!< Indicates the platform is an ASIC                                         */
      __IM  uint32_t FPGA       : 1;            /*!< Indicates the platform is an FPGA                                         */
            uint32_t            : 30;
    } bit;
  } PLATFORM;
} TBMAN_Type;                                   /*!< Size = 4 (0x4)                                                            */



/* =========================================================================================================================== */
/* ================                                    VREG_AND_CHIP_RESET                                    ================ */
/* =========================================================================================================================== */


/**
  * @brief control and status for on-chip voltage regulator and chip level reset subsystem (VREG_AND_CHIP_RESET)
  */

typedef struct {                                /*!< VREG_AND_CHIP_RESET Structure                                             */
  
  union {
    __IOM uint32_t reg;                         /*!< Voltage regulator control and status                                      */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< enable 0=not enabled, 1=enabled                                           */
      __IOM uint32_t HIZ        : 1;            /*!< high impedance mode select 0=not in high impedance mode, 1=in
                                                     high impedance mode                                                       */
            uint32_t            : 2;
      __IOM uint32_t VSEL       : 4;            /*!< output voltage select 0000 to 0101 - 0.80V 0110 - 0.85V 0111
                                                     - 0.90V 1000 - 0.95V 1001 - 1.00V 1010 - 1.05V 1011 - 1.10V
                                                     (default) 1100 - 1.15V 1101 - 1.20V 1110 - 1.25V 1111 -
                                                     1.30V                                                                     */
            uint32_t            : 4;
      __IM  uint32_t ROK        : 1;            /*!< regulation status 0=not in regulation, 1=in regulation                    */
            uint32_t            : 19;
    } bit;
  } VREG;
  
  union {
    __IOM uint32_t reg;                         /*!< brown-out detection control                                               */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< enable 0=not enabled, 1=enabled                                           */
            uint32_t            : 3;
      __IOM uint32_t VSEL       : 4;            /*!< threshold select 0000 - 0.473V 0001 - 0.516V 0010 - 0.559V 0011
                                                     - 0.602V 0100 - 0.645V 0101 - 0.688V 0110 - 0.731V 0111
                                                     - 0.774V 1000 - 0.817V 1001 - 0.860V (default) 1010 - 0.903V
                                                     1011 - 0.946V 1100 - 0.989V 1101 - 1.032V 1110 - 1.075V
                                                     1111 - 1.118V                                                             */
            uint32_t            : 24;
    } bit;
  } BOD;
  
  union {
    __IOM uint32_t reg;                         /*!< Chip reset control and status                                             */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t HAD_POR    : 1;            /*!< Last reset was from the power-on reset or brown-out detection
                                                     blocks                                                                    */
            uint32_t            : 7;
      __IM  uint32_t HAD_RUN    : 1;            /*!< Last reset was from the RUN pin                                           */
            uint32_t            : 3;
      __IM  uint32_t HAD_PSM_RESTART : 1;       /*!< Last reset was from the debug port                                        */
            uint32_t            : 3;
      __IOM uint32_t PSM_RESTART_FLAG : 1;      /*!< This is set by psm_restart from the debugger. Its purpose is
                                                     to branch bootcode to a safe mode when the debugger has
                                                     issued a psm_restart in order to recover from a boot lock-up.
                                                     In the safe mode the debugger can repair the boot code,
                                                     clear this flag then reboot the processor.                                */
            uint32_t            : 7;
    } bit;
  } CHIP_RESET;
} VREG_AND_CHIP_RESET_Type;                     /*!< Size = 12 (0xc)                                                           */



/* =========================================================================================================================== */
/* ================                                            RTC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Register block to control RTC (RTC)
  */

typedef struct {                                /*!< RTC Structure                                                             */
  
  union {
    __IOM uint32_t reg;                         /*!< Divider minus 1 for the 1 second counter. Safe to change the
                                                     value when RTC is not enabled.                                            */
    
    struct {
      __IOM uint32_t CLKDIV_M1  : 16;           /*!< CLKDIV_M1                                                                 */
            uint32_t            : 16;
    } bit;
  } CLKDIV_M1;
  
  union {
    __IOM uint32_t reg;                         /*!< RTC setup register 0                                                      */
    
    struct {
      __IOM uint32_t DAY        : 5;            /*!< Day of the month (1..31)                                                  */
            uint32_t            : 3;
      __IOM uint32_t MONTH      : 4;            /*!< Month (1..12)                                                             */
      __IOM uint32_t YEAR       : 12;           /*!< Year                                                                      */
            uint32_t            : 8;
    } bit;
  } SETUP_0;
  
  union {
    __IOM uint32_t reg;                         /*!< RTC setup register 1                                                      */
    
    struct {
      __IOM uint32_t SEC        : 6;            /*!< Seconds                                                                   */
            uint32_t            : 2;
      __IOM uint32_t MIN        : 6;            /*!< Minutes                                                                   */
            uint32_t            : 2;
      __IOM uint32_t HOUR       : 5;            /*!< Hours                                                                     */
            uint32_t            : 3;
      __IOM uint32_t DOTW       : 3;            /*!< Day of the week: 1-Monday...0-Sunday ISO 8601 mod 7                       */
            uint32_t            : 5;
    } bit;
  } SETUP_1;
  
  union {
    __IOM uint32_t reg;                         /*!< RTC Control and status                                                    */
    
    struct {
      __IOM uint32_t RTC_ENABLE : 1;            /*!< Enable RTC                                                                */
      __IM  uint32_t RTC_ACTIVE : 1;            /*!< RTC enabled (running)                                                     */
            uint32_t            : 2;
      __OM  uint32_t LOAD       : 1;            /*!< Load RTC                                                                  */
            uint32_t            : 3;
      __IOM uint32_t FORCE_NOTLEAPYEAR : 1;     /*!< If set, leapyear is forced off. Useful for years divisible by
                                                     100 but not by 400                                                        */
            uint32_t            : 23;
    } bit;
  } CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt setup register 0                                                */
    
    struct {
      __IOM uint32_t DAY        : 5;            /*!< Day of the month (1..31)                                                  */
            uint32_t            : 3;
      __IOM uint32_t MONTH      : 4;            /*!< Month (1..12)                                                             */
      __IOM uint32_t YEAR       : 12;           /*!< Year                                                                      */
      __IOM uint32_t DAY_ENA    : 1;            /*!< Enable day matching                                                       */
      __IOM uint32_t MONTH_ENA  : 1;            /*!< Enable month matching                                                     */
      __IOM uint32_t YEAR_ENA   : 1;            /*!< Enable year matching                                                      */
            uint32_t            : 1;
      __IOM uint32_t MATCH_ENA  : 1;            /*!< Global match enable. Don't change any other value while this
                                                     one is enabled                                                            */
      __IM  uint32_t MATCH_ACTIVE : 1;          /*!< MATCH_ACTIVE                                                              */
            uint32_t            : 2;
    } bit;
  } IRQ_SETUP_0;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt setup register 1                                                */
    
    struct {
      __IOM uint32_t SEC        : 6;            /*!< Seconds                                                                   */
            uint32_t            : 2;
      __IOM uint32_t MIN        : 6;            /*!< Minutes                                                                   */
            uint32_t            : 2;
      __IOM uint32_t HOUR       : 5;            /*!< Hours                                                                     */
            uint32_t            : 3;
      __IOM uint32_t DOTW       : 3;            /*!< Day of the week                                                           */
            uint32_t            : 1;
      __IOM uint32_t SEC_ENA    : 1;            /*!< Enable second matching                                                    */
      __IOM uint32_t MIN_ENA    : 1;            /*!< Enable minute matching                                                    */
      __IOM uint32_t HOUR_ENA   : 1;            /*!< Enable hour matching                                                      */
      __IOM uint32_t DOTW_ENA   : 1;            /*!< Enable day of the week matching                                           */
    } bit;
  } IRQ_SETUP_1;
  
  union {
    __IOM uint32_t reg;                         /*!< RTC register 1.                                                           */
    
    struct {
      __IM  uint32_t DAY        : 5;            /*!< Day of the month (1..31)                                                  */
            uint32_t            : 3;
      __IM  uint32_t MONTH      : 4;            /*!< Month (1..12)                                                             */
      __IM  uint32_t YEAR       : 12;           /*!< Year                                                                      */
            uint32_t            : 8;
    } bit;
  } RTC_1;
  
  union {
    __IOM uint32_t reg;                         /*!< RTC register 0 Read this before RTC 1!                                    */
    
    struct {
      __IM  uint32_t SEC        : 6;            /*!< Seconds                                                                   */
            uint32_t            : 2;
      __IM  uint32_t MIN        : 6;            /*!< Minutes                                                                   */
            uint32_t            : 2;
      __IM  uint32_t HOUR       : 5;            /*!< Hours                                                                     */
            uint32_t            : 3;
      __IM  uint32_t DOTW       : 3;            /*!< Day of the week                                                           */
            uint32_t            : 5;
    } bit;
  } RTC_0;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw Interrupts                                                            */
    
    struct {
      __IM  uint32_t RTC        : 1;            /*!< RTC                                                                       */
            uint32_t            : 31;
    } bit;
  } INTR;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable                                                          */
    
    struct {
      __IOM uint32_t RTC        : 1;            /*!< RTC                                                                       */
            uint32_t            : 31;
    } bit;
  } INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Force                                                           */
    
    struct {
      __IOM uint32_t RTC        : 1;            /*!< RTC                                                                       */
            uint32_t            : 31;
    } bit;
  } INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status after masking & forcing                                  */
    
    struct {
      __IM  uint32_t RTC        : 1;            /*!< RTC                                                                       */
            uint32_t            : 31;
    } bit;
  } INTS;
} RTC_Type;                                     /*!< Size = 48 (0x30)                                                          */


/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define RESETS_BASE                 0x4000C000UL
#define PSM_BASE                    0x40010000UL
#define CLOCKS_BASE                 0x40008000UL
#define PADS_BANK0_BASE             0x4001C000UL
#define PADS_QSPI_BASE              0x40020000UL
#define IO_QSPI_BASE                0x40018000UL
#define IO_BANK0_BASE               0x40014000UL
#define SYSINFO_BASE                0x40000000UL
#define PPB_BASE                    0xE0000000UL
#define SSI_BASE                    0x18000000UL
#define XIP_CTRL_BASE               0x14000000UL
#define SYSCFG_BASE                 0x40004000UL
#define XOSC_BASE                   0x40024000UL
#define PLL_SYS_BASE                0x40028000UL
#define PLL_USB_BASE                0x4002C000UL
#define UART0_BASE                  0x40034000UL
#define UART1_BASE                  0x40038000UL
#define ROSC_BASE                   0x40060000UL
#define WATCHDOG_BASE               0x40058000UL
#define DMA_BASE                    0x50000000UL
#define TIMER_BASE                  0x40054000UL
#define PWM_BASE                    0x40050000UL
#define ADC_BASE                    0x4004C000UL
#define I2C0_BASE                   0x40044000UL
#define I2C1_BASE                   0x40048000UL
#define SPI0_BASE                   0x4003C000UL
#define SPI1_BASE                   0x40040000UL
#define PIO0_BASE                   0x50200000UL
#define PIO1_BASE                   0x50300000UL
#define BUSCTRL_BASE                0x40030000UL
#define SIO_BASE                    0xD0000000UL
#define USB_BASE                    0x50110000UL
#define USB_DPRAM_BASE              0x50100000UL
#define TBMAN_BASE                  0x4006C000UL
#define VREG_AND_CHIP_RESET_BASE    0x40064000UL
#define RTC_BASE                    0x4005C000UL

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define RESETS                      ((RESETS_Type*)            RESETS_BASE)
#define PSM                         ((PSM_Type*)               PSM_BASE)
#define CLOCKS                      ((CLOCKS_Type*)            CLOCKS_BASE)
#define PADS_BANK0                  ((PADS_BANK0_Type*)        PADS_BANK0_BASE)
#define PADS_QSPI                   ((PADS_QSPI_Type*)         PADS_QSPI_BASE)
#define IO_QSPI                     ((IO_QSPI_Type*)           IO_QSPI_BASE)
#define IO_BANK0                    ((IO_BANK0_Type*)          IO_BANK0_BASE)
#define SYSINFO                     ((SYSINFO_Type*)           SYSINFO_BASE)
#define PPB                         ((PPB_Type*)               PPB_BASE)
#define SSI                         ((SSI_Type*)               SSI_BASE)
#define XIP_CTRL                    ((XIP_CTRL_Type*)          XIP_CTRL_BASE)
#define SYSCFG                      ((SYSCFG_Type*)            SYSCFG_BASE)
#define XOSC                        ((XOSC_Type*)              XOSC_BASE)
#define PLL_SYS                     ((PLL_SYS_Type*)           PLL_SYS_BASE)
#define PLL_USB                     ((PLL_SYS_Type*)           PLL_USB_BASE)
#define UART0                       ((UART0_Type*)             UART0_BASE)
#define UART1                       ((UART0_Type*)             UART1_BASE)
#define ROSC                        ((ROSC_Type*)              ROSC_BASE)
#define WATCHDOG                    ((WATCHDOG_Type*)          WATCHDOG_BASE)
#define DMA                         ((DMA_Type*)               DMA_BASE)
#define TIMER                       ((TIMER_Type*)             TIMER_BASE)
#define PWM                         ((PWM_Type*)               PWM_BASE)
#define ADC                         ((ADC_Type*)               ADC_BASE)
#define I2C0                        ((I2C0_Type*)              I2C0_BASE)
#define I2C1                        ((I2C0_Type*)              I2C1_BASE)
#define SPI0                        ((SPI0_Type*)              SPI0_BASE)
#define SPI1                        ((SPI0_Type*)              SPI1_BASE)
#define PIO0                        ((PIO0_Type*)              PIO0_BASE)
#define PIO1                        ((PIO0_Type*)              PIO1_BASE)
#define BUSCTRL                     ((BUSCTRL_Type*)           BUSCTRL_BASE)
#define SIO                         ((SIO_Type*)               SIO_BASE)
#define USB                         ((USB_Type*)               USB_BASE)
#define USB_DPRAM                   ((USB_DPRAM_Type*)         USB_DPRAM_BASE)
#define TBMAN                       ((TBMAN_Type*)             TBMAN_BASE)
#define VREG_AND_CHIP_RESET         ((VREG_AND_CHIP_RESET_Type*)  VREG_AND_CHIP_RESET_BASE)
#define RTC                         ((RTC_Type*)               RTC_BASE)

/** @} */ /* End of group Device_Peripheral_declaration */


#ifdef __cplusplus
}
#endif

#endif /* RP2040_H */


/** @} */ /* End of group RP2040 */

/** @} */ /* End of group Raspberry Pi */
